var documenterSearchIndex = {"docs":
[{"location":"concepts/mmisam_alg/#Multimodal-incremental-Smoothing-and-Mapping-Algorithm-1","page":"Multimodal iSAM Algorithm","title":"Multimodal incremental Smoothing and Mapping Algorithm","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Work In Progress","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Placeholder for details on how the approximate sum-product inference algorithm (mmiSAM) works.  Until then, see related literature for more details.","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Algorithm combats the so called curse-of-dimensionality on the basis of eight principles outlined in the thesis work \"Multimodal and Inertial Sensor Solutions to Navigation-type Factor Graphs\".","category":"page"},{"location":"concepts/mmisam_alg/#Joint-Probability-1","page":"Multimodal iSAM Algorithm","title":"Joint Probability","text":"","category":"section"},{"location":"concepts/mmisam_alg/#General-Factor-Graph-–-i.e.-non-Gaussian-and-multi-modal-1","page":"Multimodal iSAM Algorithm","title":"General Factor Graph – i.e. non-Gaussian and multi-modal","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"(Image: mmfgbt)","category":"page"},{"location":"concepts/mmisam_alg/#Inference-on-Bayes/Junction/Elimination-Tree-1","page":"Multimodal iSAM Algorithm","title":"Inference on Bayes/Junction/Elimination Tree","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"See tree solve video here.","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"<a href=\"http://vimeo.com/332507701\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/6412556/52549397-e4505d00-2da0-11e9-958b-e9034c30477c.png\" alt=\"Bayes/Junction tree example\" width=\"640\" border=\"0\" /></a>","category":"page"},{"location":"concepts/mmisam_alg/#Focussing-Computation-on-Tree-1","page":"Multimodal iSAM Algorithm","title":"Focussing Computation on Tree","text":"","category":"section"},{"location":"concepts/mmisam_alg/#Incremental-Updates-1","page":"Multimodal iSAM Algorithm","title":"Incremental Updates","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Recycling computations","category":"page"},{"location":"concepts/mmisam_alg/#Fixed-Lag-operation-1","page":"Multimodal iSAM Algorithm","title":"Fixed-Lag operation","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Also mixed priority solving","category":"page"},{"location":"concepts/mmisam_alg/#Federated-Tree-Solution-(Multi-session/agent)-1","page":"Multimodal iSAM Algorithm","title":"Federated Tree Solution (Multi session/agent)","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Tentatively see the multisession page.","category":"page"},{"location":"concepts/mmisam_alg/#Chapman-Kolmogorov-(Belief-Propagation-/-Sum-product)-1","page":"Multimodal iSAM Algorithm","title":"Chapman-Kolmogorov (Belief Propagation / Sum-product)","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"The main computational effort is to focus compute cycles on dominant modes exhibited by the data, by dropping low likelihood modes (although not indefinitely) and not sacrificing accuracy individual major features. ","category":"page"},{"location":"concepts/mmisam_alg/#Clique-State-Machine-1","page":"Multimodal iSAM Algorithm","title":"Clique State Machine","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"The CSM is used to govern the inference process within a clique.  A FunctionalStateMachine.jl implementation is used to allow for initialization / incremental-recycling / fixed-lag solving, and will soon support federated branch solving as well as unidirectional message passing for fixed-lead operations.  See the following video for an auto-generated–-using csmAnimate–-concurrent clique solving example.","category":"page"},{"location":"concepts/mmisam_alg/#Sequential-Nested-Gibbs-Method-1","page":"Multimodal iSAM Algorithm","title":"Sequential Nested Gibbs Method","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Current default inference method.","category":"page"},{"location":"concepts/mmisam_alg/#Convolution-Approximation-(Quasi-Deterministic)-1","page":"Multimodal iSAM Algorithm","title":"Convolution Approximation (Quasi-Deterministic)","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Convolution operations are used to implement the numerical computation of the probabilistic chain rule:","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"P(A B) = P(A  B)P(B)","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Proposal distributions are computed by means of (analytical or numerical – i.e. \"algebraic\") factor which defines a residual function:","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"delta  S times Eta rightarrow mathcalR","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"where S times Eta is the domain such that theta_i in S  eta sim P(Eta), and P(cdot) is a probability.","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Please follow, a more detailed description is on the convolutional computations page.","category":"page"},{"location":"concepts/mmisam_alg/#Stochastic-Product-Approx-of-Infinite-Functionals-1","page":"Multimodal iSAM Algorithm","title":"Stochastic Product Approx of Infinite Functionals","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"See mixed-manifold products presented in the literature section.","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"writing in progress","category":"page"},{"location":"concepts/mmisam_alg/#Mixture-Parametric-Method-1","page":"Multimodal iSAM Algorithm","title":"Mixture Parametric Method","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Work In Progress – deferred for progress on full functional methods, but likely to have Gaussian legacy algorithm with mixture model expansion added in the near future.","category":"page"},{"location":"concepts/mmisam_alg/#Full-Deterministic-Chapman-Kolmogorov-Super-Product-Method-1","page":"Multimodal iSAM Algorithm","title":"Full Deterministic Chapman-Kolmogorov Super Product Method","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Work in progress, likely to include Kernel Embedding and Homotopy Continuation methods for combining convolution and product operations as a concurrent calculation.","category":"page"},{"location":"concepts/2d_plotting/#Plotting-1","page":"Plotting (2D)","title":"Plotting","text":"","category":"section"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"Once the graph has been built, 2D plot visualizations are provided by RoMEPlotting.jl and KernelDensityEstimatePlotting.jl.  These visualizations tools are readily modifiable to highlight various aspects of mobile platform navigation.","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"note: Note\nPlotting packages can be installed separately.","category":"page"},{"location":"concepts/2d_plotting/#Quick-Start-1","page":"Plotting (2D)","title":"Quick Start","text":"","category":"section"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"A simple usage example:","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"using RoMEPlotting\n\ndrawPoses(fg)\n# If you have landmarks, you can instead call\n# drawPosesLandms(fg)\n\n# Draw the KDE for x0\nplotKDE(fg, :x0)\n# Draw the KDE's for x0 and x1\nplotKDE(fg, [:x0, :x1])","category":"page"},{"location":"concepts/2d_plotting/#Hexagonal-2D-SLAM-example-visualization-1","page":"Plotting (2D)","title":"Hexagonal 2D SLAM example visualization","text":"","category":"section"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"The major 2D plotting functions between RoMEPlotting.jl:","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"drawPoses\ndrawPosesLandms\ndrawSubmaps","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"and KernelDensityEstimatePlotting.jl:","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"plotKDE / plot(::KernelDensityEstimate)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"This simplest example for visualizing a 2D robot trajectory–-such as first running the Hexagonal 2D SLAM example–-","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"# Assuming some fg<:AbstractDFG has been loaded/constructed\n# ...\n\nusing RoMEPlotting\n\n# For Juno/Jupyter style use\npl = drawPosesLandms(fg)\n\n# For scripting use-cases you can export the image\nGadfly.draw(PDF(\"/tmp/test.pdf\", 20cm, 10cm),pl)  # or PNG(...)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"(Image: test)","category":"page"},{"location":"concepts/2d_plotting/#Density-Contour-Map-1","page":"Plotting (2D)","title":"Density Contour Map","text":"","category":"section"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"KernelDensityEstimatePlotting (as used in RoMEPlotting) provides an interface to visualize belief densities as counter plots. The following basic example shows some of features of the API, where plotKDE(..., dims=[1;2]) implies the marginal over variables (x,y):","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"using RoME, Distributions\nusing RoMEPlotting\n\nfg = initfg()\naddVariable!(fg, :x0, Pose2)\naddFactor!(fg, [:x0], PriorPose2(MvNormal(zeros(3), eye(3))))\naddVariable!(fg, :x1, Pose2)\naddFactor!(fg, [:x0;:x1], Pose2Pose2(MvNormal([10.0;0;0], eye(3))))\n\nensureAllInitialized!(fg)\n\n# plot one contour density\nplX0 = plotKDE(fg, :x0, dims=[1;2])\n# using Gadfly; Gadfly.draw(PNG(\"/tmp/testX0.png\",20cm,10cm),plX0)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"(Image: test)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"The contour density relates to the distribution of marginal samples as seen with this Gadfly.jl package histogram comparison.","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"pl1 = drawPoses(fg, to=0);\nX0 = getVal(fg, :x0);\npl2 = Gadfly.plot(x=X0[1,:],y=X0[2,:], Geom.hexbin);\nplH = hstack(pl1, pl2)\n# Gadfly.draw(PNG(\"/tmp/testH.png\",20cm,10cm),plH)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"(Image: testh)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"note: Note\nRed and Green lines represent Port and Starboard direction of Pose2, respectively.","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"Multiple beliefs can be plotted at the same time, while setting levels=4 rather than the default value:","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"plX1 = plotKDE(fg, [:x0; :x1], dims=[1;2], levels=4)\n# Gadfly.draw(PNG(\"/tmp/testX1.png\",20cm,10cm),plX1)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"(Image: testx1)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"One dimensional (such as Θ) or a stack of all plane projections is also available:","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"plTh = plotKDE(fg, [:x0; :x1], dims=[3], levels=4)\n# Gadfly.draw(PNG(\"/tmp/testTh.png\",20cm,10cm),plTh)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"(Image: testth)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"plAll = plotKDE(fg, [:x0; :x1], levels=3)\n# Gadfly.draw(PNG(\"/tmp/testX1.png\",20cm,15cm),plAll)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"(Image: testall)","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"note: Note\nThe functions hstack and vstack is provided through the Gadfly package and allows the user to build a near arbitrary composition of plots.","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"Please see KernelDensityEstimatePlotting package source for more features.","category":"page"},{"location":"concepts/2d_plotting/#Interactive-Gadfly.jl-Plots-1","page":"Plotting (2D)","title":"Interactive Gadfly.jl Plots","text":"","category":"section"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"See the following two discussions on Interactive 2D plots:","category":"page"},{"location":"concepts/2d_plotting/#","page":"Plotting (2D)","title":"Plotting (2D)","text":"Interactivity\nInteractive-SVGs","category":"page"},{"location":"principles/bayestreePrinciples/#Principle:-Bayes-tree-prototyping-1","page":"Bayes (Junction) tree","title":"Principle: Bayes tree prototyping","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"This page describes how to visualize, study, test, and compare Bayes (Junction) tree concepts with special regard for variable ordering.","category":"page"},{"location":"principles/bayestreePrinciples/#Why-a-Bayes-(Juntion)-tree-1","page":"Bayes (Junction) tree","title":"Why a Bayes (Juntion) tree","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The tree is algebraicly equivalent–-but acyclic–-structure to the factor graph:  i.) Inference is easier on on acyclic graphs; ii.) We can exploit Smart Message Passing benefits (known from the full conditional independence structure encoded in the tree), since the tree represents the \"complete form\" when marginalizing each variable one at a time (also known as elimination game, marginalization, also related to smart factors).  In loose terms, the Bayes (Junction) tree has implicit access to all Schur complements (if it parametric and linearized) of each variable to all others.  Please see this page more information regarding advanced topics on the Bayes tree.","category":"page"},{"location":"principles/bayestreePrinciples/#What-is-a-Bayes-(Junction)-tree-1","page":"Bayes (Junction) tree","title":"What is a Bayes (Junction) tree","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The Bayes tree data structure is a rooted and directed Junction tree (maximal elimination clique tree). It allows for exact inference to be carried out by leveraging and exposing the variables' conditional independence and, very interestingly, can be directly associated with the sparsity pattern exhibited by a system's factorized upper triangular square root information matrix (see picture below).","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"(Image: graph and matrix analagos)","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"Following this matrix-graph parallel, the picture also shows what the associated matrix interpretation is for a factor graph (~first order expansion in the form of a measurement Jacobian) and its corresponding Markov random field (sparsity pattern corresponding to the information matrix).","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The procedure for obtaining the Bayes (Junction) tree is outlined in the figure shown below (factor graph to chrodal Bayes net via bipartite elimination game, and chordal Bayes net to Bayes tree via maximum cardinality search algorithm).","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"(Image: add the fg2net2tree outline)","category":"page"},{"location":"principles/bayestreePrinciples/#Constructing-a-Tree-1","page":"Bayes (Junction) tree","title":"Constructing a Tree","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"Trees and factor graphs are separated in the implementation, allowing the user to construct multiple different trees from one factor graph except for a few temporary values in the factor graph.","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"using IncrementalInference # RoME or Caesar will work too\n\n## construct a distributed factor graph object\nfg = initfg()\n# add variables and factors\n# ...\n\n## build the tree\ntree = wipeBuildNewTree!(fg)","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The temporary values are wiped from the distributed factor graph object fg<:AbstractDFG and a new tree is constructed.  This wipeBuildNewTree! call can be repeated as many times the user desires and results should be consistent for the same factor graph structure (regardless of numerical values contained within).","category":"page"},{"location":"principles/bayestreePrinciples/#Visualizing-1","page":"Bayes (Junction) tree","title":"Visualizing","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"IncrementalInference.jl includes functions for visualizing the Bayes tree, and uses outside packages such as GraphViz (standard) and Latex tools (experimental, optional) to do so.  ","category":"page"},{"location":"principles/bayestreePrinciples/#GraphViz-1","page":"Bayes (Junction) tree","title":"GraphViz","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"drawTree(tree, show=true) # , filepath=\"/tmp/caesar/mytree.pdf\"","category":"page"},{"location":"principles/bayestreePrinciples/#Latex-Tikz-(Optional)-1","page":"Bayes (Junction) tree","title":"Latex Tikz (Optional)","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"EXPERIMENTAL, requiring special import.","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"First make sure the following packages are installed on your system:","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"$ sudo apt-get install texlive-pictures dot2tex\n$ pip install dot2tex","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"Then in Julia you should be able to do:","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"import IncrementalInference: generateTexTree\n\ngenerateTexTree(tree)","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"An example Bayes (Junction) tree representation obtained through generateTexTree(tree) for the sample factor graph shown above can be seen in the following image.","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/27132241/69210722-9e0c0380-0b53-11ea-9462-7964844b89b1.png\" width=\"200\" border=\"0\" />\n</p>","category":"page"},{"location":"principles/bayestreePrinciples/#Visualizing-Clique-Adjacency-Matrix-1","page":"Bayes (Junction) tree","title":"Visualizing Clique Adjacency Matrix","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"It is also possible to see the upward message passing variable/factor association matrix for each clique, requiring the Gadfly.jl package:","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"using Gadfly\n\nspyCliqMat(tree, :x1) # provided by IncrementalInference\n\n#or embedded in graphviz\ndrawTree(tree, imgs=true, show=true)","category":"page"},{"location":"principles/bayestreePrinciples/#Variable-Ordering-1","page":"Bayes (Junction) tree","title":"Variable Ordering","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#Getting-the-AMD-Variable-Ordering-1","page":"Bayes (Junction) tree","title":"Getting the AMD Variable Ordering","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The variable ordering is described as a ::Vector{Symbol}.","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"vo = getEliminationOrder(fg)\ntree = buildTreeFromOrdering!(fg, vo)","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The temporary elimination values in fg can be reset with (currently rather aggressive):","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"resetFactorGraphNewTree!(fg)","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"These steps are combined in a wrapper function:","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"resetBuildTreeFromOrder!(fg, vo)","category":"page"},{"location":"principles/bayestreePrinciples/#Manipulating-the-Variable-Ordering-1","page":"Bayes (Junction) tree","title":"Manipulating the Variable Ordering","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"vo = [:x1; :l3; :x2; ...]","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"Note that a list of variables or factors can be obtained through the ls and related functions:","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"Variables:","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"unsorted = ls(fg)\nunsorted = ls(fg, Pose2) # by variable type\nunsorted = ls(fg, r\"x\")  # by regex\nunsorted = intersect(ls(fg, r\"x\"), ls(fg, Pose2))  # by regex\n\n# sorting\nsorted = sortDFG(unsorted)  # deprecated name sortVarNested(unsorted)","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"Factors:","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"unsorted = lsf(fg)\nunsorted = ls(fg, Pose2Point2BearingRange)","category":"page"},{"location":"principles/bayestreePrinciples/#Interfacing-with-'mmisam'-Solver-1","page":"Bayes (Junction) tree","title":"Interfacing with 'mmisam' Solver","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The regular solver used in IIF is:","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"tree, smt, hist = solveTree!(fg)","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"where a new tree is constructed internally.  In order to recycle computations from a previous tree, the following interface can be used:","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"tree, smt, hist = solveTree!(fg, tree)","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"which will replace the tree object pointer to the new tree object after solution.  The following parmaters (set before calling solveTree!) will show the solution progress on the tree visualization:","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"getSolverParams(fg).drawtree = true\ngetSolverParams(fg).showtree = true","category":"page"},{"location":"principles/bayestreePrinciples/#Clique-State-Machine-1","page":"Bayes (Junction) tree","title":"Clique State Machine","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The mmisam solver is based on a state machine design to handle the inter and intra clique operations during a variety of situations.  Use of the clique state machine (CSM) makes debugging, development, verification, and modification of the algorithm real easy.  Contact us for any support regarding modifications to the default algorithm.  For pre-docs on working with CSM, please see IIF #443.","category":"page"},{"location":"principles/bayestreePrinciples/#STATUS-of-a-Clique-1","page":"Bayes (Junction) tree","title":"STATUS of a Clique","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"CSM currently uses the following statusses for each of the cliques during the inference process.","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"[:initialized;:upsolved;:marginalized;:downsolved;:uprecycled]","category":"page"},{"location":"principles/bayestreePrinciples/#Bayes-Tree-Legend-(from-IIF)-1","page":"Bayes (Junction) tree","title":"Bayes Tree Legend (from IIF)","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The color legend is currently recorded in an issue thread here.","category":"page"},{"location":"principles/bayestreePrinciples/#","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"Blank / white – uninitialized,\nRed – CPU working on clique's Chapman-Kolmogorov inference (up or down),\nLight red – completed upsolve,\nTomato – partial dimension upsolve but finished,\nGreen – trying to initialize,\nBrown – initialized but not solved yet (likely child cliques that depend on downward autoinit msgs),\nPurple – blocking on autoinit for more parent/sibling derived down msgs,\nTurquoise – blocking for on parent for downsolve msgs,\nLight blue – completed downsolve,\nBlue – fully marginalized clique that will not be updated during upsolve (maybe downsolved),\nOrange – recycled clique upsolve solution from previous tree passed into solveTree!","category":"page"},{"location":"examples/basic_slamedonut/#Range-only-SLAM,-Singular-–-i.e.-\"Under-Constrained\"-1","page":"Under-defined Trilateration, 2D","title":"Range only SLAM, Singular – i.e. \"Under-Constrained\"","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"This tutorial describes a range-only system where there are always more variable dimensions than range measurements made. The error distribution over ranges could be nearly anything, but are restricted to Gaussian-only in this example to illustrate an alternative point – other examples show inference results where highly non-Gaussian error distributions are used. A file version of this example is provided in RoME/examples here. The one pre-baked result of this of this singular range-only illustration can be seen in this video:  Multi-modal range only example (click here or image for full Vimeo),","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"<a href=\"http://vimeo.com/190052649\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/JuliaRobotics/IncrementalInference.jl/master/doc/images/mmisamvid01.gif\" alt=\"IMAGE ALT TEXT HERE\" width=\"640\" border=\"0\" /></a>","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"This example is also available as a script here in RoME.jl.","category":"page"},{"location":"examples/basic_slamedonut/#Quick-Install-1","page":"Under-defined Trilateration, 2D","title":"Quick Install","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"If you already have Julia 1.0 or above, alternatively see complete installation instructions here:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"julia> ]\n(v1.0) pkg> add RoME, Distributed\n(v1.0) pkg> add RoMEPlotting","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The Julia REPL/console is sufficient for this example (copy-paste from this page).  Note that more involved work in Julia is simplified by using the Juno IDE.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Note A recent test (May 2019, IIF v0.6.0) showed a possible bug was introduced with one of the solver upgrades.  THe figures shown on this example page are still, however, valid.  Previous versions of the solver, such as IncrementalInference v0.4.x and v0.5.x, should still work as expected.  Follow progress on issue 335 here as bug is being resolved.  Previous versions of the solver can be installed with the package manager, for example: (v1.0) pkg> add IncrementalInference@v0.5.7.  Please comment for further details.","category":"page"},{"location":"examples/basic_slamedonut/#Loading-The-Data-1","page":"Under-defined Trilateration, 2D","title":"Loading The Data","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Starting a Juno IDE or Julia REPL session, the ground truth positions for vehicle positions GTp and landmark positions GTl can be loaded into memory directly with these values:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"GTp = Dict{Symbol, Vector{Float64}}()\nGTp[:l100] = [0.0;0]\nGTp[:l101] = [50.0;0]\nGTp[:l102] = [100.0;0]\nGTp[:l103] = [100.0;50.0]\nGTp[:l104] = [100.0;100.0]\nGTp[:l105] = [50.0;100.0]\nGTp[:l106] = [0.0;100.0]\nGTp[:l107] = [0.0;50.0]\nGTp[:l108] = [0.0;-50.0]\nGTp[:l109] = [0.0;-100.0]\nGTp[:l110] = [50.0;-100.0]\nGTp[:l111] = [100.0;-100.0]\nGTp[:l112] = [100.0;-50.0]\n\nGTl = Dict{Symbol, Vector{Float64}}()\nGTl[:l1] = [10.0;30]\nGTl[:l2] = [30.0;-30]\nGTl[:l3] = [80.0;40]\nGTl[:l4] = [120.0;-50]","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"NOTE 1. that by using location indicators :l1, :l2, ... or :l100, :l101, ... is of practical benefit when visualizing with existing RoMEPlotting functions.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"NOTE 2. Landmarks must be in range before range measurements can be made to them.","category":"page"},{"location":"examples/basic_slamedonut/#Creating-the-Factor-Graph-with-Point2-1","page":"Under-defined Trilateration, 2D","title":"Creating the Factor Graph with Point2","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The first step is to load the required modules, and in our case we will add a few Julia processes to help with the compute later on.  ","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"# add more julia processes\nusing Distributed\nnprocs() < 4 ? addprocs(4-nprocs()) : nothing\n\n# tell Julia that you want to use these modules/namespaces\nusing RoME","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"NOTE Julia uses just-in-time compiling (unless pre-compiled), therefore each time a new function call on a Julia process will be slow, but all following calls to the same functions will be as fast as the statically compiled code.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"This example exclusively uses Point2 variable node types, which have dimension 2 and represent [x, y] position estimates in the world frame.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Next construct the factor graph containing the first pose :l100 (without any knowledge of where it is) and three measured beacons/landmarks :l1,:l2,:l3 – with prior location knowledge for :l1 and :l2:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"# create the factor graph object\nfg = initfg()\n\n# first pose with no initial estimate\naddVariable!(fg, :l100, Point2)\n\n# add three landmarks\naddVariable!(fg, :l1, Point2)\naddVariable!(fg, :l2, Point2)\naddVariable!(fg, :l3, Point2)\n\n# and put priors on :l101 and :l102\naddFactor!(fg, [:l1;], PriorPoint2(MvNormal(GTl[:l1], Matrix{Float64}(LinearAlgebra.I,2,2))) )\naddFactor!(fg, [:l2;], PriorPoint2(MvNormal(GTl[:l2], Matrix{Float64}(LinearAlgebra.I,2,2))) )","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The PriorPoint2 is assumed to be a multivariate normal distribution of covariance Matrix(LinearAlgebra.I,2,2), as well as a weighting factor of [1.0].","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"NOTE API changed to PriorPoint2(::T) where T <: SamplableBelief = PriorPoint2{T} to accept distribution objects and discard (standard in RoME v0.1.5 – see issue 72 here).","category":"page"},{"location":"examples/basic_slamedonut/#Adding-Range-Measurements-Between-Variables-1","page":"Under-defined Trilateration, 2D","title":"Adding Range Measurements Between Variables","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Next we connect the three range measurements from the vehicle location :l0 to the three beacons, respectively – and consider that the range measurements are completely relative between the vehicle and beacon position estimates:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"# first range measurement\nrhoZ1 = norm(GTl[:l1]-GTp[:l100])\nppr = Point2Point2Range( Normal(rhoZ1, 2.0) )\naddFactor!(fg, [:l100;:l1], ppr)\n\n# second range measurement\nrhoZ2 = norm(GTl[:l2]-GTp[:l100])\nppr = Point2Point2Range( Normal(rhoZ2, 3.0) )\naddFactor!(fg, [:l100; :l2], ppr)\n\n# second range measurement\nrhoZ3 = norm(GTl[:l3]-GTp[:l100])\nppr = Point2Point2Range( Normal(rhoZ3, 3.0) )\naddFactor!(fg, [:l100; :l3], ppr)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The ranging measurement standard deviation of 2.0 or 3.0 is taken, assuming a Gaussian measurement assumption.   Again, any distribution could have been used. The factor graph should look as follows:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"drawGraph(fg) # show the factor graph","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: rangesonlyfirstfg)","category":"page"},{"location":"examples/basic_slamedonut/#Inference-and-Visualizations-1","page":"Under-defined Trilateration, 2D","title":"Inference and Visualizations","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"At this point we can call the solver start interpreting the first results:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"tree, smt, hist = solveTree!(fg)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The factor graph figure above showed the structure between variables and factors. In order to see the numerical values contained in the factor graph, a set of tools are provided by the RoMEPlotting and KernelDensityEstimatePlotting packages. For more details, please see the dedicated visualization discussion here.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"First look at the two landmark positions :l1, :l2 at (10.0,30),(30.0,-30) respectively.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"using RoMEPlotting\n\nplotKDE(fg, [:l1;:l2], dims=[1;2])","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl1_2)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Similarly, the belief estimate for the first vehicle position :l100 is bi-modal, due to the intersection of two range measurements:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"plotKDE(fg, :l100, dims=[1;2], levels=6)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl100)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"An alternative plotting interface can also be used, that shows a histogram of desired elements instead:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"drawLandms(fg, from=1, to=101, contour=false, drawhist=true)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testlall)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Notice the ring of particles which represents the belief on the third beacon/landmark :l3, which was not constrained by a prior factor. Instead, the belief over the position of :l3 is being estimated simultaneous to estimating the vehicle position :l100.","category":"page"},{"location":"examples/basic_slamedonut/#Implicit-Growth-and-Decay-of-Modes-(i.e.-Hypotheses)-1","page":"Under-defined Trilateration, 2D","title":"Implicit Growth and Decay of Modes (i.e. Hypotheses)","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Next consider the vehicle moving a distance of 50 units–-and by design the direction of travel is not known–-to the next true position. The video above gives away the vehicle position with the cyan line, showing travel in the shape of a lower case 'e'. The following function handles (pseudo odometry) factors as range-only between positions and range-only measurement factors to beacons as the vehice travels.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"function vehicle_drives_to!(fgl::G, pos_sym::Symbol, GTp::Dict, GTl::Dict; measurelimit::R=150.0) where {G <: AbstractDFG, R <: Real}\n  currvar = union(ls(fgl)...)\n  prev_sym = Symbol(\"l$(maximum(Int[parse(Int,string(currvar[i])[2:end]) for i in 2:length(currvar)]))\")\n  if !(pos_sym in currvar)\n    println(\"Adding variable vertex $pos_sym, not yet in fgl<:AbstractDFG.\")\n    addVariable!(fgl, pos_sym, Point2)\n    @show rho = norm(GTp[prev_sym] - GTp[pos_sym])\n    ppr = Point2Point2Range( Normal(rho, 3.0) )\n    addFactor!(fgl, [prev_sym;pos_sym], ppr)\n  else\n    @warn \"Variable node $pos_sym already in the factor graph.\"\n  end\n  beacons = keys(GTl)\n  for ll in beacons\n    rho = norm(GTl[ll] - GTp[pos_sym])\n    # Check for feasible measurements:  vehicle within 150 units from the beacons/landmarks\n    if rho < measurelimit\n      ppr = Point2Point2Range( Normal(rho, 3.0) )\n      if !(ll in currvar)\n        println(\"Adding variable vertex $ll, not yet in fgl<:AbstractDFG.\")\n        addVariable!(fgl, ll, Point2)\n      end\n      addFactor!(fgl, [pos_sym;ll], ppr)\n    end\n  end\n  nothing\nend","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"After pasting (or running) this function in Julia, a new member definition vehicle_drives_to! can be used line any other function.  Julia will handle the just-in-time compiling for the type specific function required and cach the static code for repeat executions.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"NOTE The exclamation mark at the end of the function name has no syntactic significance in Julia, since the full UTF8 character set is available for functions or variables.  Instead, the exclamation serves as a Julia community convention to tell the caller that this function will modify the contents of at least some of the variables being passed into it – in this case the factor graph fg will be modified.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Now the actual driving event can be added to the factor graph:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"#drive to location :l101, then :l102\nvehicle_drives_to!(fg, :l101, GTp, GTl)\nvehicle_drives_to!(fg, :l102, GTp, GTl)\n\n# see the graph\ndrawGraph(fg, engine=\"neato\")","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"NOTE The distance traveled could be any combination of accrued direction and speeds, however, a straight line Gaussian error model is used to keep the visual presentation of this example as simple as possible.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The marginal posterior estimates are found by repeating inference over the factor graph, followed drawing all vehicle locations as a contour map:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"# solve and show message passing on Bayes (Juntion) tree\ngetSolverParams(fg).drawtree=true\ngetSolverParams(fg).showtree=true\ntree, smt, hist = solveTree!(fg)\n\n# draw all vehicle locations\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 0:2], dims=[1;2])\n# Gadfly.draw(PDF(\"/tmp/testL100_102.pdf\", 20cm, 10cm),pl) # for storing image to disk\n\npl = plotKDE(fg, [:l3;:l4], dims=[1;2], levels=4)\n# Gadfly.draw(PNG(\"/tmp/testL3_4.png\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Notice how the vehicle positions have two hypotheses, one left to right and one diagonal right to bottom left – both are valid solutions!","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl100_102)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The two \"free\" beacons/landmarks :l3,:l4 still have several modes each, implying insufficient data to constrain either to a strong unimodal belief.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl3_4)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"\nvehicle_drives_to!(fg, :l103, GTp, GTl)\nvehicle_drives_to!(fg, :l104, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 0:4], dims=[1;2])\n# Gadfly.draw(PDF(\"/tmp/testL100_104.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Moving up to position :l104 still shows strong multiodality in the vehicle position estimates:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl100_105)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"vehicle_drives_to!(fg, :l105, GTp, GTl)\nvehicle_drives_to!(fg, :l106, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\n\nvehicle_drives_to!(fg, :l107, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\n\nvehicle_drives_to!(fg, :l108, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\n\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 2:8], dims=[1;2], levels=6)\n# Gadfly.draw(PDF(\"/tmp/testL103_108.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Next we see a strong return to a single dominant mode in all vehicle position estimates, owing to the increased measurements to beacons/landmarks as well as more unimodal estimates in :l3, :l4 beacon/landmark positions.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"vehicle_drives_to!(fg, :l109, GTp, GTl)\nvehicle_drives_to!(fg, :l110, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\n\nvehicle_drives_to!(fg, :l111, GTp, GTl)\nvehicle_drives_to!(fg, :l112, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\n\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 7:12], dims=[1;2])\n# Gadfly.draw(PDF(\"/tmp/testL106_112.pdf\", 20cm, 10cm),pl)\n\npl = plotKDE(fg, [:l1;:l2;:l3;:l4], dims=[1;2], levels=4)\n# Gadfly.draw(PDF(\"/tmp/testL1234.pdf\", 20cm, 10cm),pl)\n\npl = drawLandms(fg, from=100)\n# Gadfly.draw(PDF(\"/tmp/testLocsAll.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Several location belief estimates exhibit multimodality as the trajectory progresses (not shown), but collapses and finally collapses to a stable set of dominant position estimates.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl106_112)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Landmark estimates are also stable at one estimate:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl1234)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"In addition, the SLAM 2D landmark visualization can be re-used to plot more information at once:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"# pl = drawLandms(fg, from=100, to=200)\n# Gadfly.draw(PDF(\"/tmp/testLocsAll.pdf\", 20cm, 10cm),pl)\n\npl = drawLandms(fg)\n# Gadfly.draw(PDF(\"/tmp/testAll.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testall)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"This example used the default of N=200 particles per marginal belief. By increasing the number to N=300 throughout the test many more modes and interesting features can be explored, and we refer the reader to an alternative and longer discussion on the same example, in Chapter 6 here.","category":"page"},{"location":"examples/examples/#Examples-1","page":"Caesar Examples","title":"Examples","text":"","category":"section"},{"location":"examples/examples/#Basics-1","page":"Caesar Examples","title":"Basics","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"The following examples demonstrate the conceptual operation of Caesar, highlighting specific features of the framework and its use.","category":"page"},{"location":"examples/examples/#Continuous-Scalar-1","page":"Caesar Examples","title":"Continuous Scalar","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"This abstract example illustrates how IncrementalInference enables algebraic relations between stochastic variables, and how a final posterior belief estimate is calculated from several pieces of information.","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Continuous Scalar Example","category":"page"},{"location":"examples/examples/#Hexagonal-2D-1","page":"Caesar Examples","title":"Hexagonal 2D","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"A simple 2D robot trajectory example is expanded below using techniques developed in simultaneous localization and mapping (SLAM).","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Hexagonal 2D Example","category":"page"},{"location":"examples/examples/#Fixed-Lag-Solving-Hexagonal2D-Revisited-1","page":"Caesar Examples","title":"Fixed-Lag Solving - Hexagonal2D Revisited","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Hexagonal Fixed-Lag","category":"page"},{"location":"examples/examples/#A-Under-Constrained-Solution-(unforced-multimodality)-1","page":"Caesar Examples","title":"A Under-Constrained Solution (unforced multimodality)","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"This tutorial describes a range-only system where there are always more variable dimensions than range measurements made. The error distribution over ranges could be nearly anything, but are restricted to Gaussian-only in this example to illustrate an alternative point – other examples show inference results where highly non-Gaussian error distributions are used.","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Multi-modal range only example (click here or image for full Vimeo):   ","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"http://vimeo.com/190052649\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/JuliaRobotics/IncrementalInference.jl/master/doc/images/mmisamvid01.gif\" alt=\"IMAGE ALT TEXT HERE\" width=\"640\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Multi-Modal Under-Constrained Example","category":"page"},{"location":"examples/examples/#Uncertain-Data-Associations,-a-Multi-Modal-Solution-(forced-multi-hypothesis)-1","page":"Caesar Examples","title":"Uncertain Data Associations, a Multi-Modal Solution (forced multi-hypothesis)","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Documentation in progress, in the mean time please see the addFactor!(..., multihypo=[1.0; 0.5;0.5]) feature for 50/50 uncertainty. Similarly for trinary or higher multi-hypotheses per factor.","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"TODO: add example.","category":"page"},{"location":"examples/examples/#Adding-Factors-Simple-Factor-Design-1","page":"Caesar Examples","title":"Adding Factors - Simple Factor Design","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Caesar can be extended with new variables and factors without changing the core code. An example of this design pattern is provided in this example.","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Defining New Variables and Factor","category":"page"},{"location":"examples/examples/#Adding-Factors-DynPose-Factor-1","page":"Caesar Examples","title":"Adding Factors - DynPose Factor","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Intermediate Example: Adding Dynamic Factors and Variables","category":"page"},{"location":"examples/examples/#Application-Examples-and-Demos-1","page":"Caesar Examples","title":"Application Examples and Demos","text":"","category":"section"},{"location":"examples/examples/#Multi-session-Use-case-1","page":"Caesar Examples","title":"Multi-session Use-case","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Multi-session Turtlebot example of the second floor in the Stata Center:   ","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/turtlemultisession.gif\" alt=\"Turtlebot Multi-session animation\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"See reference for more details:","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Fourie, D., Claassens, S., Pillai, S., Mata, R., Leonard, J.: \"SLAMinDB: Centralized graph databases for mobile robotics\", IEEE International Conference on Robotics and Automation (ICRA), Singapore, 2017.","category":"page"},{"location":"examples/examples/#Simulated-Ambiguous-SONAR-in-3D-1","page":"Caesar Examples","title":"Simulated Ambiguous SONAR in 3D","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Intersection of ambiguous elevation angle from planar SONAR sensor:   ","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"http://vimeo.com/198237738\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/rovasfm02.gif\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Bi-modal belief   ","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"http://vimeo.com/198872855\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/rovyaw90.gif\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#Synthetic-Aperture-Sonar-SLAM-1","page":"Caesar Examples","title":"Synthetic Aperture Sonar SLAM","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"The full functional (approximate sum-product) inference approach can be used to natively imbed single hydrophone acoustic waveform data into highly non-Gaussian SAS factors–that implicitly perform beamforming/micro-location–-for a simultaneous localization and mapping solution (image links to video):","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"https://www.youtube.com/watch?v=_RfXLQ67N4o\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/6412556/52547229-3048d500-2d94-11e9-8a46-811316a45283.png\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"See reference for more details:","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Cheung, M., Fourie, D., Rypkema, N., Vaz Teixeira, P., Schmidt, H., and Leonard, J.: \"Non-Gaussian SLAM utilizing Synthetic Aperture Sonar\", Intl. Conf. On Robotics and Automation (ICRA), IEEE, Montreal, 2019.","category":"page"},{"location":"examples/examples/#Probabilistic-Data-Association-(Uncertain-loop-closures)-1","page":"Caesar Examples","title":"Probabilistic Data Association (Uncertain loop closures)","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Example where the standard multihypothesis addFactor!(.., multihypo=[1.0;0.5;0.5]) interface is used.  This is from the Kitti driving dataset.  Video here.","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"https://www.youtube.com/watch?v=9hEonD8KDrs\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/6412556/53611733-9065b680-3b9d-11e9-8b0f-cb292a25fbb3.png\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"See reference for more details:","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Doherty, K., Fourie, D., Leonard, J.: \"Multimodal Semantic SLAM with Probabilistic Data Association\", Intl. Conf. On Robotics and Automation (ICRA), IEEE, Montreal, 2019.","category":"page"},{"location":"examples/examples/#More-Examples-1","page":"Caesar Examples","title":"More Examples","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Please see examples folders for Caesar and RoME for more examples, with expanded documentation in the works.","category":"page"},{"location":"examples/basic_continuousscalar/#Tutorials-1","page":"ContinuousScalar as 1D Example","title":"Tutorials","text":"","category":"section"},{"location":"examples/basic_continuousscalar/#IncrementalInference.jl-ContinuousScalar-1","page":"ContinuousScalar as 1D Example","title":"IncrementalInference.jl ContinuousScalar","text":"","category":"section"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This tutorial illustrates how IncrementalInference enables algebraic relations (residual functions) between multiple stochastic variables, and how a final posterior belief estimate is calculated from several pieces of information. The application of this tutorial is presented in abstract from which the user is free to imagine any system of relationships:  For example, a robot driving in a one dimensional world; or a time traveler making uncertain jumps forwards and backwards in time. The tutorial implicitly shows a multi-modal uncertainty introduced and transmitted. The tutorial also illustrates consensus through an additional piece of information, which reduces all stochastic variable marginal beliefs to unimodal only beliefs. The example will also illustrate the use of non-Gaussian beliefs and global inference. Lastly, the tutorial demonstrates how automatic initialization of variables works.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This tutorial requires IncrementalInference v0.3.0+, RoME v0.1.0, RoMEPlotting packages be installed. In addition, the optional GraphViz package will allow easy visualization of the FactorGraph object structure.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"To start, the two major mathematical packages are brought into scope.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"using IncrementalInference\n# using Distributions # automatically reexported by IncrementalInference","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Guidelines for developing your own functions are discussed here in Adding Variables and Factors, and we note that mechanizations and manifolds required for robotic simultaneous localization and mapping (SLAM) has been tightly integrated with the expansion package RoME.jl.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The next step is to describe the inference problem with a graphical model of type IncrementalInference.FactorGraph. The first step is to create an empty factor graph object and start populating it with variable nodes. The variable nodes are identified by Symbols, namely :x0, :x1, :x2, :x3.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"# Start with an empty factor graph\nfg = initfg()\n\n# add the first node\naddVariable!(fg, :x0, ContinuousScalar)\n\n# this is unary (prior) factor and does not immediately trigger autoinit of :x0.\naddFactor!(fg, [:x0], Prior(Normal(0,1)))","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Factor graphs are bipartite graphs with factors that act as mathematical structure between interacting variables. After adding node :x0, a singleton factor of type Prior (which was defined by the user earlier) is 'connected to' variable node :x0. This unary factor is taken as a Distributions.Normal distribution with zero mean and a standard devitation of 1. Graphviz can be used to visualize the factor graph structure, although the package is not installed by default – $ sudo apt-get install graphviz. Furthermore, the writeGraphPdf member definition is given at the end of this tutorial, which allows the user to store the graph image in graphviz supported image types.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"writeGraphPdf(fg)\n# writeGraphPdf(fg, file=\"fgx01.pdf\") # file=\"fgx01.png\"","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The two node factor graph is shown in the image below.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx0.png\" width=\"120\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Automatic initialization of variables depend on how the factor graph model is constructed. This tutorial demonstrates this behavior by first showing that :x0 is not initialized:","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"@show isInitialized(fg, :x0) # false","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Why is :x0 not initialized? Since no other variable nodes have been 'connected to' (or depend) on :x0 and future intentions of the user are unknown, the initialization of :x0 is deferred until the latest possible moment. IncrementalInference.jl assumes that the user will generally populate new variable nodes with most of the associated factors before moving to the next variable. By delaying initialization of a new variable (say :x0) until a second newer uninitialized variable (say :x1) depends on :x0, the IncrementalInference algorithms hope to then initialize :x0 with the more information from previous and surrounding variables and factors. Also note that initialization of variables is a local operation based only on the neighboring nodes – global inference will over the entire graph is shows later in this tutorial.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"By adding :x1 and connecting it through the LinearConditional and Normal distributed factor, the automatic initialization of :x0 is triggered.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addVariable!(fg, :x1, ContinuousScalar)\n# P(Z | :x1 - :x0 ) where Z ~ Normal(10,1)\naddFactor!(fg, [:x0, :x1], LinearConditional(Normal(10.0,1)))\n@show isInitialized(fg, :x0) # true","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Note that the automatic initialization of :x0 is aware that :x1 is not initialized and therefore only used the Prior(Normal(0,1)) unary factor to initialize the marginal belief estimate for :x0. The structure of the graph has now been updated to two variable nodes and two factors.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx01.png\" width=\"240\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Global inference requires that the entire factor graph be initialized before the numerical belief computation algorithms can be performed. Notice how the new :x1 variable is not yet initialized:","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"@show isInitialized(fg, :x1) # false","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The RoMEPlotting.jl package allows visualization (plotting) of the belief state over any of the variable nodes. Remember the first time executions are slow given required code compilation, and that future versions of these package will use more precompilation to reduce first execution running cost.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"using RoMEPlotting\n\nplotKDE(fg, :x0)","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx0.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"By forcing the initialization of :x1 and plotting its belief estimate,","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"ensureAllInitialized!(fg)\nplotKDE(fg, [:x0, :x1])","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"the predicted influence of the P(Z| X1 - X0) = LinearConditional(Normal(10, 1)) is shown by the red trace.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx01.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The red trace (predicted belief of :x1) is noting more than the approximated convolution of the current marginal belief of :x0 with the conditional belief described by P(Z | X1 - X0).","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Another ContinuousScalar variable :x2 is 'connected' to :x1 through a more complicated MixtureLinearConditional likelihood function.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addVariable!(fg, :x2, ContinuousScalar)\nmmo = MixtureLinearConditional([Rayleigh(3); Uniform(30,55)], Categorical([0.4; 0.6]))\naddFactor!(fg, [:x1, :x2], mmo)","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx012.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The mmo variable illustrates how a near arbitrary mixture probability distribution can be used as a conditional relationship between variable nodes in the factor graph. In this case, a 40%/60% balance of a Rayleigh and truncated Uniform distribution which acts as a multi-modal conditional belief. Interpret carefully what a conditional belief of this nature actually means.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Following the tutorial's practical example frameworks (robot navigation or time travel), this multi-modal belief implies that moving from one of the probable locations in :x1 to a location in :x2 by some processes defined by mmo=P(Z | X2, X1) is uncertain to the same 40%/60% ratio. In practical terms, collapsing (through observation of an event) the probabilistic likelihoods of the transition from :x1 to :x2 may result in the :x2 location being at either 15-20, or 40-65-ish units. The predicted belief over :x2 is illustrated by plotting the predicted belief (green trace), after forcing initialization.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"ensureAllInitialized!(fg)\nplotKDE(fg, [:x0, :x1, :x2])","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx012.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Adding one more variable :x3 through another LinearConditional(Normal(-50,1))","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addVariable!(fg, :x3, ContinuousScalar)\naddFactor!(fg, [:x2, :x3], LinearConditional(Normal(-50, 1)))","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"expands the factor graph to to four variables and four factors.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx0123.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This part of the tutorial shows how a unimodal likelihood (conditional belief) can transmit the bimodal belief currently contained in :x2.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"ensureAllInitialized!(fg)\nplotKDE(fg, [:x0, :x1, :x2, :x3])","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Notice the blue trace (:x3) is a shifted and slightly spread out version of the initialized belief on :x2, through the convolution with the conditional belief P(Z | X2, X3).","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx0123.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Global inference over the entire factor graph has still not occurred, and will at this stage produce roughly similar results to the predicted beliefs shown above. Only by introducing more information into the factor graph can inference extract more precise marginal belief estimates for each of the variables. A final piece of information added to this graph is a factor directly relating :x3 with :x0.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addFactor!(fg, [:x3, :x0], LinearConditional(Normal(40, 1)))","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Pay close attention to what this last factor means in terms of the probability density traces shown in the previous figure. The blue trace for :x3 has two major modes, one that overlaps with :x0, :x1 near 0 and a second mode further to the left at -40. The last factor introduces a shift LinearConditional(Normal(40,1)) which essentially aligns the left most mode of :x3 back onto :x0.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx0123c.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This last factor forces a mode selection through consensus. By doing global inference, the new information obtained in :x3 will be equally propagated to :x2 where only one of the two modes will remain.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Global inference is achieved with local computation using two function calls, as follows.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"tree, smt, hist = solveTree!(fg)\n\n# and visualization\nplotKDE(fg, [:x0, :x1, :x2, :x3])","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The resulting posterior marginal beliefs over all the system variables are:","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx0123infr.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"It is import to note that although this tutorial ends with all marginal beliefs having near Gaussian shape and are unimodal, that the package supports multi-modal belief estimates during both the prediction and global inference processes. In fact, many of the same underlying inference functions are involved with the automatic initialization process and the global multi-modal iSAM inference procedure. This concludes the ContinuousScalar tutorial particular to the IncrementalInference package.","category":"page"},{"location":"vis_func_ref/#Visualization-Function-Reference-1","page":"Visualization Reference","title":"Visualization Function Reference","text":"","category":"section"},{"location":"vis_func_ref/#","page":"Visualization Reference","title":"Visualization Reference","text":"Pages = [\n    \"vis_func_ref.md\"\n]\nDepth = 3","category":"page"},{"location":"vis_func_ref/#RoMEPlotting-1","page":"Visualization Reference","title":"RoMEPlotting","text":"","category":"section"},{"location":"vis_func_ref/#","page":"Visualization Reference","title":"Visualization Reference","text":"drawLandms\ndrawPoses\ndrawPosesLandms\nplotKDE\nplotPose\nplotProductVsKDE","category":"page"},{"location":"vis_func_ref/#RoMEPlotting.drawLandms","page":"Visualization Reference","title":"RoMEPlotting.drawLandms","text":"drawLandms(fg; from, to, minnei, meanmax, lbls, showmm, drawhist, contour, levels, manualColor, c, MM, point_size, regexLandmark, resampleGaussianFit)\n\n\n2D plot of landmarks, assuming :l1, :l2, ... :ln.  Use from and to to control the range of landmarks n to include.\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#RoMEPlotting.drawPoses","page":"Visualization Reference","title":"RoMEPlotting.drawPoses","text":"drawPoses(fg; from, to, meanmax, lbls, drawhist, spscale, drawTriads, contour, levels, regexPoses, line_width, manualColor)\n\n\n2D plot of all poses, assuming poses are labeled from `::Symbol type :x0, :x1, ..., :xn.  Use to and from to limit the range of numbers n to be drawn.  The underlying histogram can be enabled or disabled, and the size of maximum-point belief estimate cursors can be controlled with spscale.\n\nFuture:\n\nRelax to user defined pose labeling scheme, for example :p1, :p2, ...\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#RoMEPlotting.drawPosesLandms","page":"Visualization Reference","title":"RoMEPlotting.drawPosesLandms","text":"drawPosesLandms(fgl; from, to, minnei, meanmax, lbls, drawTriads, spscale, contour, levels, drawhist, MM, xmin, xmax, ymin, ymax, showmm, window, point_size, line_width, regexLandmark, regexPoses, manualColor)\n\n\n2D plot of both poses and landmarks contained in factor graph.  Assuming poses and landmarks are labeled :x1, :x2, ... and :l0, :l1, ..., respectively.  The rnage of numbers to include can be controlled with from and to along with other keyword functionality for manipulating the plot.\n\nNotes\n\nassumes :l1, :l2, ... for landmarks – not using tags=[:LANDMARK] here yet (TODO).\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#KernelDensityEstimatePlotting.plotKDE","page":"Visualization Reference","title":"KernelDensityEstimatePlotting.plotKDE","text":"A peneric KDE plotting function that allows marginals of higher dimensional beliefs and various keyword options.\n\nExample:\n\np = kde!(randn(3,100))\n\nplotKDE(p)\nplotKDE(p, dims=[1;2], levels=3)\nplotKDE(p, dims=[1])\n\nq = kde!(5*randn(3,100))\nplotKDE([p;q])\nplotKDE([p;q], dims=[1;2], levels=3)\nplotKDE([p;q], dims=[1])\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#RoMEPlotting.plotPose","page":"Visualization Reference","title":"RoMEPlotting.plotPose","text":"plotPose(pt, pp)\nplotPose(pt, pp, title; levels, c, axis, scale, overlay, hdl)\n\n\nPlot pose belief as contour information on visually sensible manifolds.\n\n\n\n\n\nplotPose(fgl, syms; levels, c, axis, scale, show, filepath, app, hdl)\n\n\nExample: pl = plotPose(fg, [:x1; :x2; :x3])\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#RoMEPlotting.plotProductVsKDE","page":"Visualization Reference","title":"RoMEPlotting.plotProductVsKDE","text":"Analysis function to compare KDE plots between the factor graph centric product of a variable with current value stored in the factor graph object.\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#","page":"Visualization Reference","title":"Visualization Reference","text":"WORK IN PROGRESS  Not all functions have been added to this directory yet.","category":"page"},{"location":"func_ref/#Function-Reference-1","page":"Caesar's Reference","title":"Function Reference","text":"","category":"section"},{"location":"func_ref/#","page":"Caesar's Reference","title":"Caesar's Reference","text":"Pages = [\n    \"func_ref.md\"\n]\nDepth = 3","category":"page"},{"location":"func_ref/#","page":"Caesar's Reference","title":"Caesar's Reference","text":"WORK IN PROGRESS  Not all functions have been added to this directory yet.","category":"page"},{"location":"func_ref/#Caesar-1","page":"Caesar's Reference","title":"Caesar","text":"","category":"section"},{"location":"func_ref/#","page":"Caesar's Reference","title":"Caesar's Reference","text":"appendvertbigdata!\nconsoleaskuserfordb\ndb2jld\nexecuteQuery\nfetchrobotdatafirstpose\nfetchsubgraph!\nfindExistingMSConstraints\ngetAllLandmarkNeoIDs\ngetBigDataElement\ngetExVertexNeoIDs\ngetLandmOtherSessNeoIDs\ngetLocalSubGraphMultisession\ngetPoseExVertexNeoIDs\ngetVertNeoIDs!\ngetfirstpose\ngetnewvertdict\ngetprpt2kde\nhasBigDataElement\ninsertrobotdatafirstpose!\nremoveNeo4jID\nresetentireremotesession\nrmInstMultisessionPriors!\nstandardcloudgraphsetup\nupdatenewverts!\nwhosNear2D\nwhosNear3D","category":"page"},{"location":"func_ref/#Caesar.appendvertbigdata!","page":"Caesar's Reference","title":"Caesar.appendvertbigdata!","text":"appendvertbigdata!(cloudGraph, cv, description, data)\n\n\nAppend big data element into current blob store and update associated global vertex information.\n\n\n\n\n\nappendvertbigdata!(fgl, vert, description, data)\n\n\nAppend big data element into current blob store and update associated global vertex information.\n\n\n\n\n\nappendvertbigdata!(fg, sym, descr, data)\n\nAppend big data element into current blob store using parent appendvertbigdata!, but here specified by symbol of variable node in the FactorGraph. Note the default data layer api definition. User must define dlapi to refetching the  vertex from the data layer. localapi avoids repeated network database fetches.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.consoleaskuserfordb","page":"Caesar's Reference","title":"Caesar.consoleaskuserfordb","text":"consoleaskuserfordb(; nparticles, drawdepth, clearslamindb, multisession, drawedges)\n\n\nObtain database addresses and login credientials from STDIN, as well as a few case dependent options.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.db2jld","page":"Caesar's Reference","title":"Caesar.db2jld","text":"db2jld(cgl::CloudGraph, session::AbstractString, filename::AbstractString)\n\nFetch and save a FactorGraph session to a jld, using CloudGraph object and session definition.\n\n\n\n\n\ndb2jld(filename::AbstractString; addrdict::NothingUnion{Dict{AbstractString, AbstractString}}=nothing )\n\nFetch and save a FactorGraph session to a jld, using or asking STDIN for credentials in the addrdict field.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.executeQuery","page":"Caesar's Reference","title":"Caesar.executeQuery","text":"executeQuery(connection, query)\n\n\nRun Neo4j Cypher queries on the cloudGraph database, and return Tuple with the unparsed (results, loadresponse). Throws an error if the query fails.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.fetchrobotdatafirstpose","page":"Caesar's Reference","title":"Caesar.fetchrobotdatafirstpose","text":"fetchrobotdatafirstpose(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString)\n\nReturn dict of JSON parsed \"robot_description\" field as was inserted by counterpart insertrobotdatafirstpose! function. Used for storing general robot specific data in easily accessible manner.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.fetchsubgraph!","page":"Caesar's Reference","title":"Caesar.fetchsubgraph!","text":"fetchsubgraph!(fgl, cvs; numneighbors)\n\n\nFetch and insert list of CloudVertices into FactorGraph object, up to neighbor depth.\n\n\n\n\n\nfetchsubgraph!(fgl, neoids; numneighbors)\n\n\nFetch and insert list of Neo4j IDs into FactorGraph object, up to neighbor depth.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.findExistingMSConstraints","page":"Caesar's Reference","title":"Caesar.findExistingMSConstraints","text":"Return Dict{Symbol, Int} of vertex symbol to Neo4j node ID of MULTISESSION constraints in this fgl.sessionname.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getAllLandmarkNeoIDs","page":"Caesar's Reference","title":"Caesar.getAllLandmarkNeoIDs","text":"getAllLandmarkNeoIDs(lm2others, slm)\n\n\nReturn Vector{Int} of Neo4j vertex IDs relating to symbol, as listed in lm2others.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getBigDataElement","page":"Caesar's Reference","title":"Caesar.getBigDataElement","text":"getBigDataElement(vertex, description)\n\n\nWalk through vertex bigDataElements and return the last matching description.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getExVertexNeoIDs","page":"Caesar's Reference","title":"Caesar.getExVertexNeoIDs","text":"getExVertexNeoIDs(conn; label, solvable, backendset, session, robot, user, reqbackendset)\n\n\nReturn array of tuples with ExVertex IDs and Neo4j IDs for vertices with label in session.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getLandmOtherSessNeoIDs","page":"Caesar's Reference","title":"Caesar.getLandmOtherSessNeoIDs","text":"getLandmOtherSessNeoIDs{T <: AbstractString}(::CloudGraph, session::T=\"\", robot::T=\"\", user::T=\"\", multisessions=Vector{T}())\n\nReturn dict of dict of Neo4j vertex IDs by session and landmark symbols.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getLocalSubGraphMultisession","page":"Caesar's Reference","title":"Caesar.getLocalSubGraphMultisession","text":"getLocalSubGraphMultisession(cg, lm2others; session, robot, user, numneighbors)\n\n\nReturn subgraph copy of type FactorGraph contaning values from session in lm2others, and Vector{Symbol} of primary key symbols used for graph exstraction.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getPoseExVertexNeoIDs","page":"Caesar's Reference","title":"Caesar.getPoseExVertexNeoIDs","text":"getPoseExVertexNeoIDs(conn; solvable, backendset, session, reqbackendset)\n\n\nReturn array of tuples with ExVertex IDs and Neo4j IDs for all poses.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getVertNeoIDs!","page":"Caesar's Reference","title":"Caesar.getVertNeoIDs!","text":"getVertNeoIDs!(::CloudGraph, res::Dict{Symbol, Int}; session::AbstractString=\"NA\", robot::AbstractString=\"NA\", user::AbstractString=\"NA\")\n\nInsert into and return dict res with Neo4j IDs of ExVertex labels as stored per session in Neo4j database.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getfirstpose","page":"Caesar's Reference","title":"Caesar.getfirstpose","text":"getfirstpose(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString)\n\nReturn Tuple{Symbol, Int} of first pose symbol and Neo4j node ID.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getnewvertdict","page":"Caesar's Reference","title":"Caesar.getnewvertdict","text":"getnewvertdict(conn, session::AbstractString, robot::AbstractString, user::AbstractString)\n\nReturn a dictionary with frtend and mongo_keys json string information for :NEWDATA elements in Neo4j database.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getprpt2kde","page":"Caesar's Reference","title":"Caesar.getprpt2kde","text":"getprp2kde(::CloudGraph, neoids::Vector{Int}; N::Int=100)\n\nReturn PriorPoint2DensityNH with N points based on beliefs of neoids, and equal share null hypothesis between length(neoids)+1 beliefs.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.hasBigDataElement","page":"Caesar's Reference","title":"Caesar.hasBigDataElement","text":"hasBigDataElement(vertex, description)\n\n\nReturn true if vertex has bigDataElements with matching description.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.insertrobotdatafirstpose!","page":"Caesar's Reference","title":"Caesar.insertrobotdatafirstpose!","text":"insertrobotdatafirstpose!(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString, robotdict::Dict)\n\nSaves robotdict via JSON to first pose in a SESSION in the database. Used for storing general robot specific data in easily accessible manner. Can fetch later retrieve same dict with counterpart fetchrobotdatafirstpose function.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.removeNeo4jID","page":"Caesar's Reference","title":"Caesar.removeNeo4jID","text":"removeNeo4jID(cg::CloudGraph, neoid=-1)\n\nRemove node from Neo4j according to Neo4j Node ID. Big data elements that may be associated with this node are not removed.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.resetentireremotesession","page":"Caesar's Reference","title":"Caesar.resetentireremotesession","text":"resetentireremotesession(conn, session, robot, user; segment)\n\n\nmatch (n:session) remove n.backendset, n.solvable, n.data, n.bigData, n.label, n.packedType, n.exVertexId, n.shape, n.width set n :NEWDATA return n\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.rmInstMultisessionPriors!","page":"Caesar's Reference","title":"Caesar.rmInstMultisessionPriors!","text":"rmInstMultisessionPriors!(::CloudGraph; session<:AbstractString=, multisessions::Vector{<:AbstractString}= )\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.standardcloudgraphsetup","page":"Caesar's Reference","title":"Caesar.standardcloudgraphsetup","text":"standardcloudgraphsetup(; addrdict, nparticles, drawdepth, drawedges, clearslamindb, multisession)\n\n\nConnect to databases via network according to addrdict, or ask user for credentials and return active cloudGraph object, as well as addrdict.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.updatenewverts!","page":"Caesar's Reference","title":"Caesar.updatenewverts!","text":"Convert vertices of session in Neo4j DB with Caesar.jl's required data elements in preparation for MM-iSAMCloudSolve process.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.whosNear2D","page":"Caesar's Reference","title":"Caesar.whosNear2D","text":"whosNear2D(cg, session, robot, user; x, y, yaw, dist, angle)\n\n\nFind vertices near the point specified and return dictionary of symbol to Neo4j ID pairs.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.whosNear3D","page":"Caesar's Reference","title":"Caesar.whosNear3D","text":"whosNear3D(cg, session, robot, user; x, y, z, roll, pitch, yaw, dist, angle)\n\n\nFind vertices near the point specified and return dictionary of symbol to Neo4j ID pairs.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#RoME-1","page":"Caesar's Reference","title":"RoME","text":"","category":"section"},{"location":"func_ref/#","page":"Caesar's Reference","title":"Caesar's Reference","text":"getRangeKDEMax2D\ninitFactorGraph!\naddOdoFG!","category":"page"},{"location":"func_ref/#RoME.getRangeKDEMax2D","page":"Caesar's Reference","title":"RoME.getRangeKDEMax2D","text":"getRangeKDEMax2D(cgl::CloudGraph, session::AbstractString, vsym1::Symbol, vsym2::Symbol)\n\nCalculate the cartesian distange between two vertices in the graph, by session and symbol names, and by maximum belief point.\n\n\n\n\n\ngetRangeKDEMax2D(fgl, vsym1, vsym2)\n\n\nCalculate the cartesian distance between two vertices in the graph using their symbol name, and by maximum belief point.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#RoME.initFactorGraph!","page":"Caesar's Reference","title":"RoME.initFactorGraph!","text":"Initialize a factor graph object as Pose2, Pose3, or neither and returns variable and factor symbols as array.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#RoME.addOdoFG!","page":"Caesar's Reference","title":"RoME.addOdoFG!","text":"addOdoFG!(fg, n, DX, cov; N, solvable, labels)\n\n\nCreate a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x<k+1> for new node new node and constraint factor are returned as a tuple.\n\n\n\n\n\naddOdoFG!(fgl, odo; N, solvable, labels)\n\n\nCreate a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x<k+1> for new node new node and constraint factor are returned as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference-1","page":"Caesar's Reference","title":"IncrementalInference","text":"","category":"section"},{"location":"func_ref/#","page":"Caesar's Reference","title":"Caesar's Reference","text":"addVariable!\naddFactor!\napproxCliqMarginalUp!\napproxConv\nareCliqChildrenNeedDownMsg\nareCliqVariablesAllMarginalized\nassignTreeHistory!\nasyncTreeInferUp!\nattemptTreeSimilarClique\nblockCliqUntilChildrenHaveUpStatus\nbuildSubgraphFromLabels\nbuildTreeFromOrdering!\nbuildCliqSubgraphDown\nbuildCliqSubgraphUp\nchildCliqs\ncliqGibbs\ncliqHistFilterTransitions\ncliqInitSolveUpByStateMachine!\ncompareAllVariables\ncompareFactorGraphs\ncompareSimilarFactors\ncompareSimilarVariables\ncompareSubsetFactorGraph\ncompareVariable\nconvert2packedfunctionnode\ncsmAnimate\ncycleInitByVarOrder!\ndecodefg\ndeleteFactor!\ndeleteVariable!\ndoautoinit!\ndoCliqUpSolve!\ndownGibbsCliqueDensity\ndownMsgPassingRecursive\ndrawCliqSubgraphUpMocking\ndwnMsg\nencodefg\nfifoFreeze!\nfilterHistAllToArray\nfindRelatedFromPotential\nfmcmc!\ngetCliq\ngetCliqAllVarIds\ngetCliqAllVarSyms\ngetCliqAssocMat\ngetCliqChildMsgsUp\ngetCliqDepth\ngetCliqDownMsgsAfterDownSolve\ngetCliqFrontalVarIds\ngetCliqVarInitOrderUp\ngetCliqMat\ngetCliqMsgsDown\ngetCliqMsgsUp\ngetCliqOrderUpSolve\ngetCliqParentMsgDown\ngetCliqSeparatorVarIds\ngetCliqSiblings\ngetCliqSolveHistory\ngetCliqVarIdsPriors\ngetCliqVars\ngetCliqVarSingletons\ngetCurrentWorkspaceFactors\ngetCurrentWorkspaceVariables\ngetKDE\ngetLogPath\ngetManifolds\ngetParent\ngetTreeAllFrontalSyms\ngetTreeCliqSolveOrderUp\ngetTreeCliqsSolverHistories\ngetVal\ngetVariableDim\ngetVariableInferredDim\ngetVertKDE\ngetUpMsgs\ngetDwnMsgs\nhasCliq\nhasOrphans\ninitfg\ninitInferTreeUp!\nisCliqMarginalizedFromVars\nisCliqReadyInferenceUp\nisInitialized\nisMarginalized\nisTreeSolved\nisPartial\nisVariable\nlocalProduct\nls\nlsf\nlsfPriors\nlsRear\nmakeCsmMovie\nmanualinit!\nparentCliq\npackFromLocalPotentials!\npredictVariableByFactor\nprepBatchTree!\nprepCliqInitMsgsDown!\nprintCliqHistorySummary\nprintgraphmax\nproductpartials!\nprodmultiplefullpartials\nprodmultipleonefullpartials\nresetBuildTreeFromOrder!\nresetCliqSolve!\nresetData!\nresetTreeCliquesForUpSolve!\nresetVariable!\nsandboxCliqResolveStep\nsavejld\nsetCliqAsMarginalized!\nsetCliqStatus!\nsetDwnMsg!\nsetfreeze!\nsetTreeCliquesMarginalized!\nsetUpMsg!\nsetValKDE!\nsetVariableInitialized!\nsetVariableInferDim!\nshowVariable\nsolveCliq!\nsolveCliqWithStateMachine!\nsolveTree!\ntransferUpdateSubGraph!\ntreeProductDwn\ntreeProductUp\nunfreezeVariablesAll!\ndontMarginalizeVariablesAll!\nupdateFGBT!\nupdateTreeCliquesAsMarginalizedFromVars!\nupGibbsCliqueDensity\nupMsg\nwipeBuildNewTree!\nwriteGraphPdf\nresetVariableAllInitializations!","category":"page"},{"location":"func_ref/#DistributedFactorGraphs.addVariable!","page":"Caesar's Reference","title":"DistributedFactorGraphs.addVariable!","text":"addVariable!(dfg, lbl, softtype; N, autoinit, solvable, dontmargin, labels, smalldata, checkduplicates, initsolvekeys)\n\n\nAdd a variable node lbl::Symbol to fg::AbstractDFG, as softtype<:InferenceVariable.\n\nExample\n\nfg = initfg()\naddVariable!(fg, :x0, Pose2)\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#DistributedFactorGraphs.addFactor!","page":"Caesar's Reference","title":"DistributedFactorGraphs.addFactor!","text":"addFactor!(dfg, Xi, usrfnc; multihypo, solvable, labels, autoinit, threadmodel, maxparallel)\n\n\nAdd factor with user defined type <: FunctorInferenceType to the factor graph object. Define whether the automatic initialization of variables should be performed.  Use order sensitive multihypo keyword argument to define if any variables are related to data association uncertainty.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.approxCliqMarginalUp!","page":"Caesar's Reference","title":"IncrementalInference.approxCliqMarginalUp!","text":"approxCliqMarginalUp!(fgl, treel, csym)\napproxCliqMarginalUp!(fgl, treel, csym, onduplicate; N, dbg, iters, drawpdf, multiproc, logger)\n\n\nApproximate Chapman-Kolmogorov transit integral and return separator marginals as messages to pass up the Bayes (Junction) tree, along with additional clique operation values for debugging.\n\nNotes\n\nonduplicate=true by default internally uses deepcopy of factor graph and Bayes tree, and does not update the given objects.  Set false to update fgl and treel during compute.\n\nFuture\n\nTODO: internal function chain is too long and needs to be refactored for maintainability.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.approxConv","page":"Caesar's Reference","title":"IncrementalInference.approxConv","text":"approxConv(dfg, fc, towards)\napproxConv(dfg, fc, towards, measurement; N)\n\n\nDraw samples from the approximate convolution of towards symbol using factor fct relative to the other variables.  In addition the api can be adjusted to recover the data from elsewhere (likely to be replaced/removed in the future).\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.areCliqChildrenNeedDownMsg","page":"Caesar's Reference","title":"IncrementalInference.areCliqChildrenNeedDownMsg","text":"areCliqChildrenNeedDownMsg(children)\n\n\nReturn true if any of the children cliques have status :needdownmsg.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.areCliqVariablesAllMarginalized","page":"Caesar's Reference","title":"IncrementalInference.areCliqVariablesAllMarginalized","text":"areCliqVariablesAllMarginalized(subfg, cliq)\n\n\nReturn true if all variables in clique are considered marginalized (and initialized).\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.assignTreeHistory!","page":"Caesar's Reference","title":"IncrementalInference.assignTreeHistory!","text":"assignTreeHistory!(treel, cliqHistories)\n\n\nAfter solving, clique histories can be inserted back into the tree for later reference. This function helps do the required assigment task.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.asyncTreeInferUp!","page":"Caesar's Reference","title":"IncrementalInference.asyncTreeInferUp!","text":"Perform tree based initialization of all variables not yet initialized in factor graph as non-blocking method.\n\nNotes:\n\nTo simplify debugging, this method does not include the usual @ sync around all the state machine async processes.\nExtract the error stack with a fetch on the failed process return by this function.\n\nRelated\n\ninitInferTreeUp!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.attemptTreeSimilarClique","page":"Caesar's Reference","title":"IncrementalInference.attemptTreeSimilarClique","text":"attemptTreeSimilarClique(othertree, seeksSimilar)\n\n\nSpecial internal function to try return the clique data if succesfully identified in othertree::AbstractBayesTree, based on contents of seeksSimilar::BayesTreeNodeData.\n\nNotes\n\nUsed to identify and skip similar cliques (i.e. recycle computations)\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.blockCliqUntilChildrenHaveUpStatus","page":"Caesar's Reference","title":"IncrementalInference.blockCliqUntilChildrenHaveUpStatus","text":"blockCliqUntilChildrenHaveUpStatus(tree, prnt)\nblockCliqUntilChildrenHaveUpStatus(tree, prnt, logger)\n\n\nBlock the thread until child cliques of prnt::TreeClique have finished attempting upward initialization – i.e. have status result. Return ::Dict{Symbol} indicating whether next action that should be taken for each child clique.\n\nNotes:\n\nSee status options at getCliqStatusUp(..).\nCan be called multiple times\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.buildTreeFromOrdering!","page":"Caesar's Reference","title":"IncrementalInference.buildTreeFromOrdering!","text":"buildTreeFromOrdering!(dfg, p; drawbayesnet, maxparallel, solvable)\n\n\nBuild Bayes/Junction/Elimination tree from a given variable ordering.\n\n\n\n\n\nbuildTreeFromOrdering!(dfg, p; drawbayesnet, maxparallel)\n\n\nBuild Bayes/Junction/Elimination tree from a given variable ordering.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.childCliqs","page":"Caesar's Reference","title":"IncrementalInference.childCliqs","text":"childCliqs(treel, cliq)\n\n\nReturn a vector of child cliques to cliq.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.cliqGibbs","page":"Caesar's Reference","title":"IncrementalInference.cliqGibbs","text":"cliqGibbs(fg, cliq, vsym, inmsgs, N, dbg, manis)\ncliqGibbs(fg, cliq, vsym, inmsgs, N, dbg, manis, logger)\n\n\nPerform one step of the minibatch clique Gibbs operation for solving the Chapman-Kolmogov trasit integral – here involving separate approximate functional convolution and product operations.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.cliqHistFilterTransitions","page":"Caesar's Reference","title":"IncrementalInference.cliqHistFilterTransitions","text":"cliqHistFilterTransitions(hist, nextfnc)\n\n\nReturn state machine transition steps from history such that the nextfnc::Function.\n\nRelated:\n\ngetCliqSolveHistory, printCliqHistorySummary, filterHistAllToArray, sandboxCliqResolveStep\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.cliqInitSolveUpByStateMachine!","page":"Caesar's Reference","title":"IncrementalInference.cliqInitSolveUpByStateMachine!","text":"cliqInitSolveUpByStateMachine!(dfg, tree, cliq; N, oldcliqdata, drawtree, show, incremental, limititers, upsolve, downsolve, recordhistory, delay, logger)\n\n\nEXPERIMENTAL: perform upward inference using a state machine solution approach.\n\nNotes:\n\nwill call on values from children or parent cliques\ncan be called multiple times\nAssumes all cliques in tree are being solved simultaneously and in similar manner.\nState machine rev.1 – copied from first TreeBasedInitialization.jl.\nDoesn't do partial initialized state properly yet.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.csmAnimate","page":"Caesar's Reference","title":"IncrementalInference.csmAnimate","text":"csmAnimate(fg, tree, cliqsyms; frames, rmfirst)\n\n\nAnimate multiple clique state machines on the same graphviz visualization.  Renders according to linear time for all provided histories.\n\nExample:\n\nusing Caesar\n\n# build a factor graph\nfg = initfg()\n# addVariable!(...)\n# addFactor!(...)\n# ...\n\nfsy = getTreeAllFrontalSyms(fg, tree) # for later use\n# perform inference to find the factor graph marginal posterior estimates\ntree, smt, hist = solveTree!(fg, recordcliqs=fsy)\n\n# generate frames in standard location /tmp/caesar/csmCompound/\n#  requires: sudo apt-get install graphviz\ncsmAnimate(fg, tree, fsy, frames=500)\n\n# to render and show from default location (might require)\n#  sudo apt-get install ffmpeg vlc\n\n# .ogv [Totem Ubuntu default]\nBase.rm(\"/tmp/caesar/csmCompound/out.ogv\")\nrun(`ffmpeg -r 10 -i /tmp/caesar/csmCompound/csm_%d.png -c:v libtheora -vf fps=25 -pix_fmt yuv420p -vf \"scale=trunc(iw/2)*2:trunc(ih/2)*2\" -q 10 /tmp/caesar/csmCompound/out.ogv`)\nrun(`totem /tmp/caesar/csmCompound/out.ogv`)\n\n# h.264 [VLC not default]\nBase.rm(\"/tmp/caesar/csmCompound/out.mp4\")\nrun(`ffmpeg -r 10 -i /tmp/caesar/csmCompound/csm_%d.png -c:v libx264 -vf fps=25 -pix_fmt yuv420p -vf \"scale=trunc(iw/2)*2:trunc(ih/2)*2\" /tmp/caesar/csmCompound/out.mp4`)\nrun(`vlc /tmp/caesar/csmCompound/out.mp4`)\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.cycleInitByVarOrder!","page":"Caesar's Reference","title":"IncrementalInference.cycleInitByVarOrder!","text":"cycleInitByVarOrder!(subfg, varorder; logger)\n\n\nCycle through var order and initialize variables as possible in subfg::AbstractDFG. Return true if something was updated.\n\nNotes:\n\nassumed subfg is a subgraph containing only the factors that can be used.\nincluding the required up or down messages\nintended for both up and down initialization operations.\n\nDev Notes\n\nShould monitor updates based on the number of inferred & solvable dimensions\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.doautoinit!","page":"Caesar's Reference","title":"IncrementalInference.doautoinit!","text":"doautoinit!(dfg, xi; singles, N, logger)\n\n\nEXPERIMENTAL: initialize target variable xi based on connected factors in the factor graph fgl.  Possibly called from addFactor!, or doCliqAutoInitUp! (?).\n\nNotes:\n\nSpecial carve out for multihypo cases, see issue 427.\n\nDevelopment Notes:\n\nTarget factor is first (singletons) or second (dim 2 pairwise) variable vertex in xi.\n\nTODO use DFG properly with local operations and DB update at end.\nTODO get faster version of isInitialized for database version.\nTODO: Persist this back if we want to here.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.doCliqUpSolve!","page":"Caesar's Reference","title":"IncrementalInference.doCliqUpSolve!","text":"doCliqUpSolve!(subfg, tree, cliq; multiproc, logger)\n\n\nUpdate subfg<:AbstractDFG according to internal computations for a full upsolve.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.downGibbsCliqueDensity","page":"Caesar's Reference","title":"IncrementalInference.downGibbsCliqueDensity","text":"downGibbsCliqueDensity(fg, cliq, dwnMsgs)\ndownGibbsCliqueDensity(fg, cliq, dwnMsgs, N)\ndownGibbsCliqueDensity(fg, cliq, dwnMsgs, N, MCMCIter)\ndownGibbsCliqueDensity(fg, cliq, dwnMsgs, N, MCMCIter, dbg)\ndownGibbsCliqueDensity(fg, cliq, dwnMsgs, N, MCMCIter, dbg, usemsgpriors)\ndownGibbsCliqueDensity(fg, cliq, dwnMsgs, N, MCMCIter, dbg, usemsgpriors, logger)\n\n\nPerform Chapman-Kolmogorov transit integral approximation for cliq in downward pass direction.\n\nNotes\n\nOnly update frontal variables of the clique.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.drawCliqSubgraphUpMocking","page":"Caesar's Reference","title":"IncrementalInference.drawCliqSubgraphUpMocking","text":"drawCliqSubgraphUpMocking(fgl, treel, frontalSym; show, filepath, engine, viewerapp)\n\n\nConstruct (new) subgraph and draw the subgraph associated with clique frontalSym::Symbol.\n\nNotes\n\nSee drawGraphCliq/writeGraphPdf for details on keyword options.\n\nRelated\n\ndrawGraphCliq, spyCliqMat, drawTree, buildCliqSubgraphUp, buildSubgraphFromLabels!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.fifoFreeze!","page":"Caesar's Reference","title":"IncrementalInference.fifoFreeze!","text":"Freeze nodes that are older than the quasi fixed-lag length defined by fg.qfl, according to fg.fifo ordering.\n\nFuture:\n\nAllow different freezing strategies beyond fifo.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.filterHistAllToArray","page":"Caesar's Reference","title":"IncrementalInference.filterHistAllToArray","text":"filterHistAllToArray(tree, frontals, nextfnc)\n\n\nReturn state machine transition steps from all cliq histories with transition nextfnc::Function.\n\nRelated:\n\ngetCliqSolveHistory, printCliqHistorySummary, cliqHistFilterTransitions, sandboxCliqResolveStep\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.findRelatedFromPotential","page":"Caesar's Reference","title":"IncrementalInference.findRelatedFromPotential","text":"findRelatedFromPotential(dfg, fct, varid, N)\nfindRelatedFromPotential(dfg, fct, varid, N, dbg)\n\n\nCompute proposal belief on vertid through fct representing some constraint in factor graph. Always full dimension variable node – partial constraints will only influence subset of variable dimensions. The remaining dimensions will keep pre-existing variable values.\n\nNotes\n\nfulldim is true when \"rank-deficient\" – TODO swap to false (or even float)\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.fmcmc!","page":"Caesar's Reference","title":"IncrementalInference.fmcmc!","text":"fmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter)\nfmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter, dbg)\nfmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter, dbg, logger)\nfmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter, dbg, logger, multithreaded)\n\n\nIterate successive approximations of clique marginal beliefs by means of the stipulated proposal convolutions and products of the functional objects for tree clique cliq.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliq","page":"Caesar's Reference","title":"IncrementalInference.getCliq","text":"getCliq(bt, frt)\n\n\nReturn the TreeClique node object that represents a clique in the Bayes (Junction) tree, as defined by one of the frontal variables frt<:AbstractString.\n\nNotes\n\nFrontal variables only occur once in a clique per tree, therefore is a unique identifier.\n\nRelated:\n\ngetCliq, getTreeAllFrontalSyms\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqAllVarIds","page":"Caesar's Reference","title":"IncrementalInference.getCliqAllVarIds","text":"getCliqAllVarIds(cliq)\n\n\nGet all cliq variable ids::Symbol.\n\nRelated\n\ngetCliqVarIdsAll, getCliqAllFactIds, getCliqVarsWithFrontalNeighbors\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqAllVarSyms","page":"Caesar's Reference","title":"IncrementalInference.getCliqAllVarSyms","text":"Get all cliq variable labels as ::Symbol.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqAssocMat","page":"Caesar's Reference","title":"IncrementalInference.getCliqAssocMat","text":"getCliqAssocMat(cliq)\n\n\nReturn boolean matrix of factor by variable (row by column) associations within clique, corresponds to order presented by getCliqFactorIds and getCliqAllVarIds.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqChildMsgsUp","page":"Caesar's Reference","title":"IncrementalInference.getCliqChildMsgsUp","text":"getCliqChildMsgsUp(fg_, treel, cliq, ?)\n\n\nGet and return upward belief messages as stored in child cliques from treel::AbstractBayesTree.\n\nNotes\n\nUse last parameter to select the return format.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqDepth","page":"Caesar's Reference","title":"IncrementalInference.getCliqDepth","text":"getCliqDepth(tree, cliq)\n\n\nReturn depth in tree as ::Int, with root as depth=0.\n\nRelated\n\ngetCliq\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqDownMsgsAfterDownSolve","page":"Caesar's Reference","title":"IncrementalInference.getCliqDownMsgsAfterDownSolve","text":"Return dictionary of down messages consisting of all frontal and separator beliefs of this clique.\n\nNotes:\n\nFetches numerical results from subdfg as dictated in cliq.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqFrontalVarIds","page":"Caesar's Reference","title":"IncrementalInference.getCliqFrontalVarIds","text":"getCliqFrontalVarIds(cliqdata)\n\n\nGet the frontal variable IDs ::Int for a given clique in a Bayes (Junction) tree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqVarInitOrderUp","page":"Caesar's Reference","title":"IncrementalInference.getCliqVarInitOrderUp","text":"getCliqVarInitOrderUp(cliq)\n\n\nReturn the most likely  ordering for initializing factor (assuming up solve sequence).\n\nNotes:\n\nsorts id for increasing number of connected factors.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqMat","page":"Caesar's Reference","title":"IncrementalInference.getCliqMat","text":"getCliqMat(cliq; showmsg)\n\n\nReturn boolean matrix of factor variable associations for a clique, optionally including (showmsg::Bool=true) the upward message singletons.  Variable order corresponds to getCliqAllVarIds.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqMsgsDown","page":"Caesar's Reference","title":"IncrementalInference.getCliqMsgsDown","text":"getCliqMsgsDown(cliql)\n\n\nReturn the last down message stored in cliq of Bayes (Junction) tree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqMsgsUp","page":"Caesar's Reference","title":"IncrementalInference.getCliqMsgsUp","text":"getCliqMsgsUp(cliql)\n\n\nReturn the last up message stored in cliq of Bayes (Junction) tree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqParentMsgDown","page":"Caesar's Reference","title":"IncrementalInference.getCliqParentMsgDown","text":"getCliqParentMsgDown(treel, cliq)\n\n\nGet the latest down message from the parent node (without calculating anything).\n\nNotes\n\nDifferent from down initialization messages that do calculate new values – see prepCliqInitMsgsDown!.\nBasically converts function getDwnMsgs from Dict{Symbol,BallTreeDensity} to Dict{Symbol,Vector{BallTreeDensity}}.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqSeparatorVarIds","page":"Caesar's Reference","title":"IncrementalInference.getCliqSeparatorVarIds","text":"getCliqSeparatorVarIds(cliqdata)\n\n\nGet cliq separator (a.k.a. conditional) variable ids::Symbol.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqSiblings","page":"Caesar's Reference","title":"IncrementalInference.getCliqSiblings","text":"getCliqSiblings(treel, cliq)\ngetCliqSiblings(treel, cliq, inclusive)\n\n\nReturn a vector of all siblings to a clique, which defaults to not inclusive the calling cliq.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqSolveHistory","page":"Caesar's Reference","title":"IncrementalInference.getCliqSolveHistory","text":"getCliqSolveHistory(cliq)\n\n\nReturn clique state machine history from tree if it was solved with recordcliqs.\n\nNotes\n\nCliques are identified by front variable ::Symbol which are always unique across the cliques.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqVarIdsPriors","page":"Caesar's Reference","title":"IncrementalInference.getCliqVarIdsPriors","text":"getCliqVarIdsPriors(cliq)\ngetCliqVarIdsPriors(cliq, allids)\ngetCliqVarIdsPriors(cliq, allids, partials)\n\n\nGet variable ids::Int with prior factors associated with this cliq.\n\nNotes:\n\ndoes not include any singleton messages from upward or downward message passing.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqVarSingletons","page":"Caesar's Reference","title":"IncrementalInference.getCliqVarSingletons","text":"getCliqVarSingletons(cliq)\ngetCliqVarSingletons(cliq, allids)\ngetCliqVarSingletons(cliq, allids, partials)\n\n\nGet cliq variable IDs with singleton factors – i.e. both in clique priors and up messages.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCurrentWorkspaceFactors","page":"Caesar's Reference","title":"IncrementalInference.getCurrentWorkspaceFactors","text":"getCurrentWorkspaceFactors()\n\n\nReturn all factors currently registered in the workspace.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCurrentWorkspaceVariables","page":"Caesar's Reference","title":"IncrementalInference.getCurrentWorkspaceVariables","text":"getCurrentWorkspaceVariables()\n\n\nReturn all variables currently registered in the workspace.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getKDE","page":"Caesar's Reference","title":"IncrementalInference.getKDE","text":"getKDE(v)\n\n\nGet KernelDensityEstimate kde estimate stored in variable node.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getLogPath","page":"Caesar's Reference","title":"IncrementalInference.getLogPath","text":"getLogPath(dfg)\n\n\nGet the folder location where debug and solver information is recorded for a particular factor graph.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getManifolds","page":"Caesar's Reference","title":"IncrementalInference.getManifolds","text":"getManifolds(vd)\n\n\nReturn the manifolds on which variable sym::Symbol is defined.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getParent","page":"Caesar's Reference","title":"IncrementalInference.getParent","text":"getParent(treel, afrontal)\n\n\nReturn cliq's parent clique.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getTreeAllFrontalSyms","page":"Caesar's Reference","title":"IncrementalInference.getTreeAllFrontalSyms","text":"getTreeAllFrontalSyms(fgl, tree)\n\n\nReturn one symbol (a frontal variable) from each clique in the ::BayesTree.\n\nNotes\n\nFrontal variables only occur once in a clique per tree, therefore is a unique identifier.\n\nRelated:\n\nwhichCliq, printCliqHistorySummary\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getTreeCliqsSolverHistories","page":"Caesar's Reference","title":"IncrementalInference.getTreeCliqsSolverHistories","text":"Return dict of all histories in a Bayes Tree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getVal","page":"Caesar's Reference","title":"IncrementalInference.getVal","text":"getVal(v; solveKey)\n\n\nConvenience function to get point values sampled i.i.d from marginal of lbl variable in the current factor graph.\n\n\n\n\n\ngetVal(vA)\ngetVal(vA, solveKey)\n\n\nFetch the variable marginal sample points without the KDE bandwidth parameter.  Use getVertKDE to retrieve the full KDE object.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getVariableDim","page":"Caesar's Reference","title":"IncrementalInference.getVariableDim","text":"getVariableDim(vard)\n\n\nReturn the number of dimensions this variable vertex var contains.\n\nRelated\n\ngetVariableInferredDim, getVariableInferredDimFraction\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getVariableInferredDim","page":"Caesar's Reference","title":"IncrementalInference.getVariableInferredDim","text":"getVariableInferredDim(vard)\ngetVariableInferredDim(vard, saturate)\n\n\nReturn the number of projected dimensions into a variable during inference.\n\nNotes\n\nsaturate clamps return value to no greater than variable dimension\n\nRelated\n\ngetVariableDim, getVariableInferredDimFraction, getVariableInferredDim, getVariableDim\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getVertKDE","page":"Caesar's Reference","title":"IncrementalInference.getVertKDE","text":"getVertKDE(v)\n\n\nGet KernelDensityEstimate kde estimate stored in variable node.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getUpMsgs","page":"Caesar's Reference","title":"IncrementalInference.getUpMsgs","text":"getUpMsgs(cliql)\n\n\nReturn the last up message stored in cliq of Bayes (Junction) tree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getDwnMsgs","page":"Caesar's Reference","title":"IncrementalInference.getDwnMsgs","text":"getDwnMsgs(cliql)\n\n\nReturn the last down message stored in cliq of Bayes (Junction) tree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.hasCliq","page":"Caesar's Reference","title":"IncrementalInference.hasCliq","text":"hasCliq(bt, frt)\n\n\nReturn boolean on whether the frontal variable frt::Symbol exists somewhere in the ::BayesTree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.initfg","page":"Caesar's Reference","title":"IncrementalInference.initfg","text":"initfg()\ninitfg(dfg; sessionname, robotname, username, cloudgraph)\n\n\nInitialize an empty in-memory DistributedFactorGraph ::DistributedFactorGraph object.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.initInferTreeUp!","page":"Caesar's Reference","title":"IncrementalInference.initInferTreeUp!","text":"Perform tree based initialization of all variables not yet initialized in factor graph.\n\nRelated\n\nasyncTreeInferUp!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.isCliqMarginalizedFromVars","page":"Caesar's Reference","title":"IncrementalInference.isCliqMarginalizedFromVars","text":"isCliqMarginalizedFromVars(subfg, cliq)\n\n\nReturn ::Bool on whether all variables in this cliq are marginalzed.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#DistributedFactorGraphs.isInitialized","page":"Caesar's Reference","title":"DistributedFactorGraphs.isInitialized","text":"isInitialized(vert)\n\n\nReturns state of vertex data .initialized flag.\n\nNotes:\n\nused by Bayes tree clique logic.\nsimilar method in DFG\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.isMarginalized","page":"Caesar's Reference","title":"IncrementalInference.isMarginalized","text":"isMarginalized(vert)\n\n\nReturn ::Bool on whether this variable has been marginalized.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.isTreeSolved","page":"Caesar's Reference","title":"IncrementalInference.isTreeSolved","text":"isTreeSolved(treel; skipinitialized)\n\n\nReturn true or false depending on whether the tree has been fully initialized/solved/marginalized.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.isPartial","page":"Caesar's Reference","title":"IncrementalInference.isPartial","text":"isPartial(fcf)\n\n\nReturn ::Bool on whether factor is a partial constraint.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.localProduct","page":"Caesar's Reference","title":"IncrementalInference.localProduct","text":"Using factor graph object dfg, project belief through connected factors (convolution with conditional) to variable sym followed by a approximate functional product.\n\nReturn: product belief, full proposals, partial dimension proposals, labels\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#DistributedFactorGraphs.ls","page":"Caesar's Reference","title":"DistributedFactorGraphs.ls","text":"ls(cgl, session, robot, user; sym, neoid, exvid)\n\n\nList neighbors to node in cgl::CloudGraph by returning Dict{Sym}=(exvid, neoid, Symbol[labels]), and can take any of the three as input node identifier. Not specifying an identifier will result in all Variable nodes being returned.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.makeCsmMovie","page":"Caesar's Reference","title":"IncrementalInference.makeCsmMovie","text":"makeCsmMovie(fg, tree)\nmakeCsmMovie(fg, tree, cliqs; assignhist, show, filename, frames)\n\n\nConvenience function to assign and make video of CSM state machine for cliqs.\n\nNotes\n\nProbably several teething issues still (lower priority).\nUse assignhist if solver params async was true, or errored.\n\nRelated\n\ncsmAnimate, printCliqHistorySummary\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.manualinit!","page":"Caesar's Reference","title":"IncrementalInference.manualinit!","text":"manualinit!(dfg, vert, pX)\n\n\nWorkaround function when first-version (factor graph based) auto initialization fails.  Usually occurs when using factors that have high connectivity to multiple variables.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.parentCliq","page":"Caesar's Reference","title":"IncrementalInference.parentCliq","text":"parentCliq(treel, cliq)\n\n\nReturn cliq's parent clique.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.packFromLocalPotentials!","page":"Caesar's Reference","title":"IncrementalInference.packFromLocalPotentials!","text":"packFromLocalPotentials!(dfg, dens, wfac, cliq, vsym, N)\npackFromLocalPotentials!(dfg, dens, wfac, cliq, vsym, N, dbg)\n\n\nAdd all potentials associated with this clique and vertid to dens.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#RoME.predictVariableByFactor","page":"Caesar's Reference","title":"RoME.predictVariableByFactor","text":"predictVariableByFactor(dfg, targetsym, fct, prevars)\n\n\nMethod to compare current and predicted estimate on a variable, developed for testing a new factor before adding to the factor graph.\n\nNotes\n\nfct does not have to be in the factor graph – likely used to test beforehand.\nfunction is useful for detecting if multihypo should be used.\napproxConv will project the full belief estimate through some factor but must already be in factor graph.\n\nExample\n\n# fg already exists containing :x7 and :l3\npp = Pose2Point2BearingRange(Normal(0,0.1),Normal(10,1.0))\n# possible new measurement from :x7 to :l3\ncurr, pred = predictVariableByFactor(fg, :l3, pp, [:x7; :l3])\n# example of naive user defined test on fit score\nfitscore = minkld(curr, pred)\n# `multihypo` can be used as option between existing or new variables\n\nRelated\n\napproxConv\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.prepBatchTree!","page":"Caesar's Reference","title":"IncrementalInference.prepBatchTree!","text":"prepBatchTree!(dfg; variableOrder, variableConstraints, ordering, drawpdf, show, filepath, viewerapp, imgs, drawbayesnet, maxparallel)\n\n\nBuild Bayes/Junction/Elimination tree.\n\nNotes\n\nDefault to free qr factorization for variable elimination order.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.prepCliqInitMsgsDown!","page":"Caesar's Reference","title":"IncrementalInference.prepCliqInitMsgsDown!","text":"prepCliqInitMsgsDown!(fgl, tree, prnt, cliq; logger, dbgnew)\n\n\nInitialization downward message passing is different from regular inference since it is possible that none of the child cliq variables have been initialized.\n\nNotes\n\ninit msgs from child upward passes are individually stored in this cliq.\nfresh product of overlapping beliefs are calculated on each function call.\nAssumed that prnt of siblings\n\nDev Notes\n\nThis should be the initialization cycle of parent, build up bit by bit...\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.printCliqHistorySummary","page":"Caesar's Reference","title":"IncrementalInference.printCliqHistorySummary","text":"printCliqHistorySummary(fid, hist)\n\n\nPrint a short summary of state machine history for a clique solve.\n\nRelated:\n\ngetTreeAllFrontalSyms, getCliqSolveHistory, animateCliqStateMachines\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.productpartials!","page":"Caesar's Reference","title":"IncrementalInference.productpartials!","text":"productpartials!(pGM, dummy, partials, manis)\n\n\nMultiply different dimensions from partial constraints individually.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.prodmultiplefullpartials","page":"Caesar's Reference","title":"IncrementalInference.prodmultiplefullpartials","text":"Multiply various full and partial dimension constraints.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.prodmultipleonefullpartials","page":"Caesar's Reference","title":"IncrementalInference.prodmultipleonefullpartials","text":"prodmultipleonefullpartials(dens, partials, Ndims, N, manis)\n\n\nMultiply a single full and several partial dimension constraints.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.resetBuildTreeFromOrder!","page":"Caesar's Reference","title":"IncrementalInference.resetBuildTreeFromOrder!","text":"resetBuildTreeFromOrder!(fgl, p)\n\n\nReset factor graph and build a new tree from the provided variable ordering p.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.resetCliqSolve!","page":"Caesar's Reference","title":"IncrementalInference.resetCliqSolve!","text":"Reset the state of all variables in a clique to not initialized.\n\nNotes\n\nresets numberical values to zeros.\n\nDev Notes\n\nTODO not all kde manifolds will initialize to zero.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.resetData!","page":"Caesar's Reference","title":"IncrementalInference.resetData!","text":"resetData!(vdata)\n\n\nPartial reset of basic data fields in ::VariableNodeData of ::FunctionNode structures.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.resetTreeCliquesForUpSolve!","page":"Caesar's Reference","title":"IncrementalInference.resetTreeCliquesForUpSolve!","text":"resetTreeCliquesForUpSolve!(treel)\n\n\nReset the Bayes (Junction) tree so that a new upsolve can be performed.\n\nNotes\n\nWill change previous clique status from :downsolved to :initialized only.\nSets the color of tree clique to lightgreen.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.resetVariable!","page":"Caesar's Reference","title":"IncrementalInference.resetVariable!","text":"resetVariable!(varid; solveKey)\n\n\nReset the solve state of a variable to uninitialized/unsolved state.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.sandboxCliqResolveStep","page":"Caesar's Reference","title":"IncrementalInference.sandboxCliqResolveStep","text":"sandboxCliqResolveStep(tree, frontal, step)\n\n\nRepeat a solver state machine step without changing history or primary values.\n\nprintCliqSummary, printCliqHistorySummary, getCliqSolveHistory, cliqHistFilterTransitions\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setCliqAsMarginalized!","page":"Caesar's Reference","title":"IncrementalInference.setCliqAsMarginalized!","text":"setCliqAsMarginalized!(cliq, status)\n\n\nSet the marginalized status of a clique.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setCliqStatus!","page":"Caesar's Reference","title":"IncrementalInference.setCliqStatus!","text":"setCliqStatus!(cliq, status)\n\n\nSet up initialization or solve status of this cliq.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setDwnMsg!","page":"Caesar's Reference","title":"IncrementalInference.setDwnMsg!","text":"setDwnMsg!(cliql, msgs)\n\n\nSet the downward passing message for Bayes (Junction) tree clique cliql.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setfreeze!","page":"Caesar's Reference","title":"IncrementalInference.setfreeze!","text":"setfreeze!(dfg, sym)\n\n\nSet variable(s) sym of factor graph to be marginalized – i.e. not be updated by inference computation.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setTreeCliquesMarginalized!","page":"Caesar's Reference","title":"IncrementalInference.setTreeCliquesMarginalized!","text":"Set all Bayes (Junction) tree cliques that have all marginalized and initialized variables.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setUpMsg!","page":"Caesar's Reference","title":"IncrementalInference.setUpMsg!","text":"setUpMsg!(cliql, msgs)\n\n\nSet the upward passing message for Bayes (Junction) tree clique cliql.\n\nDev Notes\n\nTODO setUpMsg! should also set inferred dimension\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setValKDE!","page":"Caesar's Reference","title":"IncrementalInference.setValKDE!","text":"setValKDE!(vd, pts, bws)\nsetValKDE!(vd, pts, bws, setinit)\nsetValKDE!(vd, pts, bws, setinit, inferdim)\n\n\nSet the point centers and bandwidth parameters of a variable node, also set isInitialized=true if setinit::Bool=true (as per default).\n\nNotes\n\ninitialized is used for initial solve of factor graph where variables are not yet initialized.\ninferdim is used to identify if the initialized was only partial.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setVariableInitialized!","page":"Caesar's Reference","title":"IncrementalInference.setVariableInitialized!","text":"setVariableInitialized!(varid, status)\n\n\nSet variable initialized status.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setVariableInferDim!","page":"Caesar's Reference","title":"IncrementalInference.setVariableInferDim!","text":"setVariableInferDim!(varid, val)\n\n\nSet method for the inferred dimension value in a variable.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.solveCliq!","page":"Caesar's Reference","title":"IncrementalInference.solveCliq!","text":"solveCliq!(dfgl, tree, cliqid; recordcliq, maxparallel, async)\n\n\nPerform inference over one clique in the Bayes tree according to opt::SolverParams.\n\nExample\n\ntree = wipeBuildNewTree!(fg)\nsmt, hist = solveCliq!(fg, tree, :x1 [,cliqHistories=hist] )\n\nRelated\n\nsolveTree!, wipeBuildNewTree!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.solveCliqWithStateMachine!","page":"Caesar's Reference","title":"IncrementalInference.solveCliqWithStateMachine!","text":"Standalone state machine solution for a single clique.\n\nRelated:\n\ninitInferTreeUp!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.solveTree!","page":"Caesar's Reference","title":"IncrementalInference.solveTree!","text":"Perform inference over the Bayes tree according to opt::SolverParams.\n\nNotes\n\nVariety of options, including fixed-lag solving – see getSolverParams(fg) for details.\n\nExample\n\n# without [or with] compute recycling\ntree, smt, hist = solveTree!(fg [,tree])\n\nRelated\n\nsolveCliq!, wipeBuildNewTree!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.transferUpdateSubGraph!","page":"Caesar's Reference","title":"IncrementalInference.transferUpdateSubGraph!","text":"transferUpdateSubGraph!(dest, src)\ntransferUpdateSubGraph!(dest, src, syms)\ntransferUpdateSubGraph!(dest, src, syms, logger; updatePPE)\n\n\nTransfer contents of src::AbstractDFG variables syms::Vector{Symbol} to dest::AbstractDFG. Notes\n\nReads, dest := src, for all syms\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.treeProductDwn","page":"Caesar's Reference","title":"IncrementalInference.treeProductDwn","text":"treeProductDwn(fg, tree, cliq, sym; N, dbg)\n\n\nCalculate a fresh–-single step–-approximation to the variable sym in clique cliq as though during the downward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variable based on the structure of variables, factors, and incoming messages to this clique. Which clique to be used is defined by frontal variable symbols (cliq in this case) – see whichCliq(...) for more details.  The sym symbol indicates which symbol of this clique to be calculated.  Note that the sym variable must appear in the clique where cliq is a frontal variable.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.treeProductUp","page":"Caesar's Reference","title":"IncrementalInference.treeProductUp","text":"treeProductUp(fg, tree, cliq, sym; N, dbg)\n\n\nCalculate a fresh (single step) approximation to the variable sym in clique cliq as though during the upward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variables based on the structure of the clique, factors, and incoming messages. Which clique to be used is defined by frontal variable symbols (cliq in this case) – see whichCliq(...) for more details.  The sym symbol indicates which symbol of this clique to be calculated.  Note that the sym variable must appear in the clique where cliq is a frontal variable.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.unfreezeVariablesAll!","page":"Caesar's Reference","title":"IncrementalInference.unfreezeVariablesAll!","text":"unfreezeVariablesAll!(fgl)\n\n\nFree all variables from marginalization.\n\nRelated\n\ndontMarginalizeVariablesAll!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.dontMarginalizeVariablesAll!","page":"Caesar's Reference","title":"IncrementalInference.dontMarginalizeVariablesAll!","text":"Free all variables from marginalization.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.updateFGBT!","page":"Caesar's Reference","title":"IncrementalInference.updateFGBT!","text":"updateFGBT!(fg, bt, cliqID, drt; dbg, fillcolor, logger)\n\n\nUpdate cliq cliqID in Bayes (Juction) tree bt according to contents of ddt – intended use is to update main clique after a downward belief propagation computation has been completed per clique.\n\n\n\n\n\nupdateFGBT!(fg, cliq, urt; dbg, fillcolor, logger)\n\n\nUpdate cliq cliqID in Bayes (Juction) tree bt according to contents of urt – intended use is to update main clique after a upward belief propagation computation has been completed per clique.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.updateTreeCliquesAsMarginalizedFromVars!","page":"Caesar's Reference","title":"IncrementalInference.updateTreeCliquesAsMarginalizedFromVars!","text":"updateTreeCliquesAsMarginalizedFromVars!(fgl, tree)\n\n\nRun through entire tree and set cliques as marginalized if all clique variables are marginalized.\n\nNotes:\n\nTODO can be made fully parallel, consider converting for use with @threads for.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.upGibbsCliqueDensity","page":"Caesar's Reference","title":"IncrementalInference.upGibbsCliqueDensity","text":"upGibbsCliqueDensity(inp)\nupGibbsCliqueDensity(inp, N)\nupGibbsCliqueDensity(inp, N, dbg)\nupGibbsCliqueDensity(inp, N, dbg, iters)\nupGibbsCliqueDensity(inp, N, dbg, iters, logger)\n\n\nPerform computations required for the upward message passing during belief propation on the Bayes (Junction) tree. This function is usually called as via remote_call for multiprocess dispatch.\n\nExample\n\ninp = ExploreTreeType(fg,tree,cliq,parent,childmsgs)\nurt = upGibbsCliqueDensity(inp)\n\nfg factor graph,\ntree Bayes tree,\ncliq which cliq to perform the computation on,\nparent the parent clique to where the upward message will be sent,\nchildmsgs is for any incoming messages from child cliques.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.wipeBuildNewTree!","page":"Caesar's Reference","title":"IncrementalInference.wipeBuildNewTree!","text":"Build a completely new Bayes (Junction) tree, after first wiping clean all temporary state in fg from a possibly pre-existing tree.\n\nRelated:\n\nbuildTreeFromOrdering!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.writeGraphPdf","page":"Caesar's Reference","title":"IncrementalInference.writeGraphPdf","text":"Draw and show the factor graph <:AbstractDFG via system graphviz and pdf app.\n\nNotes\n\nShould not be calling outside programs.\nNeed long term solution\nDFG's toDotFile a better solution – view with xdot application.\nalso try engine={\"sfdp\",\"fdp\",\"dot\",\"twopi\",\"circo\",\"neato\"}\n\nFuture:\n\nMight be kept with different call strategy since this function so VERY useful!\nMajor issue that this function calls an external program such as \"evince\", which should be  under user control only.\nMaybe solution is\ntoDot(fg,file=...); @async run(`xdot file.dot`), or\ntoDot(fg,file=...); exportPdf(...); @async run(`evince ...pdf`).\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.resetVariableAllInitializations!","page":"Caesar's Reference","title":"IncrementalInference.resetVariableAllInitializations!","text":"resetVariableAllInitializations!(fgl)\n\n\nReset initialization flag on all variables in ::AbstractDFG.\n\nNotes\n\nNumerical values remain, but inference will overwrite since init flags are now false.\n\n\n\n\n\n","category":"function"},{"location":"concepts/adding_variables_factors/#Creating-New-Variables-and-Factors-1","page":"Custom Variables and Factors","title":"Creating New Variables and Factors","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"In most scenarios, the existing variables and factors should be sufficient for most robotics applications. Caesar however, is extensible and allows you to easily incorporate your own variable and factor types for specialized applications.","category":"page"},{"location":"concepts/adding_variables_factors/#Considerations-1","page":"Custom Variables and Factors","title":"Considerations","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"A couple of important points:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You do not need to modify/fork/edit internal Caesar/RoME/IncrementalInference source code to introduce new variable and factor types!\nAs long as the factors exist in the working space when the solver is run, the factors are automatically used – this is possible due to Julia's multiple dispatch design\nCaesar is designed to allow you to add new variables and factors to your own independent repository and incorporate them at will at compile-time or even run-time\nResidual function definitions for new factors types use a callable struct (a.k.a functor) architecture to simultaneously allow:  \nMultiple dispatch (i.e. 'polymorphic' behavior)\nMeta-data and in-place memory storage for advanced and performant code\nAn outside callback implementation style\nIn most robotics scenarios, there is no need for new variables or factors:\nVariables have various mechanisms that allow you to attach data to them, e.g. raw sensory data or identified April tags, so you do not need to create a new variable type just to store data\nNew variables are required only if you are representing a new state - TODO: Example of needed state\nNew factors are needed if:\nYou need to represent a constraint for a variable (known as a singleton) and that constraint type doesn't exist\nYou need to represent a constraint between two variables and that constraint type doesn't exist","category":"page"},{"location":"concepts/adding_variables_factors/#Getting-Started-1","page":"Custom Variables and Factors","title":"Getting Started","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"We suggest the following design pattern for developing and building new factors:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You have reviewed the variable and factor types available in Caesar, RoME, and IncrementalInference and a new type is required - please see Building and Solving Graphs if you want to review what is currently available\n[OPTIONAL] Create a GitHub repository to store the new types (new types in the Julia Main scope is perfectly okay!)\nCreate your new variable types\nCreate your new factor types\nImplement unit tests to validate the correct operation of the types\nSet up your solver to make use the custom types","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"1.1. This is much easier than it sounds","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"If the code is public and may be useful to the community, we ask if you could submit an issue against Caesar with information about the new types and the repository. Ideally we'd like to continually improve the core code and fold in community contributions.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"The remainder of this section discusses each of these steps.","category":"page"},{"location":"concepts/adding_variables_factors/#[OPTIONAL]-Creating-a-Repository-1","page":"Custom Variables and Factors","title":"[OPTIONAL] Creating a Repository","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You can fork the following template repository to construct your own Caesar Variable and Factor Examples.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"If this repository is going to be used for development of the new variables/factors as well as for the experiment (i.e. the code that builds the graph and solves it), you should probably start a simple end-to-end test that validates a basic version of your experimental setup (e.g. ):","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"#### This example is a basic test of the new variables and factors\n#### that are added in this repo. The example is derived from\n#### the hexagonal test example.\n\nusing Caesar, RoME\nusing Caesar_VariableFactorExamples # Your new variable/factor repository\n# Using plotting for experiment validation\nusing RoMEPlotting\n\n# 1. Init factor graph\n#TODO\n\n# 2. Add variables\n#TODO\n\n# 3. Add factors\n# 3a. Add a new test prior\n#TODO\n# 3b. Add new types of odometry factors.\n#TODO\n\n# 4. Solve graph\nsolveTree!(fg)\n\n# 5. Graph solution - assuming that you have this open in Atom.\ndrawPoses(fg)","category":"page"},{"location":"concepts/adding_variables_factors/#Creating-New-Variables-1","page":"Custom Variables and Factors","title":"Creating New Variables","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"All variables have to derive from IncrementalInference.InferenceVariable.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"What you need to build in the variable:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"dims - This is used during computation and defines the degrees of freedom (dimensions) for variable\nlabels - This a required field, although it does not need to be populated. It consists of unique, indexable string identifiers, such as 'POSE', 'LANDMARK'. It assists with querying the data efficiently in large systems when using the database layer.  ","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You can then also add any additional fields that you would like to use for saving state information in variable. Note that these fields must be serializable as both JSON and Protobufs. Although you don't need to validate this, please keep the fields fairly simple and avoid complex structures with optional fields. TBD - provide a compatibility check for serialization and a docpage on it.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"In a trivial example of Pose2:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"Our dimensions would then be 3: X, Y, theta\nThe labels for Pose2 could be \"POSE\"","category":"page"},{"location":"concepts/adding_variables_factors/#Creating-New-Factors-1","page":"Custom Variables and Factors","title":"Creating New Factors","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"All factors inherit from one of the following types, depending on their function:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"FunctorSingleton: FunctorSingletons are priors (unary factors) that provide an absolute constraint for a single variable. A simple example of this is an absolute GPS prior, or equivalently a (0, 0, 0) starting location in a RoME.Pose2 scenario.\nRequires: A getSample function\nFunctorPairwiseMinimize: FunctorPairwiseMinimize are relative factors that introduce an algebraic relationship between two or more variables. A simple example of this is an odometry factor between two pose variables, or a range factor indicating the range between a pose and another variable.\nRequires: A getSample function and a residual function definition\nThe minimize suffix specifies that the residual function of this factor will be enforced by numerical minimization (find me the minimum of this function)\nFunctorPairwise: FunctorPairwise are relative factors that introduce algebraic relationships between two or more variables. They are the same as FunctorPairwiseMinimize, however they use root finding to find the zero crossings (rather than numerical minimization).\nRequires: A getSample function and a residual function definition","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"How do you decide which to use?","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"If you are creating factors for world-frame information that will be tied to a single variable, inherit from FunctorSingleton\nGPS coordinates should be priors\nIf you are creating factors for local-frame relationships between variables, inherit from FunctorPairwiseMinimize\nOdometry and bearing deltas should be introduced as pairwise factors and should be local frame","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"TBD: sUsers should start with FunctorPairwiseMinimize, discuss why and when they should promote their factors to FunctorPairwise.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"Note: FunctorPairwiseMinimize does not imply that the overall inference algorithm only minimizes an objective function. The Multi-model iSAM algorithm is built around fixed-point analysis. Minimization is used here to locally enforce the residual function.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"What you need to build in the new factor:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"A struct for the factor itself\nA sampler function to return measurements from the random ditributions\nIf you are building a FunctorPairwiseMinimize or a FunctorPairwise you need to define a residual function to introduce the relative algebraic relationship between the variables\nMinimization function should be lower-bounded and smooth\nA packed type of the factor which must be named Packed[Factor name], and allows the factor to be packed/transmitted/unpacked\nSerialization and deserialization methods\nThese are convert functions that pack and unpack the factor (which may be highly complex) into serialization-compatible formats\nAs the factors are mostly comprised of distributions (of type SamplableBelief), functions are provided to pack and unpack the distributions:\nPacking: To convert from a SamplableBelief to a string, use string(::SamplableBelief)::String\nUnpacking: To convert from string back to a SamplableBelief, use extractdistribution(::String)::SamplableBelief  ","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"An example of this is the Pose2Point2BearingRange, which provides a bearing+range relationship between a 2D pose and a 2D point.","category":"page"},{"location":"concepts/adding_variables_factors/#Pose2Point2BearingRange-Struct-1","page":"Custom Variables and Factors","title":"Pose2Point2BearingRange Struct","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"mutable struct Pose2Point2BearingRange{B <: IIF.SamplableBelief, R <: IIF.SamplableBelief} <: IncrementalInference.FunctorPairwise\n    bearing::B\n    range::R\n    Pose2Point2BearingRange{B,R}() where {B,R} = new{B,R}()\n    Pose2Point2BearingRange{B,R}(x1::B,x2::R) where {B <: IIF.SamplableBelief,R <: IIF.SamplableBelief} = new{B,R}(x1,x2)\nend\n# Convenient constructor\nPose2Point2BearingRange(x1::B,x2::R) where {B <: IIF.SamplableBelief,R <: IIF.SamplableBelief} = Pose2Point2BearingRange{B,R}(x1,x2)","category":"page"},{"location":"concepts/adding_variables_factors/#Pose2Point2BearingRange-Sampler-1","page":"Custom Variables and Factors","title":"Pose2Point2BearingRange Sampler","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"# Return N samples from the two distributions\nfunction getSample(pp2br::Pose2Point2BearingRange, N::Int=1)\n  smpls = zeros(2, N)\n  smpls[1,:] = rand(pp2br.bearing, N)[:]\n  smpls[2,:] = rand(pp2br.range, N)[:]\n  return (smpls,)\nend","category":"page"},{"location":"concepts/adding_variables_factors/#Pose2Point2BearingRange-Residual-Function-(Functor)-1","page":"Custom Variables and Factors","title":"Pose2Point2BearingRange Residual Function (Functor)","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"# define the conditional probability constraint\nfunction (pp2br::Pose2Point2BearingRange)(res::Array{Float64},\n        userdata::FactorMetadata,\n        idx::Int,\n        meas::Tuple{Array{Float64,2}},\n        xi::Array{Float64,2},\n        lm::Array{Float64,2} )\n  #\n  res[1] = lm[1,idx] - (meas[1][2,idx]*cos(meas[1][1,idx]+xi[3,idx]) + xi[1,idx])\n  res[2] = lm[2,idx] - (meas[1][2,idx]*sin(meas[1][1,idx]+xi[3,idx]) + xi[2,idx])\n  nothing\nend","category":"page"},{"location":"concepts/adding_variables_factors/#Pose2Point2BearingRange-Packing-and-Unpacking-1","page":"Custom Variables and Factors","title":"Pose2Point2BearingRange Packing and Unpacking","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"The packing structure:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"mutable struct PackedPose2Point2BearingRange <: IncrementalInference.PackedInferenceType\n    bearstr::String\n    rangstr::String\n    PackedPose2Point2BearingRange() = new()\n    PackedPose2Point2BearingRange(s1::AS, s2::AS) where {AS <: AbstractString} = new(string(s1),string(s2))\nend","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"The packing and unpacking converters (note the use of string and extractdistribution):","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"function convert(::Type{PackedPose2Point2BearingRange}, d::Pose2Point2BearingRange{B, R}) where {B <: IIF.SamplableBelief, R <: IIF.SamplableBelief}\n  return PackedPose2Point2BearingRange(string(d.bearing), string(d.range))\nend\n\nfunction convert(::Type{Pose2Point2BearingRange}, d::PackedPose2Point2BearingRange)\n # where {B <: IIF.SamplableBelief, R <: IIF.SamplableBelief}\n  Pose2Point2BearingRange(extractdistribution(d.bearstr), extractdistribution(d.rangstr))\nend","category":"page"},{"location":"concepts/adding_variables_factors/#Unit-Tests-1","page":"Custom Variables and Factors","title":"Unit Tests","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"What you should test:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"Creation of the factor\nSampling of the factor\nResidual testing\nSolving using the variables and factors\nSerialization and deserialization","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"An example of these tests can be seen for the trivial case shown in the example repo ExamplePrior Unit Tests.","category":"page"},{"location":"concepts/adding_variables_factors/#Using-your-Types-with-the-Caesar-Solver-1","page":"Custom Variables and Factors","title":"Using your Types with the Caesar Solver","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"As above, as long as you bring your factors into the workspace, you should be able to use them in your experimental setup.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You can validate this with the existence check code in Building and Solving Graphs.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"Note: This has been made available as IncrementalInference.getCurrentWorkspaceVariables() and IncrementalInference.getCurrentWorkspaceFactors()in IncrementalInference v0.4.4.","category":"page"},{"location":"concepts/adding_variables_factors/#Contributing-to-Community-1","page":"Custom Variables and Factors","title":"Contributing to Community","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"We really appreciate any contributions, so if you have developed variables and factors that may be useful to the community, please write up an issue in Caesar.jl with a link to your repo and a short description of the use-case(s).","category":"page"},{"location":"concepts/concepts/#Caesar-Concepts-1","page":"Initial Concepts","title":"Caesar Concepts","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Initial Concepts","title":"Initial Concepts","text":"A factor graph is a bipartite representation where variables (denoted by larger nodes) are interconnected by a set of factors (smaller nodes) that represent some algebraic interaction between the variables.  Factors must adhere to the limits of probabilistic models – for example conditional likelihoods (between multiple variables) or priors (unary to one variable).  A more heterogeneous factor graph example is shown below, and a broader discussion here (author disclosure):","category":"page"},{"location":"concepts/concepts/#","page":"Initial Concepts","title":"Initial Concepts","text":"(Image: factorgraphexample).","category":"page"},{"location":"concepts/concepts/#Why/Where-does-non-Gaussian-data-come-from?-1","page":"Initial Concepts","title":"Why/Where does non-Gaussian data come from?","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Initial Concepts","title":"Initial Concepts","text":"Gaussian error models in measurement or data cues will only be Gaussian (normally distributed) if all physics/decisions/systematic-errors/calibration/etc. has a correct algebraic model in every single circumstance.  Caesar.jl and mm-iSAM is heavily focussed on state-estimation from a plethora of heterogenous data.  Four major categories of non-Gaussian errors have thus far been considered:","category":"page"},{"location":"concepts/concepts/#","page":"Initial Concepts","title":"Initial Concepts","text":"Uncertain decisions (a.k.a. data association), such as a robot trying to decide if a navigation loop-closure can be deduced from a repeat observation of a similar object or measurement from current and past data.  These issues are commonly also referred to as multi-hypothesis.\nUnder-determined or under-defined systems where there are more variables than constraining measurements to fully define the system as a single mode–-a.k.a solution ambiguity.  For example, in 2D consider two range measurements resulting in two possible locations through trilateration.\nNonlinearity.  For example in 2D, consider a Pose2 odometry where the orientation is uncertain:  The resulting belief of where a next pose might be (convolution with odometry factor) results in a banana shape curve, even though the entire process is driven by assumed Gaussian belief.\nPhysics of the measurement process.  Many, if not all measurement processes exhibit non-Gaussian behaviour.  For example, acoustic/radio time-of-flight measurements, using either pulse-train or matched filtering, result in an \"energy intensity\" over time/distance of what the range to a scattering-target/source might be–i.e. highly non-Gaussian.","category":"page"},{"location":"concepts/concepts/#Getting-Started-with-Caesar-1","page":"Initial Concepts","title":"Getting Started with Caesar","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Initial Concepts","title":"Initial Concepts","text":"This section discusses the various concepts in the Caesar framework.","category":"page"},{"location":"concepts/concepts/#","page":"Initial Concepts","title":"Initial Concepts","text":"The initial steps in constructing and solving graphs can be found in Building and Solving Graphs.","category":"page"},{"location":"concepts/concepts/#","page":"Initial Concepts","title":"Initial Concepts","text":"We also recommend reviewing the various examples available in the Examples section.","category":"page"},{"location":"concepts/concepts/#Visualization-1","page":"Initial Concepts","title":"Visualization","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Initial Concepts","title":"Initial Concepts","text":"Caesar supports various visualizations and plots by using Arena, RoMEPlotting, and Director. This is discussed in Visualization with Arena.jl and RoMEPlotting.jl","category":"page"},{"location":"concepts/concepts/#Extending-Caesar-1","page":"Initial Concepts","title":"Extending Caesar","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Initial Concepts","title":"Initial Concepts","text":"The variables and factors in Caesar should be sufficient for the majority of robotic applications, however Caesar allows users to extend the framework without changing the core code. This is discussed in Creating New Variables and Factors.","category":"page"},{"location":"concepts/concepts/#Connectivity-and-Extensibility-1","page":"Initial Concepts","title":"Connectivity and Extensibility","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Initial Concepts","title":"Initial Concepts","text":"Caesar supports both in-memory solving (really fast, but for moderately-sized graphs) as well as database-driven solving (think massive graphs and multiple sessions). This is still under development/being refactored, and is discussed in Common Data Persistence and Inference.","category":"page"},{"location":"concepts/concepts/#","page":"Initial Concepts","title":"Initial Concepts","text":"Although Caesar is Julia-based, it provides multi-language support with a ZMQ interface. This is discussed in Caesar Multi-Language Support.","category":"page"},{"location":"principles/initializingOnBayesTree/#Advanced-Topics-on-Bayes-Tree-1","page":"Advanced Bayes Tree Topics","title":"Advanced Topics on Bayes Tree","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/#Definitions-1","page":"Advanced Bayes Tree Topics","title":"Definitions","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Squashing or collapsing the Bayes tree back into a 'flat' Bayes net, by chain rule: ","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"p(xy) = p(xy)p(y) = p(yx)p(x) \np(xyz) = p(xyz)p(yz) = p(xyz)p(z) = p(xyz)p(yz)p(z) \np(xyz) = p(xyz)p(y)p(z)  textiff y is independent of z  also p(yz)=p(y)","category":"page"},{"location":"principles/initializingOnBayesTree/#Are-cliques-in-the-Bayes-(Junction)-tree-densly-connected?-1","page":"Advanced Bayes Tree Topics","title":"Are cliques in the Bayes (Junction) tree densly connected?","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Yes and no. From the chordal Bayes net's perspective (obtained through the elimination game in order to build the clique tree), the nodes of the Bayes tree are indeed fully connected subgraphs (they are called cliques after all!). From the perspective of the subgraph of the original factor graph induced by the clique's variables, cliques need not be fully connected, since we are assuming the factor graph as sparse, and that no new information can be created out of nothing–-hence each clique must be sparse.  That said, the potential exists for the inference within a clique to become densly connected (experience full \"fill-in\").  See the paper on square-root-SAM, where the connection between dense covariance matrix of a Kalman filter (EKF-SLAM) is actually related to the inverse square root (rectangular) matrix which structure equivalent to the clique subgraph adjacency matrix.  ","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Also remember that the intermediate Bayes net (which has densly connected cliques) hides the underlying tree structure – think of the Bayes net as looking at the tree from on top or below, thereby encoding the dense connectivity in the structure of the tree itself.  All information below any clique of the tree is encoded in the upward marginal belief messages at that point (i.e. the densly connected aspects pertained lower down in the tree).","category":"page"},{"location":"principles/initializingOnBayesTree/#LU/QR-vs.-Belief-Propagation-1","page":"Advanced Bayes Tree Topics","title":"LU/QR vs. Belief Propagation","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"LU/QR is a special case (Parametric/Linear) of more general belief propagation.  The story though is more intricate, where QR/LU assume that product-factors can be formed through the chain rule – using congruency – it is not that straight forward with general beliefs.  In the general case we are almost forced to use belief propagation, which in turn implies special care is needed to describe the relationship between sparse factor graph fragments in cliques on the tree, and the more densely connected structure of the Bayes Net.","category":"page"},{"location":"principles/initializingOnBayesTree/#Bayes-Tree-vs-Bayes-Net-1","page":"Advanced Bayes Tree Topics","title":"Bayes Tree vs Bayes Net","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"The Bayes tree is a purely symbolic structure – i.e. special grouping of factors that all come from the factor graph joint product (product of independently sampled likelihood/conditional models):","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Theta  Z propto prod_i   Z_i=z_i  Theta_i ","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"A sparse factor graph problem can be squashed into smaller dense problem of product-factor conditionals (from variable elimination).  Therefore each product-factor (aka \"smart factor\" in other uses of the language) represent both the factors as well as the sequencing of cliques in that branch.  This process repeats recursively from the root down to the leaves.  The leaves of the tree have no further reduced product factors condensing child cliques below, and therefore sparse factor fragments can be computed to start the upward belief propagation process.  More importantly, as belief propagation progresses up the tree, upward belief messages (on clique separators) capture the same structure as the densely connected Bayes net but each clique in the Bayes tree still only contains sparse fragments from the original factor graph.  The structure of the tree (combined parent-child relationships) encodes the same information as the product-factor conditionals!","category":"page"},{"location":"principles/initializingOnBayesTree/#Initialization-on-the-Tree-1","page":"Advanced Bayes Tree Topics","title":"Initialization on the Tree","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"It more challenging but possible to initialize all variables in a factor graph through belief propagation on the Bayes tree.","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"As a thought experiment: Wouldn't it be awesome if we could compile the upsolve as a symbolic process only, and only assign numerical values once during a single downsolve procedure.  The origin of this idea comes from the realization that a complete upsolve on the Bayes (Junction) tree is very nearly the same thing finding good numerical initialization values for the factor graph.  If the up-init-solve can be performed as a purely symbolic process, it would greatly simplify numerical computations by deferring them to the down solve alone.","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Trying to do initialization for real, we might want to replace up-init-symbolic operations with numerical equivalents.  Either way, it would be worth knowing what the equivalent numerical operations of a full up-init-solve of an uninitialized factor graph would look like.","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"In general, if a clique can not be initialized based on information from lower down in that branch of the tree; more information is need from the parent.  In the Gaussian (more accurately the congruent factor) case, all information lower down in the branch–-i.e. the relationships between variables in parent–-can be summarized by a new conditional product-factor that is computed with the probabilistic chain rule.  To restate, the process of squashing the Bayes tree branch back down into a Bayes net, is effectively the the chain rule process used in variable elimination.","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"note: Note\nQuestion, are cascading up and down solves are required if you do not use eliminated factor conditionals in parent cliques.","category":"page"},{"location":"principles/initializingOnBayesTree/#Gaussian-only-special-case-1","page":"Advanced Bayes Tree Topics","title":"Gaussian-only special case","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Elimination of variables and factors using chain rule reduction is a special case of belief propagation, and thus far only the reduction of congruent beliefs (such as Gaussian) is known.","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"These computations can be parallelized depending on the conditional independence structure of the Bayes tree – separate branches are effectively separate chain rule instances.  This is precisely the same process exploited by multi-frontal QR matrix factorization.","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"On the down solve the conditionals–-from eliminated chains of previously eliminated variables and factors–-can be used for inference directly in the parent.  ","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"See node x1 to x3 in IncrementalInference issue 464. It does not branch or provide additional prior information. so it is collapsed into one factor between x1 and x3, solved in the root and the individual variable can be solved by inference.","category":"page"},{"location":"principles/initializingOnBayesTree/#","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"note: Note\nQuestion, what does the Jacobian in Gaussian only case mean with regard to a symbolic upsolve?","category":"page"},{"location":"faq/#Frequently-Asked-Questions-1","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#Why-Julia-1","page":"FAQ","title":"Why Julia","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The JuliaLang and (JuliaPro) is an open-source Just-In-Time (JIT) & optionally precompiled, strongly-typed, and high-performance programming language. The algorithmic code is implemented in Julia for many reasons, such as agile development, high level syntax, performance, type safety, multiple dispatch replacement for object oriented, parallel computing, dynamic development, cross compilable (with gcc and clang) and foundational cross-platform (LLVM) technologies.   See JuliaCon2018 highlights video.  Julia can be thought of as either {C+, Mex (done right), or as a modern Fortran replacement}.","category":"page"},{"location":"faq/#Factor-Graphs:-why-not-just-filter?-1","page":"FAQ","title":"Factor Graphs: why not just filter?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Why can't I just filter, or what is the connection with FGs? See the \"Principles\" section in the documentation. ","category":"page"},{"location":"faq/#Can-Caesar.jl-be-used-in-other-languages-beyond-Julia?-Yes.-1","page":"FAQ","title":"Can Caesar.jl be used in other languages beyond Julia? Yes.","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The Caesar.jl project is expressly focused on making this algorithmic code available to C/Fortran/C++/C#/Python/Java/JS.  Julia itself offers many additional interops.  ZMQ and HTTP/WebSockets are the standardized interfaces of choice, please see details at the multi-language section).  Consider opening issues or getting in touch for more information.","category":"page"},{"location":"faq/#Just-In-Time-Compiling-(i.e.-why-are-first-runs-slow?)-1","page":"FAQ","title":"Just-In-Time Compiling (i.e. why are first runs slow?)","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Julia uses just-in-time compilation (unless already pre-compiled)  which takes additional time the first time a new function is called. Additional calls to a cached function are fast from the second call onwards since the static binary code is now cached and ready for use.","category":"page"},{"location":"faq/#Static,-Shared-Object-.so-Compilation-1","page":"FAQ","title":"Static, Shared Object .so Compilation","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Packages are already compiled to static objects (.ji files), but can also be compiled to more common .so files.  See this AOT vs JIT compiling blog post for a deeper discussion.  Also see this Julia Binaries Blog.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Note recent developments announced on discourse..  Also see new brute force sysimg work at Fezzik.jl.","category":"page"},{"location":"faq/#Can-Julia-be-Embedded-into-C/C-1","page":"FAQ","title":"Can Julia be Embedded into C/C++","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Yes, see the Julia embedding documentation page.","category":"page"},{"location":"faq/#Variable-Scope-in-For-loop-Error-1","page":"FAQ","title":"Variable Scope in For loop Error","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Julia wants you to be specific about global variables, and variables packed in a development script at top level are created as globals.  Globals can be accessed using the global varname at the start of the context, e.g.:","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"fg = ...\ntree, smt, hist = solveTree!(fg)\n...\n# and then a loop here:\nfor i 2:100\n   global tree, fg\n   # add variables and stuff\n   ...\n   # want to solve again\n   tree, smt, hist = solveTree!(fg, tree)\n   ...\n   # more stuff\nend","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"One could also use let, see Stack overflow or the Julia docs page on scoping.  Also note it is good practice to use local scope (i.e. inside a function) variables for performance reasons.","category":"page"},{"location":"faq/#Why-ZMQ-Middleware-Layer-(multilang)?-1","page":"FAQ","title":"Why ZMQ Middleware Layer (multilang)?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Zero Message Queue (ZMQ) is a widely used data transport layer used to build various other multiprocess middleware with wide support among other programming languages.","category":"page"},{"location":"faq/#ROS-Integration-1","page":"FAQ","title":"ROS Integration","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"ROS integration is a priority for this project and will accompany the so-called 'prime time' release of the code.  ROS and ZMQ interfaces are closely related.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Note the present focus (2018Q3-2019Q2) is to stabilize the ZMQ interface.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Voice Please add your voice of support or suggestions on ROS integration here.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"WIP Please see work on an initial PoC (still using PyCall) via our wiki developer docs here.","category":"page"},{"location":"faq/#What-is-supersolve?-1","page":"FAQ","title":"What is supersolve?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"When multiple numerical values/solutions exists for the (or nearly) same factor graph – then solutions, including a reference solution (ground truth) can just be stacked in that variable.  See and comment on a few cases here.","category":"page"},{"location":"faq/#Current-Julia-version?-1","page":"FAQ","title":"Current Julia version?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Caesar.jl and packages are currently targeting Julia version as per the local install page.","category":"page"},{"location":"faq/#How-does-JSON-Schema-work?-1","page":"FAQ","title":"How does JSON-Schema work?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Caesar.jl intends to follow json-schema.org, see step-by-step guide here.","category":"page"},{"location":"faq/#How-to-get-Julia-memory-allocation-points?-1","page":"FAQ","title":"How to get Julia memory allocation points?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"See discourse discussion.","category":"page"},{"location":"faq/#Increase-Linux-Open-File-Limit?-1","page":"FAQ","title":"Increase Linux Open File Limit?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"If you see the error \"Open Files Limit\", please follow these intructions on your local system.  This is likely to happen when debug code and a large number of files are stored in the general solution specific logpath.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Hexagonal-2D-with-Fixed-Lag-Solving-1","page":"Fixed-Lag Solving 2D","title":"Hexagonal 2D with Fixed-Lag Solving","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"note: Note\nThis is an experimental feature that is currently being developed. This example provides an overview of how to enable it and the benefits of using fixed-lag solving. The objective is to provide a near-constant solve time for ever-growing graphs by only recalculating the most recent portion. Think of this as a placeholder, as we develop the solution this tutorial will be updated to demonstrate how that is achieved.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Example-Code-1","page":"Fixed-Lag Solving 2D","title":"Example Code","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"The complete code for this example can be found in the fixed-lag branch of RoME: Hexagonal Fixed-Lag Example.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Introduction-1","page":"Fixed-Lag Solving 2D","title":"Introduction","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Fixed-lag solving is enabled when creating the factor-graph. Users provide a window–-the quasi fixed-lag constant (QFL)–-which defines how many of the most-recent variables should be calculated. Any other variables are 'frozen.' The objective of this example is to explore providing a near-constant solve time for ever-growing graphs by only recalculating the most recent portion.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Example-Overview-1","page":"Fixed-Lag Solving 2D","title":"Example Overview","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"In the example, the basic Hexagonal 2D is grown to solve 200 variables. The original example remains the same, i.e., a vehicle is driving around in a hexagon and seeing the same bearing+range landmark as it crosses the starting point. At every 20th variable, a solve is invoked. Rather than use solveTree!(fg), the solve is performed in parts (construction of Bayes tree, solving the graph) to get performance statistics as the graph grows.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"numVariables = 200\nsolveEveryNVariables = 20\nlagLength = 30\n\n# Standard Hexagonal example for totalIterations - solve every iterationsPerSolve iterations.\nfunction runHexagonalExample(fg::G, totalIterations::Int, iterationsPerSolve::Int)::DataFrame where {G <: AbstractDFG}\n    # Add the first pose :x0\n    addVariable!(fg, :x0, Pose2)\n\n    # dummy tree used later for incremental updates\n    tree = wipeBuildNewTree!(fg)\n\n    # Add at a fixed location PriorPose2 to pin :x0 to a starting location\n    addFactor!(fg, [:x0], PriorPose2(MvNormal(zeros(3), 0.01*Matrix{Float64}(LinearAlgebra.I, 3,3))))\n\n    # Add a landmark l1\n    addVariable!(fg, :l1, Point2, labels=[:LANDMARK])\n\n    # Drive around in a hexagon a number of times\n    solveTimes = DataFrame(GraphSize = [], TimeBuildBayesTree = [], TimeSolveGraph = [])\n    for i in 0:totalIterations\n        psym = Symbol(\"x$i\")\n        nsym = Symbol(\"x$(i+1)\")\n        @info \"Adding pose $nsym...\"\n        addVariable!(fg, nsym, Pose2)\n        pp = Pose2Pose2(MvNormal([10.0;0;pi/3], Matrix(Diagonal( [0.1;0.1;0.1].^2 ) )))\n        @info \"Adding odometry factor between $psym -> $nsym...\"\n        addFactor!(fg, [psym;nsym], pp )\n\n        if i % 6 == 0\n            @info \"Creating factor between $psym and l1...\"\n            p2br = Pose2Point2BearingRange(Normal(0,0.1),Normal(20.0,1.0))\n            addFactor!(fg, [psym; :l1], p2br)\n        end\n        if i % iterationsPerSolve == 0 && i != 0\n            @info \"Performing inference!\"\n            if getSolverParams(fg).isfixedlag\n                @info \"Quasi fixed-lag is enabled (a feature currently in testing)!\"\n                fifoFreeze!(fg)\n            end\n            tInfer = @timed tree, smt, hist = solveTree!(fg, tree)\n            graphSize = length([ls(fg)[1]..., ls(fg)[2]...])\n            push!(solveTimes, (graphSize, tInfer[2], tInfer[2]))\n        end\n    end\n    return solveTimes\nend","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Two cases are set up:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"One solving the full graph every time a solve is performed:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"# start with an empty factor graph object\nfg = initfg()\n# DO NOT enable fixed-lag operation\nsolverTimesForBatch = runHexagonalExample(fg, numVariables, solveEveryNVariables)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"The other enabling fixed-lag with a window of 20 variables:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"fgFixedLag = initfg()\nfgFixedLag.solverParams.isfixedlag = true\nfgFixedLag.solverParams.qfl = lagLength\n\nsolverTimesFixedLag = runHexagonalExample(fgFixedLag, numVariables, solveEveryNVariables)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"The resultant path of the robot can be seen by using RoMEPlotting and is drawn if the visualization lines are uncommented:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"#### Visualization\n\n# Plot the many iterations to see that it succeeded.\n# Batch\n# drawPosesLandms(fg)\n\n# Fixed lag\n# drawPosesLandms(fgFixedLag)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Lastly, the timing results of both scenarios are merged into a single DataFrame table, exported to CSV, and a summary graph is shown using GadFly.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"using Gadfly\nusing Colors\nusing CSV\n\n# Make a clean dataset\nrename!(solverTimesForBatch, :TimeBuildBayesTree => :Batch_BayedBuild, :TimeSolveGraph => :Batch_SolveGraph);\nrename!(solverTimesFixedLag, :TimeBuildBayesTree => :FixedLag_BayedBuild, :TimeSolveGraph => :FixedLag_SolveGraph);\ntimingMerged = DataFrames.join(solverTimesForBatch, solverTimesFixedLag, on=:GraphSize)\nCSV.write(\"timing_comparison.csv\", timingMerged)\n\nPP = []\npush!(PP, Gadfly.layer(x=timingMerged[:GraphSize], y=timingMerged[:FixedLag_SolveGraph], Geom.path, Theme(default_color=colorant\"green\"))[1]);\npush!(PP, Gadfly.layer(x=timingMerged[:GraphSize], y=timingMerged[:Batch_SolveGraph], Geom.path, Theme(default_color=colorant\"magenta\"))[1]);\n\nplt = Gadfly.plot(PP...,\n    Guide.title(\"Solving Time vs. Iteration for Fixed-Lag Operation\"),\n    Guide.xlabel(\"Solving Iteration\"),\n    Guide.ylabel(\"Solving Time (seconds)\"),\n    Guide.manual_color_key(\"Legend\", [\"fixed\", \"batch\"], [\"green\", \"magenta\"]))\nGadfly.draw(PNG(\"results_comparison.png\", 12cm, 15cm), plt)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Results-1","page":"Fixed-Lag Solving 2D","title":"Results","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Preliminary results for the comparison can be seen below. However, this is just a start and we need to perform more testing. At the moment we are working on providing consistent results and further improving performance/flattening the fixed-lag time. It should be noted that the below graph is not to demonstrate the absolute solve time, but rather the relative behavior of full-graph solve vs. fixed-lag.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"(Image: Timing comparison of full solve vs. fixed-lag)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"NOTE Work is underway (aka \"Project Tree House\") to reduce overhead computations that result in poorer fixed-lag solving times.  We expect the fixed-lag performance to improve in the coming months (Written Nov 2018).  Please file issues if a deeper discussion is required.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Additional-Example-1","page":"Fixed-Lag Solving 2D","title":"Additional Example","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Work In Progress, but In the mean time see the following examples:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"https://github.com/JuliaRobotics/Caesar.jl/blob/master/examples/wheeled/racecar/apriltagandzed_slam.jl","category":"page"},{"location":"examples/basic_hexagonal2d/#Hexagonal-2D-SLAM-Example-(Local-Compute)-1","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM Example (Local Compute)","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"A simple 2D robot trajectory example is expanded below using techniques developed in simultaneous localization and mapping (SLAM). This example is available as a single script here.","category":"page"},{"location":"examples/basic_hexagonal2d/#Creating-the-Factor-Graph-with-Pose2-1","page":"Hexagonal 2D SLAM","title":"Creating the Factor Graph with Pose2","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"The first step is to load the required modules, and in our case we will add a few Julia processes to help with the compute later on.  ","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# add more julia processes\nnprocs() < 4 ? addprocs(4-nprocs()) : nothing\n\n# tell Julia that you want to use these modules/namespaces\nusing RoME, Distributions, LinearAlgebra","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"After loading the RoME and Distributions modules, we construct a local factor graph object in memory:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# start with an empty factor graph object\nfg = initfg()\n\n# Add the first pose :x0\naddVariable!(fg, :x0, Pose2)\n\n# Add at a fixed location PriorPose2 to pin :x0 to a starting location\naddFactor!(fg, [:x0], PriorPose2(MvNormal(zeros(3), 0.01*Matrix(LinearAlgebra.I,3,3))) )","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"A factor graph object fg (of type <:AbstractDFG) has been constructed; the first pose :x0 has been added; and a prior factor setting the origin at [0,0,0] over variable node dimensions [x,y,θ] in the world frame. The type Pose2 is used to indicate what variable is stored in the node. Caesar.jl allows a little more freedom in how factor and variable nodes can be connected, while still allowing for type-assertion to occur.","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"NOTE Julia uses just-in-time compilation (unless pre-compiled)  which is slow the first time a function is called but fast from the second call onwards, since the static function is now cached and ready for use.","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"The next 6 nodes are added with odometry in an counter-clockwise hexagonal manner. Note how variables are denoted with symbols, :x2 == Symbol(\"x2\"):","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# Drive around in a hexagon\nfor i in 0:5\n  psym = Symbol(\"x$i\")\n  nsym = Symbol(\"x$(i+1)\")\n  addVariable!(fg, nsym, Pose2)\n  pp = Pose2Pose2(MvNormal([10.0;0;pi/3], Matrix(Diagonal([0.1;0.1;0.1].^2))))\n  addFactor!(fg, [psym;nsym], pp )\nend","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"At this point it would be good to see what the factor graph actually looks like:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"drawGraph(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"You should see the program evince open with this visual:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: exfg2d)","category":"page"},{"location":"examples/basic_hexagonal2d/#Performing-Inference-1","page":"Hexagonal 2D SLAM","title":"Performing Inference","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"Let's run the multimodal-incremental smoothing and mapping (mm-iSAM) solver against this fg object:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# perform inference, and remember first runs are slower owing to Julia's just-in-time compiling\ntree, smt, hist = solveTree!(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"This will take a couple of seconds (including first time compiling for all Julia processes).  If you wanted to see the Bayes tree operations during solving, set the following parameters before calling the solver:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"getSolverParams(fg).drawtree = true\ngetSolverParams(fg).showtree = true","category":"page"},{"location":"examples/basic_hexagonal2d/#Some-Visualization-Plot-1","page":"Hexagonal 2D SLAM","title":"Some Visualization Plot","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"2D plots of the factor graph contents is provided by the RoMEPlotting package. See further discussion on visualizations and packages here.","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"## Inter-operating visualization packages for Caesar/RoME/IncrementalInference exist\nusing RoMEPlotting\n\n# For Juno/Jupyter style use\npl = drawPoses(fg)\n\n# For scripting use-cases you can export the image\npl |> Gadfly.PDF(\"/tmp/test.pdf\") # or PNG(...)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: test)","category":"page"},{"location":"examples/basic_hexagonal2d/#Adding-Landmarks-as-Point2-1","page":"Hexagonal 2D SLAM","title":"Adding Landmarks as Point2","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"Suppose some sensor detected a feature of interest with an associated range and bearing measurement. The new variable and measurement can be included into the factor graph as follows:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# Add landmarks with Bearing range measurements\naddVariable!(fg, :l1, Point2, labels=[\"LANDMARK\"])\np2br = Pose2Point2BearingRange(Normal(0,0.1),Normal(20.0,1.0))\naddFactor!(fg, [:x0; :l1], p2br)\n\n# Initialize :l1 numerical values but do not rerun solver\nensureAllInitialized!(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"NOTE The default behavior for initialization of variable nodes implies the last variable node added will not have any numerical values yet, please see ContinuousScalar Tutorial for deeper discussion on automatic initialization (autoinit). A slightly expanded plotting function will draw both poses and landmarks (and currently assumes labels starting with :x and :l respectively)–-notice the new landmark bottom right:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"drawPosesLandms(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: test)","category":"page"},{"location":"examples/basic_hexagonal2d/#One-type-of-Loop-Closure-1","page":"Hexagonal 2D SLAM","title":"One type of Loop-Closure","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"Loop-closures are a major part of SLAM based state estimation. One illustration is to take a second sighting of the same :l1 landmark from the last pose :x6; followed by repeating the inference and re-plotting the result–-notice the tighter confidences over all variables:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# Add landmarks with Bearing range measurements\np2br2 = Pose2Point2BearingRange(Normal(0,0.1),Normal(20.0,1.0))\naddFactor!(fg, [:x6; :l1], p2br2)\n\n# solve\ntree, smt, hist = solveTree!(fg, tree)\n\n# redraw\npl = drawPosesLandms(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: test)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"This concludes the Hexagonal 2D SLAM example.","category":"page"},{"location":"examples/basic_hexagonal2d/#Interest:-The-Bayes-(Junction)-tree-1","page":"Hexagonal 2D SLAM","title":"Interest: The Bayes (Junction) tree","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"The Bayes (Junction) tree is used as an acyclic (has no loops) computational object, an exact algebraic refactorizating of factor graph, to perform the associated sum-product inference. The visual structure of the tree can be extracted by modifying the command tree = wipeBuildNewTree!(fg, drawpdf=true) to produce representations such as this in bt.pdf.","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: exbt2d)","category":"page"},{"location":"concepts/multisession/#Multisession-Operation-1","page":"Multi-session/agent Solving","title":"Multisession Operation","text":"","category":"section"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Having all the data consolidated in a factor graph allows us to do something we find really exciting: reason against data for different robots, different robot sessions, even different users. Of course, this is all optional, and must be explicitly configured, but if enabled, current inference solutions can make use of historical data to continually improve their solutions.","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Consider a single robot working in a common environment that has driven around the same area a number of times and has identified a landmark that is (probably) the same. We can automatically close the loop and use the information from the prior data to improve our current solution. This is called a multisession solve.","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"To perform a multisession solve, you need to specify that a session is part of a common environment, e.g 'lab'. A user then requests a multisession solve (manually for the moment), and this creates relationships between common landmarks. The collective information is used to produce a consensus on the shared landmarks. A chain of session solves is then created, and the information is propagated into the individual sessions, improving their results.","category":"page"},{"location":"concepts/multisession/#Steps-in-Multisession-Solve-1","page":"Multi-session/agent Solving","title":"Steps in Multisession Solve","text":"","category":"section"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"The following steps are performed by the user:","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Indicate which sessions are part of a common environment - this is done via GraffSDK when the session is created\nRequest a multisession solve","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Upon request, the solver performs the following actions:","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Updates the common existing multisession landmarks with any new information (propagation from session to common information)\nBuilds common landmarks for any new sessions or updated data\nSolves the common, multisession graph\nPropagates the common consensus result to the individual sessions\nFreezes all the session landmarks so that the session solving does not update the consensus result\nRequests session solves for all the updated sessions","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Note the current approach is well positioned to transition to the \"Federated Bayes (Junction) Tree\" multisession solving method, and will be updated accordingly in due coarse.  The Federated method will allow faster multi-session solving times by avoiding the current iterated approach.","category":"page"},{"location":"concepts/multisession/#Example-1","page":"Multi-session/agent Solving","title":"Example","text":"","category":"section"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Consider three sessions which exist in the same, shared environment. In this environment, during each session the robot identified the same l0 landmark, as shown in the below figure. (Image: Independent Sessions)","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"If we examine this in terms of the estimates of the actual landmarks, we have three independent densities (blue, green, and orange) giving measures of l0 located at (20, 0):","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"(Image: Independent densities)","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Now we trigger a multisession solve. For each landmark that is seen in multiple session, we produce a common landmark (we call a prime landmark) and link it to the session landmarks via factors - all denoted in black outline.","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"(Image: Linked landmarks)","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"A multisession solve is performed, which for each common (prime) landmark, we produce a common estimate. In terms of densities, this is a single answer for the disparate information, as shown in red in the below figure (for a slightly different dataset):","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"(Image: Prime density)","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"This information is then propagated back to the individual session landmarks, giving one common density for each landmark. As above, our green, blue, and orange individual densities are now all updated to match the consensus shown in black:","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"(Image: Prime density)","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"The session landmarks are then frozen, and individual session solves are triggered to propagate the information back into the sessions.  Until the federated upgrade is completed, the above process is iterated a few times to allow information to cross propagate through all sessions.  There federated tree solution requires only a single iteration up and down the federated Bayes (Junction) tree. ","category":"page"},{"location":"concepts/multisession/#Next-Steps-1","page":"Multi-session/agent Solving","title":"Next Steps","text":"","category":"section"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"This provides an initial implementation for stitching data from multiple sessions, robots, and users. In the short term, we may trigger this automatically for any shared environments.  Multisession solving along with other automated techniques for additional measurement discovery in data allows the system to 'dream' – i.e. reducing succint info from the large volumes of heterogenous sensor data.","category":"page"},{"location":"concepts/multisession/#","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"In the medium future we will extend this functionality to operate in the Bayes tree, which we call 'federated solving', so that we perform the operation using cached results of subtrees. ","category":"page"},{"location":"principles/multiplyingDensities/#Principle:-Multiplying-Functions-(Python)-1","page":"Multiplying Functions (.py)","title":"Principle: Multiplying Functions (Python)","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"This example illustrates a central concept in Caesar.jl (and the multimodal-iSAM algorithm), whereby different probability belief functions are multiplied together. The true product between various likelihood beliefs is very complicated to compute, but a good approximations exist. In addition, ZmqCaesar offers a ZMQ interface to the factor graph solution for multilanguage support.  This example is a small subset that shows how to use the ZMQ infrastructure, but avoids the larger factor graph related calls.","category":"page"},{"location":"principles/multiplyingDensities/#Products-of-Infinite-Objects-(Functionals)-1","page":"Multiplying Functions (.py)","title":"Products of Infinite Objects (Functionals)","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Consider multiplying multiple belief density functions together, for example","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"f = f_1 times f_2 times f_3","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"which is a core operation required for solving the Chapman-Kolmogorov transit equations.","category":"page"},{"location":"principles/multiplyingDensities/#Direct-Julia-Calculation-1","page":"Multiplying Functions (.py)","title":"Direct Julia Calculation","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"The ApproxManifoldProducts.jl package (experimental) is meant to unify many on-manifold product operations, and can be called directly in Julia:","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"using ApproxManifoldProducts\n\nf1 = manikde!(randn(100,1).-3.0, (:Euclid,))\nf2 = manikde!(randn(100,1).+3.0, (:Euclid,))\n...\n\nf12 = maniproduct([f1;f2], (:Euclid,))","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Also see previous KernelDensityEstimate.jl.","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"To make Caesar.jl usable from other languages, a ZMQ server interface model has been developed which can also be used to test this principle functional product operation.","category":"page"},{"location":"principles/multiplyingDensities/#Not-Susceptible-to-Particle-Depletion-1","page":"Multiplying Functions (.py)","title":"Not Susceptible to Particle Depletion","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"The product process of say f1*f2 is not a importance sampling procedure that is commonly used in particle filtering, but instead a more advanced Bayesian inference process based on a wide variety of academic literature.  The KernelDensityEstimate method is a stochastic method, what active research is looking into deterministic homotopy/continuation methods.","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"The easy example that demonstrates that particle depletion is avoided here, is where f1 and f2 are represented by well separated and evenly weighted samples – the Bayesian inference 'product' technique efficiently produces new (evenly weighted) samples for f12 somewhere in between f1 and f2, but clearly not overlapping the original population of samples used for f1 and f2.  In contrast, conventional particle filtering measurement updates would have \"de-weighted\" particles of either input function and then be rejected during an eventual resampling step, thereby depleting the sample population.","category":"page"},{"location":"principles/multiplyingDensities/#Starting-the-ZMQ-server-1","page":"Multiplying Functions (.py)","title":"Starting the ZMQ server","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Caesar.jl provides a startup script for a default ZMQ instance.  Start a server and allow precompilations to finish, as indicated by a printout message \"waiting to receive...\".  More details here.","category":"page"},{"location":"principles/multiplyingDensities/#Functional-Products-via-Python-1","page":"Multiplying Functions (.py)","title":"Functional Products via Python","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Clone the Python GraffSDK.py code here and look at the product.py file.","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"import sys\nsys.path.append('..')\n\nimport numpy as np\nfrom graff.Endpoint import Endpoint\nfrom graff.Distribution.Normal import Normal\nfrom graff.Distribution.SampleWeights import SampleWeights\nfrom graff.Distribution.BallTreeDensity import BallTreeDensity\n\nfrom graff.Core import MultiplyDistributions\n\nimport matplotlib.pyplot as plt\n\nif __name__ == '__main__':\n    e = Endpoint()\n\n    e.Connect('tcp://192.168.0.102:5555')\n    print(e.Status())\n\n    N = 1000\n    u1 = 0.0\n    s1 = 10.0\n    x1 = u1+s1*np.random.randn(N)\n\n    u2 = 50.0\n    s2 = 10.0\n    x2 = u2+s2*np.random.randn(N)\n    b1 = BallTreeDensity('Gaussian', np.ones(N), np.ones(N), x1)\n    b2 = BallTreeDensity('Gaussian', np.ones(N), np.ones(N), x2)\n\n    rep = MultiplyDistributions(e, [b1,b2])\n    print(rep)\n    x = np.array(rep['points'] )\n    # plt.stem(x, np.ones(len(x)) )\n    plt.hist(x, bins = int(len(x)/10.0), color= 'm')\n    plt.hist(x1, bins = int(len(x)/10.0),color='r')\n    plt.hist(x2, bins = int(len(x)/10.0),color='b')\n    plt.show()\n\n    e.Disconnect()","category":"page"},{"location":"principles/multiplyingDensities/#A-Basic-Factor-Graph-Product-Illustration-1","page":"Multiplying Functions (.py)","title":"A Basic Factor Graph Product Illustration","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Using the factor graph methodology, we can repeat the example by adding variable and two prior factors.  This can be done directly in Julia (or via ZMQ in the further Python example below)","category":"page"},{"location":"principles/multiplyingDensities/#Products-of-Functions-(Factor-Graphs-in-Julia)-1","page":"Multiplying Functions (.py)","title":"Products of Functions (Factor Graphs in Julia)","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Directly in Julia:","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"using IncrementalInference\n\nfg = initfg()\n\naddVariable!(fg, :x0, ContinuousScalar)\naddFactor!(fg, [:x0], Prior(Normal(-3.0,1.0)))\naddFactor!(fg, [:x0], Prior(Normal(+3.0,1.0)))\n\nsolveTree!(fg)\n\n# plot the results\nusing KernelDensityEstimatePlotting\n\nplotKDE(getKDE(fg, :x0))","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Example figure:","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/productexample.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"principles/multiplyingDensities/#Products-of-Functions-(Via-Python-and-ZmqCaesar)-1","page":"Multiplying Functions (.py)","title":"Products of Functions (Via Python and ZmqCaesar)","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"We repeat the example using Python and the ZMQ interface:","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"import sys\nsys.path.append('..')\n\nimport numpy as np\nfrom graff.Endpoint import Endpoint\nfrom graff.Distribution.Normal import Normal\nfrom graff.Distribution.SampleWeights import SampleWeights\nfrom graff.Distribution.BallTreeDensity import BallTreeDensity\n\nfrom graff.Core import MultiplyDistributions\n\n\nif __name__ == '__main__':\n    \"\"\"\n\n    \"\"\"\n    e.Connect('tcp://127.0.0.1:5555')\n    print(e.Status())\n\n    # Add the first pose x0\n    x0 = Variable('x0', 'ContinuousScalar')\n    e.AddVariable(x0)\n\n    # Add at a fixed location PriorPose2 to pin x0 to a starting location\n    prior = Factor('Prior', ['x0'], Normal(np.zeros(1,1)-3.0, np.eye(1)) )\n    e.AddFactor(prior)\n    prior = Factor('Prior', ['x0'], Normal(np.zeros(1,1)+3.0, np.eye(1)) )\n    e.AddFactor(prior)","category":"page"},{"location":"concepts/database_interactions/#Using-The-Cloud-Server-1","page":"Cloud Server/Database","title":"Using The Cloud Server","text":"","category":"section"},{"location":"concepts/database_interactions/#","page":"Cloud Server/Database","title":"Cloud Server/Database","text":"See ongoing work at:","category":"page"},{"location":"concepts/database_interactions/#","page":"Cloud Server/Database","title":"Cloud Server/Database","text":"DistributedFactorGraphs.jl, \nGraffSDK.jl.","category":"page"},{"location":"concepts/database_interactions/#Cloud-Server-offers-Multi-session/agent-Support-1","page":"Cloud Server/Database","title":"Cloud Server offers Multi-session/agent Support","text":"","category":"section"},{"location":"concepts/database_interactions/#","page":"Cloud Server/Database","title":"Cloud Server/Database","text":"Next page Multisession","category":"page"},{"location":"concepts/multilang/#Multi-Language-and-Shared-Objects-1","page":"Multi-Language Support","title":"Multi-Language and Shared Objects","text":"","category":"section"},{"location":"concepts/multilang/#Multilanguage-Interops:-Caesar-SDKs-and-APIs-1","page":"Multi-Language Support","title":"Multilanguage Interops: Caesar SDKs and APIs","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"The Caesar framework is not limited to direct Julia use. The following Github projects provide access to features of Caesar in their language:","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Julia Web interface:\nGraffSDK.jl\nZMQ Interface\nC/C++:\nGraff Cpp\nCaesar LCM\nPython:\nGraffSDK.py","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Contributions are welcome! If you are developing an extension we would like to help, please feel free to contact us (details below).","category":"page"},{"location":"concepts/multilang/#ZMQ-Messaging-Interface-1","page":"Multi-Language Support","title":"ZMQ Messaging Interface","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Caesar.jl has a ZMQ messaging interface (interested can see code here  here) that allows users to interact with the solver code base in a variety of ways.  The messaging interface is not meant to replace static .so library file compilation–see below–-but rather a more versatile and flexible development strategy.","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"The current known interface implementations to Caesar.jl are:","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"C/C++ GraffCPP,\nPython GraffSDK.py (needs to be updated),","category":"page"},{"location":"concepts/multilang/#Starting-the-Caesar-ZMQ-Navigation-Server-1","page":"Multi-Language Support","title":"Starting the Caesar ZMQ Navigation Server","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Start the Caesar.ZmqCaesar server in a Julia session with a few process cores and full optimization:","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"julia -p4 -O3","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Then run the following commands, and note these steps have also been scripted here:","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"#import the required modules\nusing Caesar, Caesar.ZmqCaesar\n\n# create empty factor graph and config objects\nfg = initfg()\nconfig = Dict{String, String}()\nzmqConfig = ZmqServer(fg, config, true, \"tcp://*:5555\");\n\n# Start the server over ZMQ\nstart(zmqConfig)\n\n# give the server a minute to start up ...","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"The current tests are a good place to see some examples of the current interfacing functions.  Feel free to change the ZMQ interface for to any of the ZMQ supported modes of data transport, such as Interprocess Communication (IPC) vs. TCP.","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"TODO: expand the ZMQ documentation","category":"page"},{"location":"concepts/multilang/#ROS-Integration-1","page":"Multi-Language Support","title":"ROS Integration","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Yes, but not yet.  See:","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"FAQ: ROS Integration","category":"page"},{"location":"concepts/multilang/#Static,-Shared-Object-.so-Compilation-1","page":"Multi-Language Support","title":"Static, Shared Object .so Compilation","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"FAQ: Static, Shared Object .so Compilation","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"The plan for the Caesar.jl & the mm-iSAM is to use PackageCompiler.jl to generate linkable .o or .so files; or maybe even full executables.","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Please add your comments to this issue discussion.","category":"page"},{"location":"concepts/multilang/#Alternative-Methods-1","page":"Multi-Language Support","title":"Alternative Methods","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Interfacing from languages like Python may also be achieved using PyCall.jl although little work has been done in the Caesar.jl framework to explore this path.  Julia is itself interactive/dynamic and has plenty of line-by-line and Integrated Development Environment support – consider trying Julia for your application.","category":"page"},{"location":"principles/filterCorrespondence/#Build-your-own-(Bayes)-Filter-1","page":"Filters vs. Graphs","title":"Build your own (Bayes) Filter","text":"","category":"section"},{"location":"principles/filterCorrespondence/#Correspondence-with-Kalman-Filtering?-1","page":"Filters vs. Graphs","title":"Correspondence with Kalman Filtering?","text":"","category":"section"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"A frequent discussion point is the correspondence between Kalman/particle/log-flow filtering strategies and factor graph formulations.  This section aims to shed light on the relationship, and to show that factor graph interpretations are a powerful generalization of existing filtering techniques.  The discussion follows a build-your-own-filter style and combines the Approximate Convolution and Multiplying Densities pages as the required prediction and update cycle steps, respectively.  Using the steps described here, the user will be able to build fully-functional–-i.e. non-Gaussian–-(Bayes) filters.  ","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"note: Note\nA simple 1D predict correct Bayesian filtering example (using underlying convolution and product operations of the mmisam algorithm) can be used as a rough template to familiarize yourself on the correspondence between filters and newer graph-based operations.","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"This page tries to highlight some of the reasons why using a factor graph approach (w/ Bayes/junction tree inference) in a incremental/fixed-lag/federated sense–-e.g. simultaneous localization and mapping (SLAM) approach–-has merit.  The described steps form part of the core operations used by the multimodal incremental smoothing and mapping (mmisam) algorithm.","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Further topics on factor graph (and Bayes/junction tree) inference formulation, including how out-marginalization works is discussed separately as part of the Bayes tree description page.  It is also worth reiterating the section on why do we even care about non-Gaussian signal processing.","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"note: Note\nComing soon, the steps described on this page will be fully accessible via multi-language interfaces (middleware) – some of these interfaces already exist.","category":"page"},{"location":"principles/filterCorrespondence/#The-Target-Tracking-Problem-(Conventional-Filtering)-1","page":"Filters vs. Graphs","title":"The Target Tracking Problem (Conventional Filtering)","text":"","category":"section"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Consider a common example, two dimensional target tracking, where a projectile transits over a tracking station using various sensing technologies [Zarchan 2013].  Position and velocity estimates of the target","category":"page"},{"location":"principles/filterCorrespondence/#Prediction-Step-using-a-Factor-Graph-1","page":"Filters vs. Graphs","title":"Prediction Step using a Factor Graph","text":"","category":"section"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Assume a constant velocity model from which the estimate will be updated through the measurement model described in the next section.  A constant velocity model is taken as (cartesian)","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"fracdxdt = 0 + eta_x\nfracdydt = 0 + eta_y","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"or polar coordinates","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"fracdrhodt = 0 + eta_rho\nfracdthetadt = 0 + eta_theta","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"In this example, noise is introduced as an affine slack variable \\eta, but could be added as any part of the process model:","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"eta_j sim p()","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"where p is any allowable noise probability density/distribution model – discussed more in the next section.","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"After integration (assume zeroth order) the associated residual function can be constructed:","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"delta_i (theta_k theta_k-1 fracd theta_kdt Delta t) = theta_k - (theta_k-1 + fracd theta_kdt Delta t)","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Filter prediction steps are synonymous with a binary factor (conditional likelihood) between two variables where a prior estimate from one variable is projected (by means of a convolution) to the next variable.  The convolutional principle page describes a more detailed example on how a convolution can be computed. ","category":"page"},{"location":"principles/filterCorrespondence/#Measurement-Step-using-a-Factor-Graph-1","page":"Filters vs. Graphs","title":"Measurement Step using a Factor Graph","text":"","category":"section"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"The measurement update is a product operation of infinite functional objects (probability densities)","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"p(X_k  X_k-1 Z_a Z_b) approx p(X_k  X_k-1 Z_a) times p(X_k  Z_b)","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"where Z_. represents conditional information for two beliefs on the same variable.  The product of the two functional estimates (beliefs) are multiplied by a stochastic algorithm described in more detail on the multiplying functions page.","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Direct state observations can be added to the factor graph as prior factors directly on the variables.  An illustration of both predictions (binary likelihood process model) and direct observations (measurements) is presented:","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/68166954-e45e4180-ff5b-11e9-91cb-0741d90a0c02.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Alternatively, indirect measurements of the state variables are should be modeled with the most sensible function","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"y = h(theta eta)\ndelta_j(theta_j eta_j) = ominus h_j(theta_j eta_j) oplus y_j","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"which approximates the underlying (on-manifold) stochastics and physics of the process at hand.  The measurement models can be used to project belief through a measurement function, and should be recognized as a standard representation for a Hidden Markov Model (HMM):","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/71652397-105c3000-2d1d-11ea-92bc-282ddbe3eabc.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"principles/filterCorrespondence/#Beyond-Filtering-1","page":"Filters vs. Graphs","title":"Beyond Filtering","text":"","category":"section"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Consider a multi-sensory system along with data transmission delays, variable sampling rates, etc.;  when designing a filtering system to track one or multiple targets, it quickly becomes difficult to augment state vectors with the required state and measurement histories.  In contrast, the factor graph as a language allows for heterogeneous data streams to be combined in a common inference framework, and is discussed further in the building distributed factor graphs section.","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"note: Note\nFactor graphs are constructed along with the evolution of time which allows the mmisam inference algorithm to resolve variable marginal estimates both forward and backwards in time.  Conventional filtering only allows for forward-backward \"smoothing\" as two separate processes.  When inferring over a factor graph, all variables and factors are considered simultaneously according the topological connectivity irrespective of when and where which measurements were made or communicated – as long as the factor graph (probabilistic model) captures the stochastics of the situation with sufficient accuracy.  ","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"TODO: Multi-modal (belief) vs. multi-hypothesis – see thesis work on multimodal solutions in the mean time.","category":"page"},{"location":"principles/filterCorrespondence/#","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"note: Note\nMmisam allows for parametric, non-parametric, or intensity noise models which can be incorporated into any differentiable residual function.","category":"page"},{"location":"examples/basic_definingfactors/#Defining-New-Variables-and-Factors-1","page":"Creating Variables and Factors","title":"Defining New Variables and Factors","text":"","category":"section"},{"location":"examples/basic_definingfactors/#","page":"Creating Variables and Factors","title":"Creating Variables and Factors","text":"TODO: Smooth text and flow.","category":"page"},{"location":"examples/basic_definingfactors/#Quick-Example-in-One-Dimension-1","page":"Creating Variables and Factors","title":"Quick Example in One Dimension","text":"","category":"section"},{"location":"examples/basic_definingfactors/#","page":"Creating Variables and Factors","title":"Creating Variables and Factors","text":"Note these factors already exists in IncrementalInference (and many more in RoME) and are presented here as a first introduction into the process of defining your own factors.","category":"page"},{"location":"examples/basic_definingfactors/#","page":"Creating Variables and Factors","title":"Creating Variables and Factors","text":"User scope Prior, LinearOffset, and MultiModalOffset with arbitrary distributions are defined as:","category":"page"},{"location":"examples/basic_definingfactors/#","page":"Creating Variables and Factors","title":"Creating Variables and Factors","text":"import IncrementalInference: getSample\n\nstruct Prior{T} <: IncrementalInference.FunctorSingleton where T <: Distribution\n  z::T\nend\ngetSample(s::Prior, N::Int=1) = (reshape(rand(s.z,N),1,:), )\nstruct LinearOffset{T} <: IncrementalInference.FunctorPairwise where T <: Distribution\n  z::T\nend\ngetSample(s::LinearOffset, N::Int=1) = (reshape(rand(s.z,N),1,:), )\nfunction (s::LinearOffset)(res::Array{Float64},\n                           userdata::FactorMetadata,\n                           idx::Int,\n                           meas::Tuple{Array{Float64, 2}},\n                           X1::Array{Float64,2},\n                           X2::Array{Float64,2}  )\n  #\n  res[1] = meas[1][idx] - (X2[1,idx] - X1[1,idx])\n  nothing\nend\nstruct MultiModalOffset <: IncrementalInference.FunctorPairwise\n  z::Vector{Distribution}\n  c::Categorical\nend\ngetSample(s::MultiModalOffset, N::Int=1) = (reshape.(rand.(s.z, N),1,:)..., rand(s.c, N))\nfunction (s::MultiModalOffset)(res::Array{Float64},\n                               userdata::FactorMetadata,\n                               idx::Int,\n                               meas::Tuple,\n                               X1::Array{Float64,2},\n                               X2::Array{Float64,2}  )\n  #\n  res[1] = meas[meas[end][idx]][idx] - (X2[1,idx] - X1[1,idx])\n  nothing\nend","category":"page"},{"location":"examples/basic_definingfactors/#","page":"Creating Variables and Factors","title":"Creating Variables and Factors","text":"Notice the residual function relating to the two PairwiseFunctor derived definitions. The one dimensional residual functions, res[1] = measurement - prediction, are used during inference to approximate the convolution of conditional beliefs from the sample approximate marginal beliefs of the connected variables.","category":"page"},{"location":"installation_environment/#Welcome-1","page":"Installation","title":"Welcome","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Caesar.jl is one of the packages within the JuliaRobotics community, and adheres to the code-of-conduct.","category":"page"},{"location":"installation_environment/#Local-Dependencies-1","page":"Installation","title":"Local Dependencies","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"The following system packages are used by Caesar.jl:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"# required packages\nsudo apt-get install hdf5-tools imagemagick\n\n# optional packages\nsudo apt-get install graphviz","category":"page"},{"location":"installation_environment/#New-to-Julia-and-want-a-full-Development-Install-1","page":"Installation","title":"New to Julia and want a full Development Install","text":"","category":"section"},{"location":"installation_environment/#Local-Installation-of-Julia-1","page":"Installation","title":"Local Installation of Julia","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Although Julia (or JuliaPro) can be installed on a Linux computer using the apt package manager, we are striving for a fully local installation environment which is highly reproducible on a variety of platforms.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"The easiest method is–-via the terminal–-to download the desired version of Julia as a binary, extract, setup a symbolic link, and run:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"cd ~\nmkdir -p .julia\ncd .julia\nwget https://julialang-s3.julialang.org/bin/linux/x64/1.3/julia-1.3.1-linux-x86_64.tar.gz\ntar -xvf julia-1.3.1-linux-x86_64.tar.gz\nrm julia-1.3.1-linux-x86_64.tar.gz\ncd /usr/local/bin\nsudo ln -s ~/.julia/julia-1.3.1/bin/julia julia","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"note: Note\nFeel free to modify this setup as you see fit.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"This should allow any terminal or process on the computer to run the Julia REPL by type julia and testing with:","category":"page"},{"location":"installation_environment/#[Optional]-Quick-Test-that-Julia-is-Working-1","page":"Installation","title":"[Optional] Quick Test that Julia is Working","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Run Julia in REPL (console) mode:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"$ julia\njulia> println(\"hello world\")\n\"hello world\"","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Maybe a script, or command:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"user@...$ echo \"println(\\\"hello again\\\")\" > myscript.jl\nuser@...$ julia myscript.jl\nhello again\nuser@...$ rm myscript.jl\n\nuser@...$ julia -e \"println(\\\"one more time.\\\")\"\none more time.\nuser@...$ julia -e \"println(\\\"...testing...\\\")\"\n...testing...\n","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"note: Note\nWhen searching for Julia related help online, use the phrase 'julialang' instead of just 'julia'.  For example, search for 'julialang workflow tips' or 'julialang performance tips'. Also, see FAQ - Why are first runs slow?, which is due to Just-In-Time/Pre compiling and caching.","category":"page"},{"location":"installation_environment/#Setup-Juno-IDE-Environment-1","page":"Installation","title":"Setup Juno IDE Environment","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Juno IDE allows for interactive development of Julia code by extending the Atom text editor with a few packages. Download and install Atom as instructed on the website, or via command line:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"mkdir -p ~/Downloads/atom\ncd ~/Downloads/atom\nwget https://atom.io/download/deb -q --show-progress\nsudo dpkg -i deb","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"After installing and running Atom, you can choose to either install uber-juno package in one go or install the three associated packages individually. In Atom, open the command pallette by pressing Ctrl + Shft + p and typing settings. Go to the install tab, search for and install either","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"uber-juno","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"or the individual packages directly:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"ink\njulia-client\njulia-language\nlatex-completions","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"note: Note\nSome situations have required the user separately installing the Atom.jl Julia package via command line (if Juno does not automatically install Atom.jl for you).  Atom.jl can then be installed with Julia's package manager and add Atom — see below.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"There are a variety of useful packages in Atom, such as minimap and minimap-git.  Julia packages are independent of the Atom packages and installed via the Julia Pkg Package.","category":"page"},{"location":"installation_environment/#Julia-Packages-1","page":"Installation","title":"Julia Packages","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"The philosophy around Julia packages are discussed at length in the Julia core documentation, where each Julia package relates to a git repository likely found on Github.com. To install a Julia package, simply open a julia REPL (equally the julia REPL in Atom/Juno) and type:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"] # activate Pkg manager\n(v1.3) pkg> add Caesar","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"These are registered packages maintained by JuliaRegistries/General. Unregistered latest packages can also be installed with using only the Pkg.develop function:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"# Just using Caesar URL as an example --  Caesar is already on JuliaRegistries/General\nusing Pkg\nPkg.develop(PackageSpec(url=\"https://github.com/JuliaRobotics/Caesar.jl.git\"))","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Unless you change the default environment variable JULIA_PKG_DIR, all packages (git repos) are cloned/installed to ~/.julia. You can work with the packages as regular git repositories there.","category":"page"},{"location":"installation_environment/#Install-Visualization-Tools-1","page":"Installation","title":"Install Visualization Tools","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"RoMEPlotting.jl (2D) and Arena.jl (3D) as optional visualization packages:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"(v1.2) pkg> add RoMEPlotting\n\n# separately\n(v1.2) pkg> add Arena#master","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"note: Note\nArena.jl and Amphitheater.jl are currently being refactored as part of the broader DistributedFactorGraph migration, the features are are in beta stage (1Q2020).","category":"page"},{"location":"installation_environment/#Install-Visualization-Utils-(e.g.-Arena.jl)-1","page":"Installation","title":"Install Visualization Utils (e.g. Arena.jl)","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"3D Visualizations are provided by Arena.jl as well as development package Amphitheater.jl. Please follow instructions on the Visualizations page for a variety of 3D utilities.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Arena.jl can be installed with the following steps:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"]\nadd Arena","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"of the latest development version:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"(v1.0) pkg> add Arena#master","category":"page"},{"location":"installation_environment/#RoMEPlotting.jl-for-2D-plots-1","page":"Installation","title":"RoMEPlotting.jl for 2D plots","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Previous versions of libraries required the following Linux system packages be installed:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"sudo apt-get install libfontconfig1\nsudo apt-get install gettext\nsudo apt-get install libcairo2\nsudo apt-get install libpango1.0-0  # or libpango1.0-1","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"note: Note\nAs of 1Q2020 it is likely that most systems won’t require a system install of libpango or even libcairo.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Please install the latest RoMEPlotting using Package manager as follows:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"$ julia\njulia> ] # to get package manager\n(v1.2) pkg> add RoMEPlotting","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Alternatively, the dev command –- i.e. (v1.2) pkg> dev RoMEPlotting –- will clone the RoMEPlotting.jl git repository to your local .julia/dev/RoMEPlotting folder.","category":"page"},{"location":"installation_environment/#The-\"I-Know-Julia\"-Installation-(TL;DR)-1","page":"Installation","title":"The \"I Know Julia\" Installation (TL;DR)","text":"","category":"section"},{"location":"installation_environment/#Install-Inference-Tools-1","page":"Installation","title":"Install Inference Tools","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Add Caesar to your Julia packages, you can install the metadata registered package 'Caesar' in Julia 1.0 with:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"julia> ] # to enable package manager\n(v1.0) pkg> add Caesar","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Unit tests can further be performed for the upstream packages as follows – NOTE first time runs are slow since each new function call or package must first be precompiled.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"# the multimodal incremental smoothing and mapping solver\n(v1.2) pkg> test IncrementalInference\n...\n# robotics related variables and factors to work with IncrementalInference -- can be used standalone SLAM system\n(v1.2) pkg> test RoME\n...\n# umbrella framework with interaction tools and more -- allows stand alone and server based solving\n(v1.2) pkg> test Caesar\n...","category":"page"},{"location":"installation_environment/#Install-\"Just-the-ZMQ/ROS-Runtime-Solver\"-(Linux)-1","page":"Installation","title":"Install \"Just the ZMQ/ROS Runtime Solver\" (Linux)","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Work in progress (see issue #278).","category":"page"},{"location":"installation_environment/#Contributing,-Issues,-or-Comments-1","page":"Installation","title":"Contributing, Issues, or Comments","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Please feel free to open issues with Caesar.jl or even Fork and Pull Request as required. General conversations or comments can be made in the Caesar Gist.","category":"page"},{"location":"concepts/building_graphs/#Building-and-Solving-Graphs-1","page":"Building Factor Graphs","title":"Building and Solving Graphs","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Irrespective of your application - real-time robotics, batch processing of survey data, or really complex multi-hypothesis modeling - you're going to need to add factors and variables to a graph. This section discusses how to do that in Caesar.","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"The following sections discuss the steps required to construct a graph and solve it:","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Initialing the Factor Graph\nAdding Variables and Factors to the Graph\nSolving the Graph\nInforming the Solver About Ready Data","category":"page"},{"location":"concepts/building_graphs/#What-are-Variables-and-Factors-1","page":"Building Factor Graphs","title":"What are Variables and Factors","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Factor graphs are bipartite, i.e. variables and factors.  In practice we use \"nodes\" to represent both variables and factors with edges between.  In future, we will remove the wording \"node\" from anything Factor Graph usage/abstraction related (only vars and factors).  Nodes and edges will be used as terminology for actually storing the data on some graph storage/process foundation technology.","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Even more meta – factors are \"variables\" that have already been observed and are now stochastically \"fixed\".  Waving hands over the fact that a factors encode both the algebraic model AND the observed measurement values.","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Variables in the factor graph have not been observed, but we want to back them out from the observed values and algebra relating them all.  If factors are constructed from statistically independent measurements (i.e. no direct correlations between measurements other than the algebra already connecting them), then we can use Probabilistic Chain rule to write inference operation down (unnormalized):","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"P(Theta  Z)  =  P(Z  Theta) P(Theta)","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"where Theta represents all variables and Z represents all measurements or data, and","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"P(Theta  Z) = P(Z  Theta) P(Theta)","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"or","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"P(Theta Z) = P(Theta  Z) P(Z)","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"You'll notice the first looks like \"Bayes rule\" and we take P(Z) as a constant (the uncorrelated assumption).","category":"page"},{"location":"concepts/building_graphs/#Initializing-a-Factor-Graph-1","page":"Building Factor Graphs","title":"Initializing a Factor Graph","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"The first step is to model the data (using the most appropriate factors) among variables of interest.  To start model, first create a distributed factor graph object:","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"using Caesar, RoME, Distributions\n\n# start with an empty factor graph object\nfg = initfg()","category":"page"},{"location":"concepts/building_graphs/#Variables-1","page":"Building Factor Graphs","title":"Variables","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Variables (a.k.a. poses or states in navigation lingo) are created with the addVariable! fucntion call.","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"# Add the first pose :x0\naddVariable!(fg, :x0, Pose2)\n# Add a few more poses\nfor i in 1:10\n  addVariable!(fg, Symbol(\"x$(i)\"), Pose2)\nend","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Variables contain a label, a data type (e.g. in 2D RoME.Point2 or RoME.Pose2). Note that variables are solved - i.e. they are the product, what you wish to calculate when the solver runs - so you don't provide any measurements when creating them.","category":"page"},{"location":"concepts/building_graphs/#Factors-1","page":"Building Factor Graphs","title":"Factors","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Factors are algebraic relationships between variables based on data cues such as sensor measurements. Examples of factors are absolute (pre-resolved) GPS readings (unary factors/priors) and odometry changes between pose variables. All factors encode a stochastic measurement (measurement + error), such as below, where a IIF.Prior belief is add to x0 (using the addFactor call) as a normal distribution centered around [0,0,0].","category":"page"},{"location":"concepts/building_graphs/#Priors-1","page":"Building Factor Graphs","title":"Priors","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"# Add at a fixed location Prior to pin :x0 to a starting location (0,0,pi/6.0)\naddFactor!(fg, [:x0], IIF.Prior( MvNormal([0; 0; pi/6.0], Matrix(Diagonal([0.1;0.1;0.05].^2)) )))","category":"page"},{"location":"concepts/building_graphs/#Factors-Between-Variables-1","page":"Building Factor Graphs","title":"Factors Between Variables","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"# Add odometry indicating a zigzag movement\nfor i in 1:10\n  pp = Pose2Pose2(MvNormal([10.0;0; (i % 2 == 0 ? -pi/3 : pi/3)], Matrix(Diagonal([0.1;0.1;0.1].^2))))\n  addFactor!(fg, [Symbol(\"x$(i-1)\"); Symbol(\"x$(i)\")], pp )\nend","category":"page"},{"location":"concepts/building_graphs/#When-to-Instantiate-Poses-(i.e.-new-Variables-in-Factor-Graph)-1","page":"Building Factor Graphs","title":"When to Instantiate Poses (i.e. new Variables in Factor Graph)","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Consider a robot traversing some area while exploring, localizing, and wanting to find strong loop-closure features for consistent mapping.  The creation of new poses and landmark variables is a trade-off in computational complexity and marginalization errors made during factor graph construction.  Common triggers for new poses are:","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Time-based trigger (eg. new pose a second or 5 minutes if stationary)\nDistance traveled (eg. new pose every 0.5 meters)\nRotation angle (eg. new pose every 15 degrees)","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Computation will progress faster if poses and landmarks are very sparse.  To extract the benefit of dense reconstructions, one approach is to use the factor graph as sparse index in history about the general progression of the trajectory and use additional processing from dense sensor data for high-fidelity map reconstructions.  Either interpolations, or better direct reconstructions from inertial data can be used for dense reconstruction.","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"For completeness, one could also re-project the most meaningful measurements from sensor measurements between pose epochs as though measured from the pose epoch.  This approach essentially marginalizes the local dead reckoning drift errors into the local interpose re-projections, but helps keep the pose count low.","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"In addition, see fixed-lag discussion for limiting during inference the number of fluid variables manually to a user desired count.","category":"page"},{"location":"concepts/building_graphs/#Which-Variables-and-Factors-to-use-1","page":"Building Factor Graphs","title":"Which Variables and Factors to use","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"See the next page on available variables and factors","category":"page"},{"location":"dev/wiki/#Developers-Documentation-1","page":"Wiki Pointers","title":"Developers Documentation","text":"","category":"section"},{"location":"dev/wiki/#Standardizing-the-API,-verbNoun-Definitions:-1","page":"Wiki Pointers","title":"Standardizing the API, verbNoun Definitions:","text":"","category":"section"},{"location":"dev/wiki/#","page":"Wiki Pointers","title":"Wiki Pointers","text":"The API derives from a set of standard definitions for verbs and Nouns, please see the developer wiki regarding these definitions.","category":"page"},{"location":"dev/wiki/#Read-DistributedFactorGraphs.jl-Docs-1","page":"Wiki Pointers","title":"Read DistributedFactorGraphs.jl Docs","text":"","category":"section"},{"location":"dev/wiki/#","page":"Wiki Pointers","title":"Wiki Pointers","text":"These are more hardy developer docs, such as the lower level data management API etc.","category":"page"},{"location":"dev/wiki/#Design-Wiki,-Data-and-Architecture-1","page":"Wiki Pointers","title":"Design Wiki, Data and Architecture","text":"","category":"section"},{"location":"dev/wiki/#","page":"Wiki Pointers","title":"Wiki Pointers","text":"More developer zone material will be added here in the future, but for the time being check out the Caesar Wiki.","category":"page"},{"location":"dev/wiki/#Parametric-Solve-Whiteboard-1","page":"Wiki Pointers","title":"Parametric Solve Whiteboard","text":"","category":"section"},{"location":"dev/wiki/#","page":"Wiki Pointers","title":"Wiki Pointers","text":"https://github.com/JuliaRobotics/IncrementalInference.jl/wiki/Parametric-Solve-Whiteboard","category":"page"},{"location":"dev/wiki/#Early-PoC-work-on-Tree-based-Initialization-1","page":"Wiki Pointers","title":"Early PoC work on Tree based Initialization","text":"","category":"section"},{"location":"dev/wiki/#","page":"Wiki Pointers","title":"Wiki Pointers","text":"https://github.com/JuliaRobotics/IncrementalInference.jl/wiki/Tree-Based-Initialization","category":"page"},{"location":"dev/wiki/#Variable-Ordering-Links-1","page":"Wiki Pointers","title":"Variable Ordering Links","text":"","category":"section"},{"location":"dev/wiki/#","page":"Wiki Pointers","title":"Wiki Pointers","text":"Wiki for variable ordering links.","category":"page"},{"location":"dev/wiki/#Developer's-Poem-1","page":"Wiki Pointers","title":"Developer's Poem","text":"","category":"section"},{"location":"dev/wiki/#","page":"Wiki Pointers","title":"Wiki Pointers","text":"Soft gitty, \nWarm gitty, \nMerging change, you sure?\nHappy travy, \nSleepy travy, \nPR PR PR ","category":"page"},{"location":"concepts/arena_visualizations/#Visualization-with-Arena.jl-1","page":"Visualization (3D)","title":"Visualization with Arena.jl","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Visualization (3D)","title":"Visualization (3D)","text":"The sections below discuss 3D visualization techniques available to the Caesar.jl robot navigation system. Caesar.jl uses the Arena.jl package for all the visualization requirements.  This part of the documentation discusses the robotic visualization aspects supported by Arena.jl. Arena.jl supports a wide variety of general visualization as well as developer visualization tools more focused on research and development. The visualizations are also intended to help with subgraph plotting for finding loop closures in data or compare two datasets.","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Visualization (3D)","title":"Visualization (3D)","text":"warning: Warning\nArena and Amphitheater are being upgraded as part of the broader migration to DistributedFactorGraphs (1Q20)","category":"page"},{"location":"concepts/arena_visualizations/#Introduction-1","page":"Visualization (3D)","title":"Introduction","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Visualization (3D)","title":"Visualization (3D)","text":"Over time, Caesar.jl/Arena.jl has used a least three different 3D visualization technologies, with the most recent based on WebGL and three.js by means of the MeshCat.jl package. The previous incarnation used a client side installation of VTK  by means of the DrakeVisualizer.jl and Director libraries. Different 2D plotting libraries have also been used, with evolutions to improve usability for a wider user base. Each epoch has been aimed at reducing dependencies and increasing multi-platform support.","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Visualization (3D)","title":"Visualization (3D)","text":"note: Note\nSee installation page for instructions.","category":"page"},{"location":"concepts/arena_visualizations/#D-Visualization-1","page":"Visualization (3D)","title":"3D Visualization","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Visualization (3D)","title":"Visualization (3D)","text":"warning: Warning\nThis section is out of date, see proof or concept examples in Amphitheater.jl (1Q20).","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Visualization (3D)","title":"Visualization (3D)","text":"Factor graphs of two or three dimensions can be visualized with the 3D visualizations provided by Arena.jl and it's dependencies. The 2D example above and also be visualized in a 3D space with the commands:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Visualization (3D)","title":"Visualization (3D)","text":"vc = startdefaultvisualization() # to load a DrakeVisualizer/Director process instance\nvisualize(fg, vc, drawlandms=false)\n# visualizeallposes!(vc, fg, drawlandms=false)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Visualization (3D)","title":"Visualization (3D)","text":"Here is a basic example of using visualization and multi-core factor graph solving:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Visualization (3D)","title":"Visualization (3D)","text":"addprocs(2)\nusing Caesar, RoME, TransformUtils, Distributions\n\n# load scene and ROV model (might experience UDP packet loss LCM buffer not set)\nsc1 = loadmodel(:scene01); sc1(vc)\nrovt = loadmodel(:rov); rovt(vc)\n\ninitCov = 0.001*eye(6); [initCov[i,i] = 0.00001 for i in 4:6];\nodoCov = 0.0001*eye(6); [odoCov[i,i] = 0.00001 for i in 4:6];\nrangecov, bearingcov = 3e-4, 2e-3\n\n# start and add to a factor graph\nfg = identitypose6fg(initCov=initCov)\ntf = SE3([0.0;0.7;0.0], Euler(pi/4,0.0,0.0) )\naddOdoFG!(fg, Pose3Pose3(MvNormal(veeEuler(tf), odoCov) ) )\n\naddLinearArrayConstraint(fg, (4.0, 0.0), :x0, :l1, rangecov=rangecov,bearingcov=bearingcov)\naddLinearArrayConstraint(fg, (4.0, 0.0), :x1, :l1, rangecov=rangecov,bearingcov=bearingcov)\n\nsolveBatch!(fg)\n\nusing Arena\n\nvc = startdefaultvisualization()\nvisualize(fg, vc, drawlandms=true, densitymeshes=[:l1;:x2])\nvisualizeDensityMesh!(vc, fg, :l1)\n# visualizeallposes!(vc, fg, drawlandms=false)","category":"page"},{"location":"concepts/arena_visualizations/#Previous-3D-Viewer-(VTK-/-Director)-–-no-longer-required-1","page":"Visualization (3D)","title":"Previous 3D Viewer (VTK / Director) – no longer required","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Visualization (3D)","title":"Visualization (3D)","text":"Previous versions used the much larger VTK based Director available via DrakeVisualizer.jl package.  This requires the following preinstalled packages:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Visualization (3D)","title":"Visualization (3D)","text":"    sudo apt-get install libvtk5-qt4-dev python-vtk","category":"page"},{"location":"concepts/interacting_fgs/#Querying-the-FactorGraph-1","page":"Interacting w/ Factor Graphs","title":"Querying the FactorGraph","text":"","category":"section"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"There are a variety of functions to query the factor graph, please refer to Function Reference for details.","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"A quick summary of the variables in the factor graph can be retrieved with:","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"# List variables\nls(fg)\n# List factors attached to x0\nls(fg, :x0)\n# TODO: Provide an overview of getVal, getVert, getBW, getVertKDE, etc.","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"A factor graph object can be visualized using:","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"drawGraph(fg, show=true)","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"By setting show=true, the application evince will be called to show the fg.pdf file that was created using GraphViz.  A GraphPlot.jl visualization engine is also available.","category":"page"},{"location":"concepts/interacting_fgs/#Solving-Graphs-1","page":"Interacting w/ Factor Graphs","title":"Solving Graphs","text":"","category":"section"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"When you have built the graph, you can call the solver to perform inference with the following:","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"# Perform inference\ntree, smt, hist = solveTree!(fg)","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"The returned Bayes (Junction) tree object is described in more detail on a dedicated documentation page, while smt and hist return values most closely relate to development and debug outputs which can be ignored during general use.  Should an error occur during, the exception information is easily accessible in the smt object (as well as file logs which default to /tmp/caesar/).","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"One of the major features of the multimodal-iSAM (mmisam) algorithm (implemented by IncrementalInference.jl) is reducing computational load by recycling and marginalizing different (usually older) parts of the factor graph.  In order to utilize the benefits of recycing, the previous Bayes (Junction) tree should also be provided as input (see fixed-lag examples for more details):","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"tree, smt, hist = solveTree!(fg, tree)","category":"page"},{"location":"concepts/interacting_fgs/#Peeking-at-Results-1","page":"Interacting w/ Factor Graphs","title":"Peeking at Results","text":"","category":"section"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"Once you have solved the graph, you can review the full marginal with:","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"X0 = getKDE(fg, :x0) # Get the raw KDE\n# Evaluate the marginal density function just for fun at [0.01, 0, 0].\nX0([0.01, 0, 0])","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"For finding the MAP value in the density functions, you can use getKDEMax or getKDEMean. Here we are asking for the MAP values for all the variables in the factor graph:","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"varsyms = ls(fg)\nmap(v -> println(\"$v : $(getKDEMax(getKDE(fg, v)))\"), varsyms[1]);","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"Also see built-in function printgraphmax(fg) which performs a similar function.","category":"page"},{"location":"refs/literature/#Literature-1","page":"References","title":"Literature","text":"","category":"section"},{"location":"refs/literature/#","page":"References","title":"References","text":"Newly created page to list related references and additional literature pertaining to this package.","category":"page"},{"location":"refs/literature/#Direct-References-1","page":"References","title":"Direct References","text":"","category":"section"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.1]  Fourie, D., Leonard, J., Kaess, M.: \"A Nonparametric Belief Solution to the Bayes Tree\" IEEE/RSJ Intl. Conf. on Intelligent Robots and Systems (IROS), (2016).","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.2]  Fourie, D.: \"Multi-modal and Inertial Sensor Solutions for Navigation-type Factor   Graphs\", Ph.D. Thesis, Massachusetts Institute of Technology Electrical Engineering and Computer Science together with Woods Hole Oceanographic Institution Department for Applied Ocean Science and Engineering, September 2017.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.3]  Fourie, D., Claassens, S., Pillai, S., Mata, R., Leonard, J.: \"SLAMinDB: Centralized graph databases for mobile robotics\", IEEE Intl. Conf. on Robotics and Automation (ICRA), Singapore, 2017.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.4]  Rypkema, N. R.,: \"Underwater \\& Out of Sight: Towards Ubiquity in UnderwaterRobotics\", Ph.D. Thesis, Massachusetts Institute of Technology Electrical Engineering and Computer Science together with Woods Hole Oceanographic Institution Department for Applied Ocean Science and Engineering, September 2019.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.5]  Cheung, M., Fourie, D., Rypkema, N., Vaz Teixeira, P., Schmidt, H., and Leonard, J.: \"Non-Gaussian SLAM utilizing Synthetic Aperture Sonar\", Intl. Conf. On Robotics and Automation (ICRA), IEEE, Montreal, 2019.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.6]  Doherty, K., Fourie, D., Leonard, J.: \"Multimodal Semantic SLAM with Probabilistic Data Association\", Intl. Conf. On Robotics and Automation (ICRA), IEEE, Montreal, 2019.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.7]  Fourie, D., Vaz Teixeira, P., Leonard, J.: \"Non-parametric Mixed-Manifold Products using Multiscale Kernel Densities\", IEEE Intl. Conf. on Intelligent Robots and Systems (IROS), (2019),.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.8]  Fourie, D., Leonard, J.: \"Inertial Odometry with Retroactive Sensor Calibration\", publication under review.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.9]  Koolen, T. and Deits, R., 2019. Julia for robotics: Simulation and real-time control in a high-level programming language. IEEE, Intl. Conference on Robotics and Automation, ICRA (2019).","category":"page"},{"location":"refs/literature/#Important-References-1","page":"References","title":"Important References","text":"","category":"section"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.1]  Kaess, Michael, et al. \"iSAM2: Incremental smoothing and mapping using the Bayes tree\" The International Journal of Robotics Research (2011): 0278364911430419.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.2]  Kaess, Michael, et al. \"The Bayes tree: An algorithmic foundation for probabilistic robot mapping.\" Algorithmic Foundations of Robotics IX. Springer, Berlin, Heidelberg, 2010. 157-173.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.3]  Kschischang, Frank R., Brendan J. Frey, and Hans-Andrea Loeliger. \"Factor graphs and the sum-product algorithm.\" IEEE Transactions on information theory 47.2 (2001): 498-519.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.4]  Dellaert, Frank, and Michael Kaess. \"Factor graphs for robot perception.\" Foundations and Trends® in Robotics 6.1-2 (2017): 1-139.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.5]  Sudderth, E.B., Ihler, A.T., Isard, M., Freeman, W.T. and Willsky, A.S., 2010. \"Nonparametric belief propagation.\" Communications of the ACM, 53(10), pp.95-103","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.6] Paskin, Mark A. \"Thin junction tree filters for simultaneous localization and mapping.\" in Int. Joint Conf. on Artificial Intelligence. 2003.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.7]  Farrell, J., and Matthew B.: \"The global positioning system and inertial navigation.\" Vol. 61. New York: Mcgraw-hill, 1999.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.8]  Zarchan, Paul, and Howard Musoff, eds. Fundamentals of Kalman filtering: a practical approach. American Institute of Aeronautics and Astronautics, Inc., 2013.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.9]  Hanebeck, Uwe D. \"FLUX: Progressive State Estimation Based on Zakai-type Distributed Ordinary Differential Equations.\" arXiv preprint arXiv:1808.02825 (2018).","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.10]  Muandet, Krikamol, et al. \"Kernel mean embedding of distributions: A review and beyond.\" Foundations and Trends® in Machine Learning 10.1-2 (2017): 1-141.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.11]  Hsiao, M. and Kaess, M., 2019, May. MH-iSAM2: Multi-hypothesis iSAM using Bayes Tree and Hypo-tree. In 2019 International Conference on Robotics and Automation (ICRA) (pp. 1274-1280). IEEE.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.12]  Arnborg, S., Corneil, D.G. and Proskurowski, A., 1987. Complexity of finding embeddings in a k-tree. SIAM Journal on Algebraic Discrete Methods, 8(2), pp.277-284.","category":"page"},{"location":"refs/literature/#Additional-References-1","page":"References","title":"Additional References","text":"","category":"section"},{"location":"refs/literature/#","page":"References","title":"References","text":"[3.1]  Duits, Remco, Erik J. Bekkers, and Alexey Mashtakov. \"Fourier Transform on the Homogeneous Space of 3D Positions and Orientations for Exact Solutions to Linear Parabolic and (Hypo-) Elliptic PDEs.\" arXiv preprint arXiv:1811.00363 (2018).","category":"page"},{"location":"refs/literature/#Signal-Processing-(Beamforming-and-Channel-Deconvolution)-1","page":"References","title":"Signal Processing (Beamforming and Channel Deconvolution)","text":"","category":"section"},{"location":"refs/literature/#","page":"References","title":"References","text":"[4.1]  Van Trees, H.L., 2004. Optimum array processing: Part IV of detection, estimation, and modulation theory. John Wiley & Sons.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[4.2a]  Dowling, D.R., 2013. Acoustic Blind Deconvolution and Unconventional Nonlinear Beamforming in Shallow Ocean Environments. MICHIGAN UNIV ANN ARBOR DEPT OF MECHANICAL ENGINEERING.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[4.2b]  Hossein Abadi, S., 2013. Blind deconvolution in multipath environments and extensions to remote source localization, paper, thesis.","category":"page"},{"location":"principles/approxConvDensities/#Principle:-Approximate-Convolutions-1","page":"Generic Convolutions","title":"Principle: Approximate Convolutions","text":"","category":"section"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"This example illustrates a central concept of approximating the convolution of belief density functions.  Convolutions are required to compute (estimate) the probabilistic chain rule with conditional probability density functions.  One easy illustration is robotics where an odometry chain of poses has a continuous increase–-or spreading–-of the confidence/uncertainty of a next pose.  This tutorial will demonstrate that process.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"This page describes a Julia language interface, followed by a CaesarZMQ interface; a link to the mathematical description is provided thereafter.","category":"page"},{"location":"principles/approxConvDensities/#Convolutions-of-Infinite-Objects-(Functionals)-1","page":"Generic Convolutions","title":"Convolutions of Infinite Objects (Functionals)","text":"","category":"section"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"Consider the following vehicle odometry prediction (probabilistic) operation, where odometry measurement Z is an independent stochastic process from prior belief on pose X0","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"p(X_1  X_0 Z) propto p(Z  X_0 X_1) p(X_0)","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"and recognize this process as a convolution operation where the prior belief on X0 is spread to a less certain prediction of pose X1.  The figure below shows an example quasi-deterministic convolution of green densitty with the red density, which results in the black density below:","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"<a href=\"https://darchive.mblwhoilibrary.org/bitstream/handle/1912/9305/Fourie_thesis.pdf?sequence=1\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/6412556/61175404-3b4f9d80-a59e-11e9-85db-ca6bbdb73ffd.png\" alt=\"Bayes/Junction tree example\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"Note that this operation is precisely the same as a prediction step in filtering applications, where the state transition model–-usually annotated as d/dt x = f(x, z)–-is here presented by the conditional belief p(Z | X_0, X_1).","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"The convolution computation described above is a core operation required for solving the Chapman-Kolmogorov transit equations.","category":"page"},{"location":"principles/approxConvDensities/#Underlying-Mathematical-Operations-1","page":"Generic Convolutions","title":"Underlying Mathematical Operations","text":"","category":"section"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"In order to compute generic convolutions, the mmisam algorithm uses non-linear gradient descent to resolve estimates of the target variable based on the values of other dependent variables.  The conditional likelihood (multidimensional factor) is based on a residual function:","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"z_i = delta_i (theta_i)","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"where z_i is the innovation of any smooth twice differentiable residual function delta.  The residual function depends on specific variables collected as theta_i.  The IIF code supports both root finding or minimization trust-region operations, which are each provided by NLsolve.jl or Optim.jl packages respectively.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"The choice between root finding or minimization is a performance consideration only.  Minimization of the residual squared will always work but certain situations allow direct root finding to be used.  If the residual function is guaranteed to cross zero–-i.e. z*=0–-the root finding approach can be used.  Each measurement function has a certain number of dimensions – e.g. ranges or bearings are dimension one, and an inter Pose2 rigid transform (delta x, y, theta) is dimension 3.  If the variable being resolved has larger dimension than the measurement residual, then the minimization approach must be used.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"The method of solving the target variable is to fix all other variable values and resolve, sample by sample, the particle estimates of the target.  The Julia programming language has good support for functional programming and is used extensively in the IIF implementation to utilize user defined functions to resolve any variable, including the null-hypothesis and multi-hypothesis generalizations.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"The following section illustrates a single convolution operation by using a few high level and some low level function calls.  An additional tutorial exists where a related example in one dimension is performed as a complete factor graph solution/estimation problem.","category":"page"},{"location":"principles/approxConvDensities/#Previous-Text-(to-be-merged-here)-1","page":"Generic Convolutions","title":"Previous Text (to be merged here)","text":"","category":"section"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"Proposal distributions are computed by means of (analytical or numerical – i.e. \"algebraic\") factor which defines a residual function:","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"delta  S times Eta rightarrow mathcalR","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"where S times Eta is the domain such that theta_i in S  eta sim P(Eta), and P(cdot) is a probability.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"A trust-region, nonlinear gradient decent method is used to enforce the residual function delta (theta_S) in a leave-one-out-Gibbs strategy for all the factors and variables in each clique.  Each time a factor residual is enforced for another particle along with a sample from the stochastic noise term.  Solutions are found either through root finding on \"full dimension\" equations (source code here):","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"textsolve_theta_i  st  0 = delta(theta_S eta)","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"Or minimization of \"low dimension\" equations (source code here) that might not have any roots in theta_i:","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"textargmin_theta_i  delta(theta_S eta)^2","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"Gradient decent methods are obtained from the Julia Package community, namely NLsolve.jl and Optim.jl.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"The factor noise term can be any samplable belief (a.k.a. IIF.SamplableBelief), either through algebraic modeling, or (critically) directly from the sensor measurement that is driven by the underlying physics process.  Parametric factors (Distributions.jl) or direct physical measurement noise can be used via AliasingScalarSampler or KernelDensityEstimate.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"note: Note\nAlso see [1.2], Chap. 5, Approximate Convolutions for more details.","category":"page"},{"location":"principles/approxConvDensities/#Illustrated-Calculation-in-Julia-1","page":"Generic Convolutions","title":"Illustrated Calculation in Julia","text":"","category":"section"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"The IncrementalInference.jl package provides a generic interface for estimating the convolution of full functional objects given some user specified residual or cost function.  The residual/cost function is then used, with the help of non-linear gradient decent, to project/resolve a set of particles for any one variable associated with a any factor.  In the binary variable factor case, such as the odometry tutorial, either pose X2 will be resolved from X1 using the user supplied likelihood residual function, or visa versa for X1 from X2.  ","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"note: Note\nNote in a factor graph sense, the flow of time is captured in the structure of the graph and a requirement of the IncrementalInference system is that factors can be resolved towards any variable, given current estimates on all other variables connected to that factor.  Furthermore, this forwards or backwards resolving/convolution through a factor should adhere to the Kolmogorov Criterion of reversibility to ensure that detailed balance is maintained in the overall marginal posterior solutions.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"The IncrementalInference (IIF) package provides a few generic conditional likelihood functions such as LinearConditional or MixtureLinearConditional which we will use in this illustration.  ","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"note: Note\nNote that the RoME.jl package provides many more factors that are useful to robotics applications.  For a listing of current factors see this docs page, details on developing your own factors on this page.  One of the clear design objectives of the IIF package was to allow easier user extension of arbitrary residual functions that allows for vast capacity to represent non-Gaussian stochastic processes.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"Consider a robot traveling in one dimension, progressing along the x-axis at varying speed.  Lets assume pose locations are determined by a constant delta-time rule of say one pose every second, named X0, X1, X2, and so on.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"note: Note\nNote the bread-crum discretization of the trajectory history by means of poses can later be used to allow estimation of previously unknown mapping parameters simultaneous to the ongoing localization problem.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"Lets a few basic factor graph operations to develop the desired convolutions:","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"using IncrementalInference\n\n# empty factor graph container\nfg = initfg()\n\n# add two variables of interest\naddVariable!(fg, :x0, ContinuousScalar)\naddVariable!(fg, :x1, ContinuousScalar)\n\n# gauge the solution by adding the first prior information that represents all history up to the current starting position for the robot\npr = Prior(Normal(0.0, 0.1))\naddFactor!(fg, [:x0], pr)\n\n# numerically initialize variable :x0 -- this avoids repeat computations later (specific to this tutorial)\ndoautoinit!(fg, :x0)\n\n# lastly add the odometry conditional likelihood function between the two variables of interest\nodo = LinearConditional(Rayleigh(...))\naddFactor!(fg, [:x0;:x1], odo)  # note the list is order sensitive","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"The code block above (not solved yet) describes a algebraic setup exactly equivalent to the convolution equation presented at the top of this page.  ","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"note: Note\nIIF does not require the distribution functions to only be parametric, such as Normal, Rayleigh, mixture models, but also allows intensity based values or kernel density estimates.  Parametric types are just used here for ease of illustration.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"To perform an stochastic approximate convolution with the odometry conditional, one can simply call a low level function used the mmisam solver:","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"pts = approxConv(fg, :x0x1f1, :x1)","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"The approxConv function call reads as a operation on fg which won't influence any values of parameter list (common Julia exclamation mark convention) and must use the first factor :x0x1f1 to resolve a convolution on target variable :x1.  Implicitly, this result is based on the current estimate contained in :x0.  The value of pts is a :;Array{Float64,2} where the rows represent the different dimensions (1-D in this case) and the columns are each of the different samples drawn from the intermediate posterior (i.e. convolution result).  ","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"IIF currently uses kernel density estimation to convert discrete samples into a smooth function estimate – more details can be found on the function approximation principles page here.  The sample set can be converted into an on-manifold functional object as follows:","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"# create kde object by referencing back the existing memory location pts\nhatX1 = manikde!(pts, ContinuousScalar)","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"The functional object X1 is now ready for other operations such as function evaluation or product computations discussed on another principles page.  The ContinuousScalar manifold is just the real line in Euclidean space, internally denoted as single element tuple (:Euclid,).","category":"page"},{"location":"principles/approxConvDensities/#A-Handy-ZMQ-interface-to-Generic-Convolutions-1","page":"Generic Convolutions","title":"A Handy ZMQ interface to Generic Convolutions","text":"","category":"section"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"NOTE WIP on expanding ZMQ interface:","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"In addition, ZmqCaesar offers a ZMQ interface to the factor graph solution for multilanguage support.  This example is a small subset that shows how to use the ZMQ infrastructure, but avoids the larger factor graph related calls.","category":"page"},{"location":"principles/approxConvDensities/#","page":"Generic Convolutions","title":"Generic Convolutions","text":"...","category":"page"},{"location":"concepts/available_varfacs/#Variables-in-Caesar.jl-1","page":"Available Variables/Factors","title":"Variables in Caesar.jl","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"You can check for the latest variable types by running the following in your terminal:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"using RoME, Caesar\nsubtypes(IncrementalInference.InferenceVariable)\nIncrementalInference.getCurrentWorkspaceVariables()","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Default variables in IncrementalInference","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"ContinuousScalar\nContinuousMultivariate","category":"page"},{"location":"concepts/available_varfacs/#IncrementalInference.ContinuousScalar","page":"Available Variables/Factors","title":"IncrementalInference.ContinuousScalar","text":"struct ContinuousScalar <: InferenceVariable\n\nMost basic continuous scalar variable a ::FactorGraph object.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#IncrementalInference.ContinuousMultivariate","page":"Available Variables/Factors","title":"IncrementalInference.ContinuousMultivariate","text":"struct ContinuousMultivariate{T1<:Tuple} <: InferenceVariable\n\nContinuous variable of dimension .dims on manifold .manifolds.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#D-Variables-1","page":"Available Variables/Factors","title":"2D Variables","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"The current variables types are:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Point2\nPose2\nDynPoint2\nDynPose2","category":"page"},{"location":"concepts/available_varfacs/#RoME.Point2","page":"Available Variables/Factors","title":"RoME.Point2","text":"struct Point2 <: InferenceVariable\n\nXY Euclidean manifold variable node softtype.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2","page":"Available Variables/Factors","title":"RoME.Pose2","text":"struct Pose2 <: InferenceVariable\n\nPose2 is a SE(2) mechanization of two Euclidean translations and one Circular rotation, used for general 2D SLAM.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPoint2","page":"Available Variables/Factors","title":"RoME.DynPoint2","text":"mutable struct DynPoint2 <: InferenceVariable\n\nDynamic point in 2D space with velocity components: x, y, dx/dt, dy/dt\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPose2","page":"Available Variables/Factors","title":"RoME.DynPose2","text":"mutable struct DynPose2 <: InferenceVariable\n\nDynamic pose variable with velocity components: x, y, theta, dx/dt, dy/dt\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#D-Variables-2","page":"Available Variables/Factors","title":"3D Variables","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Point3\nPose3\nInertialPose3","category":"page"},{"location":"concepts/available_varfacs/#RoME.Point3","page":"Available Variables/Factors","title":"RoME.Point3","text":"struct Point3 <: InferenceVariable\n\nXYZ Euclidean manifold variable node softtype.\n\nExample\n\np3 = Point3()\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose3","page":"Available Variables/Factors","title":"RoME.Pose3","text":"struct Pose3 <: InferenceVariable\n\nPose3 is currently a Euler angle mechanization of three Euclidean translations and three Circular rotation.\n\nFuture:\n\nWork in progress on AMP3D for proper non-Euler angle on-manifold operations.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.InertialPose3","page":"Available Variables/Factors","title":"RoME.InertialPose3","text":"mutable struct InertialPose3 <: FunctorPairwise\n\nInertial Odometry version of preintegration procedure and used as a factor between InertialPose3 types for inertial navigation in factor graphs.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"note: Note\nPlease open an issue with JuliaRobotics/RoME.jl for specific requests, problems, or suggestions.  Contributions are also welcome.  There might be more variable types in Caesar/RoME/IIF not yet documented here.","category":"page"},{"location":"concepts/available_varfacs/#Factors-in-Caesar.jl-1","page":"Available Variables/Factors","title":"Factors in Caesar.jl","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"You can check for the latest factor types by running the following in your terminal:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"using RoME, Caesar\nprintln(\"- Singletons (priors): \")\nprintln.(sort(string.(subtypes(IncrementalInference.FunctorSingleton))));\nprintln(\"- Pairwise (variable constraints): \")\nprintln.(sort(string.(subtypes(IncrementalInference.FunctorPairwise))));\nprintln(\"- Pairwise (variable minimization constraints): \")\nprintln.(sort(string.(subtypes(IncrementalInference.FunctorPairwiseMinimize))));","category":"page"},{"location":"concepts/available_varfacs/#Priors-(Absolute-Data)-1","page":"Available Variables/Factors","title":"Priors (Absolute Data)","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Defaults in IncrementalInference.jl:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Prior\nPartialPrior\nMixturePrior","category":"page"},{"location":"concepts/available_varfacs/#IncrementalInference.Prior","page":"Available Variables/Factors","title":"IncrementalInference.Prior","text":"struct Prior{T} <: FunctorSingleton\n\nDefault prior on all dimensions of a variable node in the factor graph.  Prior is not recommended when non-Euclidean dimensions are used in variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#IncrementalInference.PartialPrior","page":"Available Variables/Factors","title":"IncrementalInference.PartialPrior","text":"struct PartialPrior{T, P} <: FunctorSingleton\n\nPartial prior belief (absolute data) on any variable, given <:SamplableBelief and which dimensions of the intended variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#IncrementalInference.MixturePrior","page":"Available Variables/Factors","title":"IncrementalInference.MixturePrior","text":"struct MixturePrior{T} <: FunctorSingleton\n\nDefine a categorical mixture of prior beliefs on a variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Some of the most common priors (unary factors) in Caesar.jl/RoME.jl include:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"PriorPolar\nPriorPoint2\nPriorPose2\nPriorPoint3\nPriorPose3","category":"page"},{"location":"concepts/available_varfacs/#RoME.PriorPolar","page":"Available Variables/Factors","title":"RoME.PriorPolar","text":"mutable struct PriorPolar{T1<:Union{AliasingScalarSampler, BallTreeDensity, Distribution}, T2<:Union{AliasingScalarSampler, BallTreeDensity, Distribution}} <: FunctorSingleton\n\nPrior belief on any Polar related variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPoint2","page":"Available Variables/Factors","title":"RoME.PriorPoint2","text":"mutable struct PriorPoint2{T} <: FunctorSingleton\n\nDirection observation information of a Point2 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPose2","page":"Available Variables/Factors","title":"RoME.PriorPose2","text":"mutable struct PriorPose2{T} <: FunctorSingleton\n\nIntroduce direct observations on all dimensions of a Pose2 variable:\n\nExample:\n\nPriorPose2( MvNormal([10; 10; pi/6.0], Matrix(Diagonal([0.1;0.1;0.05].^2))) )\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPoint3","page":"Available Variables/Factors","title":"RoME.PriorPoint3","text":"mutable struct PriorPoint3{T} <: FunctorSingleton\n\nDirection observation information of a Point3 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPose3","page":"Available Variables/Factors","title":"RoME.PriorPose3","text":"mutable struct PriorPose3 <: FunctorSingleton\n\nDirect observation information of Pose3 variable type.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#Conditional-Likelihoods-(Relative-Data)-1","page":"Available Variables/Factors","title":"Conditional Likelihoods (Relative Data)","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Defaults in IncrementalInference.jl:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"LinearConditional\nMixtureLinearConditional","category":"page"},{"location":"concepts/available_varfacs/#IncrementalInference.LinearConditional","page":"Available Variables/Factors","title":"IncrementalInference.LinearConditional","text":"struct LinearConditional{T} <: FunctorPairwise\n\nDefault linear offset between two scalar variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#IncrementalInference.MixtureLinearConditional","page":"Available Variables/Factors","title":"IncrementalInference.MixtureLinearConditional","text":"struct MixtureLinearConditional{T} <: FunctorPairwise\n\nDefine a categorical mixture of (relative) likelihood beliefs between any two variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Existing n-ary factors in Caesar.jl/RoME.jl/IIF.jl include:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"PolarPolar\nPoint2Point2\nPoint2Point2WorldBearing\nPose2Point2Bearing\nPose2Point2BearingRange\nPose2Point2Range\nPose2Pose2\nDynPoint2VelocityPrior\nDynPoint2DynPoint2\nVelPoint2VelPoint2\nPoint2Point2Velocity\nDynPose2VelocityPrior\nVelPose2VelPose2\nDynPose2Pose2\nPose3Pose3\nPriorPose3ZRP\nPartialPriorRollPitchZ\nPartialPose3XYYaw\nPose3Pose3XYYaw","category":"page"},{"location":"concepts/available_varfacs/#RoME.PolarPolar","page":"Available Variables/Factors","title":"RoME.PolarPolar","text":"mutable struct PolarPolar{T1<:Union{AliasingScalarSampler, BallTreeDensity, Distribution}, T2<:Union{AliasingScalarSampler, BallTreeDensity, Distribution}} <: FunctorPairwise\n\nLinear offset factor of IIF.SamplableBelief between two Polar variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Point2Point2","page":"Available Variables/Factors","title":"RoME.Point2Point2","text":"mutable struct Point2Point2{D<:Union{AliasingScalarSampler, BallTreeDensity, Distribution}} <: FunctorPairwise\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Point2Point2WorldBearing","page":"Available Variables/Factors","title":"RoME.Point2Point2WorldBearing","text":"mutable struct Point2Point2WorldBearing{T} <: FunctorPairwise\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2Point2Bearing","page":"Available Variables/Factors","title":"RoME.Pose2Point2Bearing","text":"struct Pose2Point2Bearing{B<:Union{AliasingScalarSampler, BallTreeDensity, Distribution}} <: FunctorPairwiseMinimize\n\nSingle dimension bearing constraint from Pose2 to Point2 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2Point2BearingRange","page":"Available Variables/Factors","title":"RoME.Pose2Point2BearingRange","text":"mutable struct Pose2Point2BearingRange{B<:Union{AliasingScalarSampler, BallTreeDensity, Distribution}, R<:Union{AliasingScalarSampler, BallTreeDensity, Distribution}} <: FunctorPairwiseMinimize\n\nBearing and Range constraint from a Pose2 to Point2 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2Point2Range","page":"Available Variables/Factors","title":"RoME.Pose2Point2Range","text":"mutable struct Pose2Point2Range{T} <: FunctorPairwiseMinimize\n\nRange only measurement from Pose2 to Point2 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2Pose2","page":"Available Variables/Factors","title":"RoME.Pose2Pose2","text":"struct Pose2Pose2{T} <: FunctorPairwise\n\nRigid transform between two Pose2's, assuming (x,y,theta).\n\nRelated\n\nPose3Pose3, Point2Point2, MutablePose2Pose2Gaussian, DynPose2, InertialPose3\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPoint2VelocityPrior","page":"Available Variables/Factors","title":"RoME.DynPoint2VelocityPrior","text":"mutable struct DynPoint2VelocityPrior{T} <: FunctorSingleton\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPoint2DynPoint2","page":"Available Variables/Factors","title":"RoME.DynPoint2DynPoint2","text":"mutable struct DynPoint2DynPoint2{T} <: FunctorPairwise\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.VelPoint2VelPoint2","page":"Available Variables/Factors","title":"RoME.VelPoint2VelPoint2","text":"mutable struct VelPoint2VelPoint2{T} <: FunctorPairwiseMinimize\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Point2Point2Velocity","page":"Available Variables/Factors","title":"RoME.Point2Point2Velocity","text":"mutable struct Point2Point2Velocity{T} <: FunctorPairwiseMinimize\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPose2VelocityPrior","page":"Available Variables/Factors","title":"RoME.DynPose2VelocityPrior","text":"mutable struct DynPose2VelocityPrior{T1, T2} <: FunctorSingleton\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.VelPose2VelPose2","page":"Available Variables/Factors","title":"RoME.VelPose2VelPose2","text":"mutable struct VelPose2VelPose2{T1, T2} <: FunctorPairwiseMinimize\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPose2Pose2","page":"Available Variables/Factors","title":"RoME.DynPose2Pose2","text":"mutable struct DynPose2Pose2{T} <: FunctorPairwise\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose3Pose3","page":"Available Variables/Factors","title":"RoME.Pose3Pose3","text":"mutable struct Pose3Pose3 <: FunctorPairwise\n\nRigid transform factor between two Pose3 compliant variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPose3ZRP","page":"Available Variables/Factors","title":"RoME.PriorPose3ZRP","text":"mutable struct PriorPose3ZRP{T1, T2} <: FunctorSingleton\n\nPartial prior belief on Z, Roll, and Pitch of a Pose3.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PartialPriorRollPitchZ","page":"Available Variables/Factors","title":"RoME.PartialPriorRollPitchZ","text":"mutable struct PartialPriorRollPitchZ{T1, T2} <: FunctorSingleton\n\nPartial prior belief on Roll Pitch and Z of a Pose3 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PartialPose3XYYaw","page":"Available Variables/Factors","title":"RoME.PartialPose3XYYaw","text":"mutable struct PartialPose3XYYaw{T1, T2} <: FunctorPairwise\n\nPartial factor between XY and Yaw of two Pose3 variables.\n\nTo be deprecated: use Pose3Pose3XYYaw instead.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose3Pose3XYYaw","page":"Available Variables/Factors","title":"RoME.Pose3Pose3XYYaw","text":"mutable struct Pose3Pose3XYYaw{T1, T2} <: FunctorPairwise\n\nPartial factor between XY and Yaw of two Pose3 variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#Extending-Caesar-with-New-Variables-and-Factors-1","page":"Available Variables/Factors","title":"Extending Caesar with New Variables and Factors","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"A question that frequently arises is how to design custom variables and factors to solve a specific type of graph. One strength of Caesar is the ability to incorporate new variables and factors at will. Please refer to Adding Factors for more information on creating your own factors.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/47298402-ace95500-d5e5-11e8-8607-593525445d14.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Caesar is an open-source robotic software stack for combining heterogeneous and ambiguous data streams.  The focus is predominantly on geometric/spatial estimation tasks related to simultaneous localization and mapping (SLAM), but this software is also highly extensible and well suited to a variety of estimation/filtering-type tasks — especially in non-Gaussian/multimodal settings.  Caesar.jl addresses numerous issues that arise in prior SLAM solutions: solving under-defined systems, inference with non-Gaussian measurements, standard features for natively handling ambiguous data association and multi-hypotheses, simplifying bespoke factor development, centralized (or peer-to-peer distributed) factor-graph persistence with databases and cloud infrastructure, federated multi-session/agent reduction.  Caesar.jl originates from research work in navigation systems, see the literature reference page for more information.","category":"page"},{"location":"#Focus-Area-1","page":"Introduction","title":"Focus Area","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This project focuses on the open development of a stable, reliable, verified, user-friendly, and growing library that is well suited to various data-fusion / state-estimation aspects of robotics and autonomy in non-Gaussian/multi-modal data processing.","category":"page"},{"location":"#The-Caesar-Framework-1","page":"Introduction","title":"The Caesar Framework","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The Caesar.jl package is an \"umbrella\" framework around other dedicated algorithmic packages.  While most of the packages are implemented in native Julia (JuliaPro), a few dependencies are wrapped C libraries.  Note that C/C++ can be incorporated with zero overhead, such as was done with AprilTags.jl.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"FAQ: Why use Julia?","category":"page"},{"location":"#RoME.jl/IncrementalInference.jl/ApproxManifoldProducts.jl-1","page":"Introduction","title":"RoME.jl/IncrementalInference.jl/ApproxManifoldProducts.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Robot motion estimate (RoME.jl) can operate in the conventional SLAM manner, using local memory (dictionaries), or alternatively distribute over a persisted DistributedFactorGraph.jl through common serialization and graph storage/database technologies, see this article as example [1.3].   A variety of 2D plotting, 3D visualization, serialization, middleware, and analysis tools come standard as provided by the associated packages.  RoME.jl combines reference frame transformations and robotics SLAM tool around the back-end solver provides by IncrementalInference.jl.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Details about the accompanying packages:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"IncrementalInference.jl supplies the algebraic logic for factor graph inference with Bayes tree and depends on several packages itself.\nRoME.jl introduces nodes and factors that are useful to robotic navigation.\nApproxManifoldProducts.jl provides on-manifold belief product operations.","category":"page"},{"location":"#Visualization-(Arena.jl/RoMEPlotting.jl)-1","page":"Introduction","title":"Visualization (Arena.jl/RoMEPlotting.jl)","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Caesar visualization (plotting of results, graphs, and data) is provided by 2D and 3D packages respectively:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"RoMEPlotting.jl are a set of scripts that provide MATLAB style plotting of factor graph beliefs, mostly supporting 2D visualization with some support for projections of 3D;\nArena.jl package, which is a collection of 3D visualization tools.","category":"page"},{"location":"#Multilanguage-Interops:-Caesar-SDKs-and-APIs-1","page":"Introduction","title":"Multilanguage Interops: Caesar SDKs and APIs","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The Caesar framework is not limited to direct Julia use.  See the multi-language page for details.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"FAQ: Interop with other languages (not limited to Julia only)","category":"page"},{"location":"#A-Few-Highlights-1","page":"Introduction","title":"A Few Highlights","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The Caesar framework has the following features:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Distributed Factor Graph representation of pose and sensor data\nLocalization using Multi-modal iSAM\nMulti-core inference supporting Pose2, Pose3, Point2, Point3, Multi-modal (multi-hypothesis), IMU preintegration, KDE density, intensity map, partial constraints, null hypothesis, etc\nMulti-modal and non-parametric representation of constraints\nGaussian distributions are but one of the many representations of measurement error\nSimple, extensible framework for creation of new factor types\nMulti-hypothesis representation in the factor-graph\nLocal in-memory solving on the device as well as database-driven centralized solving (micro-service architecture).\nFixed-lag, continuous operation as well as off-line batch solving","category":"page"},{"location":"#Origins-in-Fundamental-Research-1","page":"Introduction","title":"Origins in Fundamental Research","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"See related works on the literature page.  Many future directions are in the works – including fundamental research, implementation quality/performance, and system integration.  Please see/open issues for specific requests or adding comments to an ongoing discussion – also consult the Caesar.jl Slack channel to follow/engage with community discussions.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"note: Note\nPlease help improve this documentation–if something confuses you, chances are you're not alone. It's easy to do as you read along: just click on the \"Edit on GitHub\" link above, and then edit the files directly in your browser. Your changes will be vetted by developers before becoming permanent, so don't worry about whether you might say something wrong.","category":"page"},{"location":"#Next-Steps-1","page":"Introduction","title":"Next Steps","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"For installation steps, examples/tutorials, and concepts please refer to the following pages:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"installation_environment.md\"\n    \"concepts/concepts.md\"\n    \"examples/examples.md\"\n    \"func_ref.md\"\n]\nDepth = 3","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Please file issues here as needed to help resolve problems for everyone! We are tracking improvements and new endeavors on the Issues page of this repository – issues frequently are moved upstream into each of the indivisual library packages, while Caesar.jl frequently acts as a catchall to help get problems resolved.","category":"page"},{"location":"#JuliaRobotics-Code-of-Conduct-1","page":"Introduction","title":"JuliaRobotics Code of Conduct","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The Caesar repository is part of the JuliaRobotics organization and adheres to the JuliaRobotics code-of-conduct.","category":"page"},{"location":"#Contributors-1","page":"Introduction","title":"Contributors","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"We are grateful for many, many contributions within the Julia package ecosystem – see the Project.toml files of Caesar, Arena, RoME, RoMEPlotting, KernelDensityEstimate, IncrementalInference, NLsolve, Graphs, MeshCat and others for a far reaching list of contributions.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Consider citing our work:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"@misc{caesarjl,\n  author = \"Contributors and Packages\",\n  title =  \"Caesar.jl\",\n  year =   2020,\n  url =    \"https://github.com/JuliaRobotics/Caesar.jl\"\n}","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Administration of the Caesar/RoME/IncrementalInference/Arena packages is currently conducted by Dehann Fourie who can be contacted for more details.","category":"page"},{"location":"examples/interm_dynpose/#Adding-Dynamic-Factors-and-Variables-1","page":"Creating DynPose Factor","title":"Adding Dynamic Factors and Variables","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"This tutorial describes how a new factor can be developed, beyond the pre-existing implementation in RoME.jl.  Factors can accept any number of variable dependencies and allow for a wide class of allowable function calls can be used.  Our intention is to make it as easy as possible for users to create their own factor types.","category":"page"},{"location":"examples/interm_dynpose/#Example:-Adding-Velocity-to-RoME.Point2-1","page":"Creating DynPose Factor","title":"Example: Adding Velocity to RoME.Point2","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A smaller example in two dimensions where we wish to estimate the velocity of some target:  Consider two variables :x0 with a prior as well as a conditional–-likelihood for short–-to variable :x1.  Priors are in the \"global\" reference frame (how ever you choose to define it), while likelihoods are in the \"local\" / \"relative\" frame that only exist between variables.","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"(Image: dynpoint2fg)","category":"page"},{"location":"examples/interm_dynpose/#Brief-on-Variable-Node-softtypes-1","page":"Creating DynPose Factor","title":"Brief on Variable Node softtypes","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Variable nodes retain meta data (so called \"soft types\") describing the type of variable.  Common VariableNode types are RoME.Point2D, RoME.Pose3D.  VariableNode soft types are passed during construction of the factor graph, for example:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"v1 = addVariable!(fg, :x1, Pose2)","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Certain cases require that more information be retained for each VariableNode, and velocity calculations are a clear example where time stamp data across positions is required.  ","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Note Larger data can also be stored under the bigdata framework which is discussed here (TBD).","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"If the required VariableNode does not exist, then one can be created, such as adding velocity states with DynPoint2:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct DynPoint2 <: IncrementalInference.InferenceVariable\n  ut::Int64 # microsecond time\n  dims::Int\n  DynPoint2(;ut::Int64=0) = new(ut, 4)\nend","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"The dims field is permanently set to 4, i.e. [x, y, dx/dt, dy/dt].  The utparameter is for storing the microsecond time stamp for that variable node.","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"In order to implement your own factor type outside IncrementalInference you should import the required identifiers, as follows:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"using IncrementalInference\nimport IncrementalInference: getSample","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Note that new factor types can be defined at any time, even after you have started to construct the FactorGraph object.","category":"page"},{"location":"examples/interm_dynpose/#DynPoint2VelocityPrior-1","page":"Creating DynPose Factor","title":"DynPoint2VelocityPrior","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Work in progress.","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct DynPoint2VelocityPrior{T} <: IncrementalInference.FunctorSingleton where {T <: Distribution}\n  z::T\n  DynPoint2VelocityPrior{T}() where {T <: Distribution} = new{T}()\n  DynPoint2VelocityPrior(z1::T) where {T <: Distribution} = new{T}(z1)\nend\ngetSample(dp2v::DynPoint2VelocityPrior, N::Int=1) = (rand(dp2v.z,N), )","category":"page"},{"location":"examples/interm_dynpose/#DynPoint2DynPoint2-(preintegration)-1","page":"Creating DynPose Factor","title":"DynPoint2DynPoint2 (preintegration)","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"The basic idea is that change in position is composed of three components (originating from double integration of Newton's second law):","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"(Image: deltapositionplus) ( eq. 1)","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"DynPoint2DynPoint2 factor is using the above equation to define the difference in position between the two DynPoint2s.  The position part stored in DynPoint2DynPoint2 factor corresponds to (Image: deltaposplusonly).  A new multi-variable (so called \"pairwise\") factor between any number of variables is defined with three elements:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Factor type definition that inherits either IncrementalInference.FunctorPairwise or IncrementalInference.FunctorPairwiseMinimize;","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct DynPoint2DynPoint2{T} <: IncrementalInference.FunctorPairwise where {T <: Distribution}\n  z::T\n  DynPoint2DynPoint2{T}() where {T <: Distribution} = new{T}()\n  DynPoint2DynPoint2(z1::T) where {T <: Distribution} = new{T}(z1)\nend","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A sampling function with exactly the signature: getSample(dp2dp2::DynPoint2DynPoint2, N::Int=1) and returning a Tuple (legacy reasons);","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"getSample(dp2dp2::DynPoint2DynPoint2, N::Int=1) = (rand(dp2dp2.z,N), )","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A residual or minimization function with exactly the signature described below.","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Residual (related to FunctorPairwise) or factor minimization function (related to FunctorPairwiseMinimize) signatures should match this dp2dp2::DynPoint2DynPoint2 example:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"function (dp2dp2::DynPoint2DynPoint2)(\n            res::Array{Float64},\n            userdata,\n            idx::Int,\n            meas::Tuple,\n            Xs...  )::Nothing","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"where Xs can be expanded to the particular number of variable nodes this factor will be associated, and note they are order sensitive at addFactor!(fg, ...) time.  The res parameter is a vector of the same dimension defined by the largest of the Xs terms.  The userdata value contains the small metadata / userdata portions of information that was introduced to the factor graph at construction time – please consult error(string(fieldnames(userdata))) for details at this time.  This is a relatively new feature in the code and likely to be improved.  The idx parameter represents a legacy index into the measurement meas[1] and variables Xs to select the desired marginal sample value.  Future versions of the code plan to remove the idx parameter entirely.  The Xs array of parameter are each of type ::Array{Float64,2} and contain the estimated samples from each of the current best marginal belief estimates of the factor graph variable node.  ","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"function (dp2dp2::DynPoint2DynPoint2)(\n            res::Array{Float64},\n            userdata,\n            idx::Int,\n            meas::Tuple,\n            Xi::Array{Float64,2},\n            Xj::Array{Float64,2}  )\n  #\n  z = meas[1][:,idx]\n  xi, xj = Xi[:,idx], Xj[:,idx]\n  dt = (userdata.variableuserdata[2].ut - userdata.variableuserdata[1].ut)*1e-6   # roughly the intended use of userdata\n  res[1:2] = z[1:2] - (xj[1:2] - (xi[1:2]+dt*xi[3:4]))\n  res[3:4] = z[3:4] - (xj[3:4] - xi[3:4])\n  nothing\nend","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A brief usage example looks as follows, and further questions about how the preintegration strategy was implemented can be traced through the original issue JuliaRobotics/RoME.jl#60 or the literature associated with this project, or contact for more information.","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"using RoME, Distributions\nfg = initfg()\nv0 = addVariable!(fg, :x0, DynPoint2(ut=0))\n\n# Prior factor as boundary condition\npp0 = DynPoint2VelocityPrior(MvNormal([zeros(2);10*ones(2)], 0.1*eye(4)))\nf0 = addFactor!(fg, [:x0;], pp0)\n\n# conditional likelihood between Dynamic Point2\nv1 = addVariable!(fg, :x1, DynPoint2(ut=1000_000)) # time in microseconds\ndp2dp2 = DynPoint2DynPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))\nf1 = addFactor!(fg, [:x0;:x1], dp2dp2)\n\nensureAllInitialized!(fg)\ntree = wipeBuildNewTree!(fg)\ninferOverTree!(fg, tree)\n\nusing KernelDensityEstimate\n@show x0 = getKDEMax(getVertKDE(fg, :x0))\n# julia> ... = [-0.19441, 0.0187019, 10.0082, 10.0901]\n@show x1 = getKDEMax(getVertKDE(fg, :x1))\n # julia> ... = [19.9072, 19.9765, 10.0418, 10.0797]","category":"page"},{"location":"examples/interm_dynpose/#VelPoint2VelPoint2-(back-differentiation)-1","page":"Creating DynPose Factor","title":"VelPoint2VelPoint2 (back-differentiation)","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"In case the preintegrated approach is not the first choice, we include VelPoint2VelPoint2 <: IncrementalInference.FunctorPairwiseMinimize as a second likelihood factor example which may seem more intuitive:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct VelPoint2VelPoint2{T} <: IncrementalInference.FunctorPairwiseMinimize where {T <: Distribution}\n  z::T\n  VelPoint2VelPoint2{T}() where {T <: Distribution} = new{T}()\n  VelPoint2VelPoint2(z1::T) where {T <: Distribution} = new{T}(z1)\nend\ngetSample(vp2vp2::VelPoint2VelPoint2, N::Int=1) = (rand(vp2vp2.z,N), )\nfunction (vp2vp2::VelPoint2VelPoint2)(\n                res::Array{Float64},\n                userdata,\n                idx::Int,\n                meas::Tuple,\n                Xi::Array{Float64,2},\n                Xj::Array{Float64,2}  )\n  #\n  z = meas[1][:,idx]\n  xi, xj = Xi[:,idx], Xj[:,idx]\n  dt = (userdata.variableuserdata[2].ut - userdata.variableuserdata[1].ut)*1e-6   # roughly the intended use of userdata\n  dp = (xj[1:2]-xi[1:2])\n  dv = (xj[3:4]-xi[3:4])\n  res[1] = 0.0\n  res[1] += sum((z[1:2] - dp).^2)\n  res[1] += sum((z[3:4] - dv).^2)\n  res[1] += sum((dp/dt - xi[3:4]).^2)  # (dp/dt - 0.5*(xj[3:4]+xi[3:4])) # midpoint integration\n  res[1]\nend","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A similar usage example here shows:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"fg = initfg()\n\n# add three point locations\nv0 = addVariable!(fg, :x0, DynPoint2(ut=0))\nv1 = addVariable!(fg, :x1, DynPoint2(ut=1000_000))\nv2 = addVariable!(fg, :x2, DynPoint2(ut=2000_000))\n\n# Prior factor as boundary condition\npp0 = DynPoint2VelocityPrior(MvNormal([zeros(2);10*ones(2)], 0.1*eye(4)))\nf0 = addFactor!(fg, [:x0;], pp0)\n\n# conditional likelihood between Dynamic Point2\ndp2dp2 = VelPoint2VelPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))\nf1 = addFactor!(fg, [:x0;:x1], dp2dp2)\n\n# conditional likelihood between Dynamic Point2\ndp2dp2 = VelPoint2VelPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))\nf2 = addFactor!(fg, [:x1;:x2], dp2dp2)\n\n# Graphs.plot(fg.g)\nensureAllInitialized!(fg)\ntree = wipeBuildNewTree!(fg)\ninferOverTree!(fg, tree)\n\n# see the output\n@show x0 = getKDEMax(getVertKDE(fg, :x0))\n@show x1 = getKDEMax(getVertKDE(fg, :x1))\n@show x2 = getKDEMax(getVertKDE(fg, :x2))","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Producing output:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"x0 = getKDEMax(getVertKDE(fg, :x0)) = [0.101503, -0.0273216, 9.86718, 9.91146]\nx1 = getKDEMax(getVertKDE(fg, :x1)) = [10.0087, 9.95139, 10.0622, 10.0195]\nx2 = getKDEMax(getVertKDE(fg, :x2)) = [19.9381, 19.9791, 10.0056, 9.92442]","category":"page"},{"location":"examples/interm_dynpose/#IncrementalInference.jl-Defining-Factors-(Future-API)-1","page":"Creating DynPose Factor","title":"IncrementalInference.jl Defining Factors (Future API)","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"We would like to remove the idx indexing from the residual function calls, since that is an unnecessary burden on the user.  Instead, the package will use views and SubArray types to simplify the interface.  Please contact author for more details (8 June 2018).","category":"page"},{"location":"examples/interm_dynpose/#Contributions-1","page":"Creating DynPose Factor","title":"Contributions","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Thanks to mc2922 for raising the catalyst issue and conversations that followed from JuliaRobotics/RoME.jl#60.","category":"page"}]
}
