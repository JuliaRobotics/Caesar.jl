var documenterSearchIndex = {"docs":
[{"location":"concepts/mmisam_alg/#Multimodal-incremental-Smoothing-and-Mapping-Algorithm","page":"Multimodal iSAM Algorithm","title":"Multimodal incremental Smoothing and Mapping Algorithm","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"note: Note\nMajor refactoring of documentation under way 2020Q1.  Much of the previous text has be repositioned and being improved.  See references for details and check back here for updates in the coming weeks.","category":"page"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Caesar.jl uses an approximate sum-product inference algorithm (mmiSAM) works.  Until then, see related literature for more details.","category":"page"},{"location":"concepts/mmisam_alg/#Joint-Probability","page":"Multimodal iSAM Algorithm","title":"Joint Probability","text":"","category":"section"},{"location":"concepts/mmisam_alg/#General-Factor-Graph-–-i.e.-non-Gaussian-and-multi-modal","page":"Multimodal iSAM Algorithm","title":"General Factor Graph – i.e. non-Gaussian and multi-modal","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"(Image: mmfgbt)","category":"page"},{"location":"concepts/mmisam_alg/#Inference-on-Bayes/Junction/Elimination-Tree","page":"Multimodal iSAM Algorithm","title":"Inference on Bayes/Junction/Elimination Tree","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"See tree solve video here.","category":"page"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"<a href=\"http://vimeo.com/332507701\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/6412556/52549397-e4505d00-2da0-11e9-958b-e9034c30477c.png\" alt=\"Bayes/Junction tree example\" width=\"640\" border=\"0\" /></a>","category":"page"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Algorithm combats the so called curse-of-dimensionality on the basis of eight principles outlined in the thesis work \"Multimodal and Inertial Sensor Solutions to Navigation-type Factor Graphs\".","category":"page"},{"location":"concepts/mmisam_alg/#Chapman-Kolmogorov-(Belief-Propagation-/-Sum-product)","page":"Multimodal iSAM Algorithm","title":"Chapman-Kolmogorov (Belief Propagation / Sum-product)","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"The main computational effort is to focus compute cycles on dominant modes exhibited by the data, by dropping low likelihood modes (although not indefinitely) and not sacrificing accuracy individual major features. ","category":"page"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"D. Fourie, A. T. Espinoza, M. Kaess, and J. J. Leonard, “Characterizing marginalization and incremental operations on the Bayes tree,” in International Workshop on Algorithmic Foundations of Robotics (WAFR), 2020, submitted, under review.","category":"page"},{"location":"concepts/mmisam_alg/#Focussing-Computation-on-Tree","page":"Multimodal iSAM Algorithm","title":"Focussing Computation on Tree","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Link to new dedicated Bayes tree pages.  The following sections describe different elements of clique recycling.","category":"page"},{"location":"concepts/mmisam_alg/#Incremental-Updates","page":"Multimodal iSAM Algorithm","title":"Incremental Updates","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Recycling computations similar to iSAM2, with option to complete future downward pass.","category":"page"},{"location":"concepts/mmisam_alg/#Fixed-Lag-operation-(out-marginalization)","page":"Multimodal iSAM Algorithm","title":"Fixed-Lag operation (out-marginalization)","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Active user (likely) computational limits on message passing.  Also mixed priority solving","category":"page"},{"location":"concepts/mmisam_alg/#Federated-Tree-Solution-(Multi-session/agent)","page":"Multimodal iSAM Algorithm","title":"Federated Tree Solution (Multi session/agent)","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Tentatively see the multisession page.","category":"page"},{"location":"concepts/mmisam_alg/#Clique-State-Machine","page":"Multimodal iSAM Algorithm","title":"Clique State Machine","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"The CSM is used to govern the inference process within a clique.  A FunctionalStateMachine.jl implementation is used to allow for initialization / incremental-recycling / fixed-lag solving, and will soon support federated branch solving as well as unidirectional message passing for fixed-lead operations.  See the following video for an auto-generated–-using csmAnimate–-concurrent clique solving example.","category":"page"},{"location":"concepts/mmisam_alg/#Sequential-Nested-Gibbs-Method","page":"Multimodal iSAM Algorithm","title":"Sequential Nested Gibbs Method","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Current default inference method.  See [Fourie et al., IROS 2016]","category":"page"},{"location":"concepts/mmisam_alg/#Convolution-Approximation-(Quasi-Deterministic)","page":"Multimodal iSAM Algorithm","title":"Convolution Approximation (Quasi-Deterministic)","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Convolution operations are used to implement the numerical computation of the probabilistic chain rule:","category":"page"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"P(A B) = P(A  B)P(B)","category":"page"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Proposal distributions are computed by means of (analytical or numerical – i.e. \"algebraic\") factor which defines a residual function:","category":"page"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"delta  S times Eta rightarrow mathcalR","category":"page"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"where S times Eta is the domain such that theta_i in S  eta sim P(Eta), and P(cdot) is a probability.","category":"page"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Please follow, a more detailed description is on the convolutional computations page.","category":"page"},{"location":"concepts/mmisam_alg/#Stochastic-Product-Approx-of-Infinite-Functionals","page":"Multimodal iSAM Algorithm","title":"Stochastic Product Approx of Infinite Functionals","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"See mixed-manifold products presented in the literature section.","category":"page"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"writing in progress","category":"page"},{"location":"concepts/mmisam_alg/#Mixture-Parametric-Method","page":"Multimodal iSAM Algorithm","title":"Mixture Parametric Method","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Work In Progress – deferred for progress on full functional methods, but likely to have Gaussian legacy algorithm with mixture model expansion added in the near future.","category":"page"},{"location":"concepts/mmisam_alg/#Full-Deterministic-Chapman-Kolmogorov-Super-Product-Method","page":"Multimodal iSAM Algorithm","title":"Full Deterministic Chapman-Kolmogorov Super Product Method","text":"","category":"section"},{"location":"concepts/mmisam_alg/","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Work in progress, likely to include Kernel Embedding and Homotopy Continuation methods for combining convolution and product operations as a concurrent calculation.","category":"page"},{"location":"examples/deadreckontether/#Dead-Reckon-Tether","page":"Dead Reckon Tether","title":"Dead Reckon Tether","text":"","category":"section"},{"location":"examples/deadreckontether/","page":"Dead Reckon Tether","title":"Dead Reckon Tether","text":"Towards real-rime location prediction and model based target tracking.  See brief description in this presentation.","category":"page"},{"location":"examples/deadreckontether/","page":"Dead Reckon Tether","title":"Dead Reckon Tether","text":"<iframe src=\"https://player.vimeo.com/video/474897929#t=11m24s\" width=\"800\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n<p><a href=\"https://vimeo.com/474897929\">Towards Real-Time Non-Gaussian SLAM</a> from <a href=\"https://vimeo.com/user35117400\">Dehann</a> on <a href=\"https://vimeo.com\">Vimeo</a>.</p>","category":"page"},{"location":"examples/deadreckontether/#Functions-to-Use","page":"Dead Reckon Tether","title":"Functions to Use","text":"","category":"section"},{"location":"examples/deadreckontether/","page":"Dead Reckon Tether","title":"Dead Reckon Tether","text":"See the related functions while this documentation is being expanded:","category":"page"},{"location":"examples/deadreckontether/","page":"Dead Reckon Tether","title":"Dead Reckon Tether","text":"addVariable!(fg, :drt_0, ..., solvable=0)\ndrec1 = MutablePose2Pose2Gaussian(...)\naddFactor!(dfg, [:x0; :drt_0], drec1, solvable=0, graphinit=false)\naccumulateDiscreteLocalFrame!\naccumulateFactorMeans\nduplicateToStandardFactorVariable","category":"page"},{"location":"examples/deadreckontether/","page":"Dead Reckon Tether","title":"Dead Reckon Tether","text":"duplicateToStandardFactorVariable\naccumulateDiscreteLocalFrame!\naccumulateFactorMeans\nMutablePose2Pose2Gaussian","category":"page"},{"location":"examples/deadreckontether/#RoME.duplicateToStandardFactorVariable","page":"Dead Reckon Tether","title":"RoME.duplicateToStandardFactorVariable","text":"duplicateToStandardFactorVariable(, mpp, dfg, prevsym, newsym; solvable, graphinit, cov)\n\n\nHelper function to duplicate values from a special factor variable into standard factor and variable.  Returns the name of the new factor.\n\nNotes:\n\nDeveloped for accumulating odometry in a MutablePosePose and then cloning out a standard PosePose and new variable.\nDoes not change the original MutablePosePose source factor or variable in any way.\nAssumes timestampe from mpp object.\n\nRelated\n\naddVariable!, addFactor!\n\n\n\n\n\n","category":"function"},{"location":"examples/deadreckontether/#RoME.accumulateDiscreteLocalFrame!","page":"Dead Reckon Tether","title":"RoME.accumulateDiscreteLocalFrame!","text":"accumulateDiscreteLocalFrame!(mpp, DX, Qc)\naccumulateDiscreteLocalFrame!(mpp, DX, Qc, dt; Fk, Gk, Phik)\n\n\nAdvance an odometry factor as though integrating an ODE – i.e. X_2 = X_1  ΔX. Accepts continuous domain process noise density Qc which is internally integrated to discrete process noise Qd.  DX is assumed to already be incrementally integrated before this function.  See related accumulateContinuousLocalFrame! for fully continuous system propagation.\n\nNotes\n\nThis update stays in the same reference frame but updates the local vector as though accumulating measurement values over time.\nKalman filter would have used for noise propagation: Pk1 = F*Pk*F + Qdk\nFrom Chirikjian, Vol.II, 2012, p.35: Jacobian SE(2), Jr = [cθ sθ 0; -sθ cθ 0; 0 0 1] – i.e. dSE2/dX' = SE2([0;0;-θ])\nDX = dX/dt*Dt\nassumed process noise for {}^b Qc = {}^b [x;y;yaw] = [fwd; sideways; rotation.rate]\n\nDev Notes\n\nTODO many operations here can be done in-place.\n\nRelated\n\naccumulateContinuousLocalFrame!, accumulateDiscreteReferenceFrame!, accumulateFactorMeans\n\n\n\n\n\n","category":"function"},{"location":"examples/deadreckontether/#IncrementalInference.accumulateFactorMeans","page":"Dead Reckon Tether","title":"IncrementalInference.accumulateFactorMeans","text":"accumulateFactorMeans(dfg, fctsyms)\n\n\nAccumulate chains of binary factors–-potentially starting from a prior–-as a parameteric mean value only.\n\nNotes\n\nNot used during tree inference.\nExpected uses are for user analysis of factors and estimates.\nreal-time dead reckoning chain prediction.\n\nDevNotes\n\nTODO consolidate with similar approxConvChain\n\nRelated:\n\napproxConv, solveBinaryFactorParameteric, RoME.MutablePose2Pose2Gaussian\n\n\n\n\n\n","category":"function"},{"location":"examples/deadreckontether/#RoME.MutablePose2Pose2Gaussian","page":"Dead Reckon Tether","title":"RoME.MutablePose2Pose2Gaussian","text":"mutable struct MutablePose2Pose2Gaussian <: AbstractRelativeRoots\n\nSpecialized Pose2Pose2 factor type (Gaussian), which allows for rapid accumulation of odometry information as a branch on the factor graph.\n\n\n\n\n\n","category":"type"},{"location":"dev/known_issues/#Known-Issues","page":"Known Issue List","title":"Known Issues","text":"","category":"section"},{"location":"dev/known_issues/","page":"Known Issue List","title":"Known Issue List","text":"This page is used to list known issues:","category":"page"},{"location":"dev/known_issues/","page":"Known Issue List","title":"Known Issue List","text":"Arena.jl is fairly behind on a number of updates and deprecations.  Fixes for this are planned 2021Q2.\nRoMEPlotting.jl main features like plotSLAM2D are working, but some of the other features are not fully up to date with recent changes in upstream packages.  This too will be updated around Summer 2021.","category":"page"},{"location":"concepts/2d_plotting/#Plotting","page":"Plotting (2D)","title":"Plotting","text":"","category":"section"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"Once the graph has been built, 2D plot visualizations are provided by RoMEPlotting.jl and KernelDensityEstimatePlotting.jl.  These visualizations tools are readily modifiable to highlight various aspects of mobile platform navigation.","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"note: Note\nPlotting packages can be installed separately.","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"The major 2D plotting functions between RoMEPlotting.jl and KernelDensityEstimatePlotting.jl:","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plotSLAM2D,\nplotSLAM2DPoses,\nplotSLAM2DLandmarks,\nplotPose,\nplotKDE / plot,\nplotLocalProduct,\nPDF, PNG, SVG,\nhstack, vstack.","category":"page"},{"location":"concepts/2d_plotting/#Example-Plot-SLAM-2D","page":"Plotting (2D)","title":"Example Plot SLAM 2D","text":"","category":"section"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"This simplest example for visualizing a 2D robot trajectory–-such as first running the Hexagonal 2D SLAM example–-","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"Assuming some fg<:AbstractDFG has been loaded/constructed:","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"# load the plotting functionality\nusing RoME, RoMEPlotting\n\n# generate some factor graph with numerical values\nfg = generateCanonicalFG_Hexagonal()\nsolveTree!(fg)\n\n# or fg = loadDFG(\"somepath\")\n\n# slam2D plot\npl = plotSLAM2D(fg, drawhist=true, drawPoints=false)","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/69353457-6cd82400-0c76-11ea-905c-8f435faa6b11.png\" width=\"800\" border=\"0\" />\n</p>","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plotSLAM2D","category":"page"},{"location":"concepts/2d_plotting/#RoMEPlotting.plotSLAM2D","page":"Plotting (2D)","title":"RoMEPlotting.plotSLAM2D","text":"plotSLAM2D(fgl; solveKey, from, to, minnei, meanmax, posesPPE, landmsPPE, lbls, drawTriads, spscale, dyadScale, levels, drawhist, MM, xmin, xmax, ymin, ymax, showmm, window, point_size, line_width, regexLandmark, regexPoses, manualColor, drawPoints, pointsColor, drawContour, drawEllipse, ellipseColor, contour, title)\n\n\n2D plot of both poses and landmarks contained in factor graph.  Assuming poses and landmarks  are labeled :x1, :x2, ... and :l0, :l1, ..., respectively.  The range of numbers to  include can be controlled with from and to along with other keyword functionality for  manipulating the plot.\n\nNotes\n\nAssumes :l1, :l2, ... for landmarks – \nCan increase default Gadfly plot size (for JSSVG in browser): Gadfly.set_default_plot_size(35cm,20cm).\nEnable or disable features such as the covariance ellipse with keyword drawEllipse=true.\n\nDevNotes\n\nTODO update to use e.g. tags=[:LANDMARK],\nTODO fix drawHist,\nTODO deprecate, showmm, spscale.\n\nExamples:\n\nfg = generateCanonicalFG_Hexagonal()\nplotSLAM2D(fg)\nplotSLAM2D(fg, drawPoints=false)\nplotSLAM2D(fg, contour=false, drawEllipse=true)\nplotSLAM2D(fg, contour=false, title=\"SLAM result 1\")\n\n# or load a factor graph\nfg_ = loadDFG(\"somewhere.tar.gz\")\nplotSLAM2D(fg_)\n\nRelated\n\nplotSLAM2DPoses, plotSLAM2DLandmarks, plotPose, plotKDE \n\n\n\n\n\n","category":"function"},{"location":"concepts/2d_plotting/#Plot-Covariance-Ellipse-and-Points","page":"Plotting (2D)","title":"Plot Covariance Ellipse and Points","text":"","category":"section"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"While the Caesar.jl framework is focussed on non-Gaussian inference, it is frequently desirable to relate the results to a more familiar covariance ellipse, and native support for this exists:","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plotSLAM2D(fg, contour=false, drawEllipse=true, drawPoints=true)","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/98863019-c4e2da00-2435-11eb-8e50-4a34cc8de2d7.png\" width=\"800\" border=\"0\" />\n</p>","category":"page"},{"location":"concepts/2d_plotting/#Plot-Poses-or-Landmarks","page":"Plotting (2D)","title":"Plot Poses or Landmarks","text":"","category":"section"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"Lower down utility functions are used to plot poses and landmarks separately before joining the Gadfly layers.","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plotSLAM2DPoses\nplotSLAM2DLandmarks","category":"page"},{"location":"concepts/2d_plotting/#RoMEPlotting.plotSLAM2DPoses","page":"Plotting (2D)","title":"RoMEPlotting.plotSLAM2DPoses","text":"plotSLAM2DPoses(fg; solveKey, regexPoses, from, to, variableList, meanmax, ppe, lbls, drawhist, spscale, dyadScale, drawTriads, drawContour, levels, contour, line_width, drawPoints, pointsColor, drawEllipse, ellipseColor, manualColor)\n\n\n2D plot of all poses, assuming poses are labeled from `::Symbol type :x0, :x1, ..., :xn.  Use to and from to limit the range of numbers n to be drawn.  The underlying histogram can be enabled or disabled, and the size of maximum-point belief estimate cursors can be controlled with spscale.\n\nFuture:\n\nRelax to user defined pose labeling scheme, for example :p1, :p2, ...\n\n\n\n\n\n","category":"function"},{"location":"concepts/2d_plotting/#RoMEPlotting.plotSLAM2DLandmarks","page":"Plotting (2D)","title":"RoMEPlotting.plotSLAM2DLandmarks","text":"plotSLAM2DLandmarks(fg; solveKey, regexLandmark, from, to, minnei, variableList, meanmax, ppe, lbls, showmm, drawhist, drawContour, levels, contour, manualColor, c, MM, point_size, drawPoints, pointsColor, drawEllipse, ellipseColor, resampleGaussianFit)\n\n\n2D plot of landmarks, assuming :l1, :l2, ... :ln.  Use from and to to control the range of landmarks n to include.\n\n\n\n\n\n","category":"function"},{"location":"concepts/2d_plotting/#Plot-Belief-Density-Contour","page":"Plotting (2D)","title":"Plot Belief Density Contour","text":"","category":"section"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"KernelDensityEstimatePlotting (as used in RoMEPlotting) provides an interface to visualize belief densities as counter plots.  Something basic might be to just show all plane pairs of this variable marginal belief:","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"# Draw the KDE for x0\nplotKDE(fg, :x0)","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"Plotting the marginal density over say variables (x,y) in a Pose2 would be:","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plotKDE(fg, :x1, dims=[1;2])","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"The following example better shows some of features (via Gadfly.jl):","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"# Draw the (x,y) marginal estimated belief contour for :x0, :x2, and Lx4\npl = plotKDE(fg, [:x0; :x2; :x4], c=[\"red\";\"green\";\"blue\"], levels=2, dims=[1;2])\n\n# add a few fun layers\npl3 = plotSLAM2DPoses(fg, regexPoses=r\"x\\d\", from=3, to=3, contour=false, drawEllipse=true)\npl5 = plotSLAM2DPoses(fg, regexPoses=r\"x\\d\", from=5, to=5, contour=false, drawEllipse=true, drawPoints=false)\npl_ = plotSLAM2DPoses(fg, contour=false, drawPoints=false, dyadScale=0.001, to=5)\nunion!(pl.layers, pl3.layers)\nunion!(pl.layers, pl5.layers)\nunion!(pl.layers, pl_.layers)\n\n# change the plotting coordinates\npl.coord = Coord.Cartesian(xmin=-10,xmax=20, ymin=-1, ymax=25)\n\n# save the plot to SVG and giving dedicated (although optional) sizing\npl |> SVG(\"/tmp/test.svg\", 25cm, 15cm)\n\n# also display the plot live\npl","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/98865698-c910f680-2439-11eb-8adf-e50ec37eacc2.png\" width=\"800\" border=\"0\" />\n</p>","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"See function documentation for more details on API features","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plotKDE","category":"page"},{"location":"concepts/2d_plotting/#KernelDensityEstimatePlotting.plotKDE","page":"Plotting (2D)","title":"KernelDensityEstimatePlotting.plotKDE","text":"plotKDE(fgl, sym; solveKey, dims, title, levels, fill, layers, c, overlay)\n\n\nA peneric KDE plotting function that allows marginals of higher dimensional beliefs and various keyword options.\n\nExample:\n\np = kde!(randn(3,100))\n\nplotKDE(p)\nplotKDE(p, dims=[1;2], levels=3)\nplotKDE(p, dims=[1])\n\nq = kde!(5*randn(3,100))\nplotKDE([p;q])\nplotKDE([p;q], dims=[1;2], levels=3)\nplotKDE([p;q], dims=[1])\n\n\n\n\n\n","category":"function"},{"location":"concepts/2d_plotting/#Save-Plot-to-Image","page":"Plotting (2D)","title":"Save Plot to Image","text":"","category":"section"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"VSCode/Juno can set plot to be opened in a browser tab instead.  For scripting use-cases you can also export the image:","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"using Gadfly\n# can change the default plot size\n# Gadfly.set_default_plot_size(35cm, 30cm)\n\npl |> PDF(\"/tmp/test.pdf\", 20cm, 10cm)  # or PNG, SVG","category":"page"},{"location":"concepts/2d_plotting/#Save-Plot-Object-To-File","page":"Plotting (2D)","title":"Save Plot Object To File","text":"","category":"section"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"It is also possible to store the whole plot container to file using JLD2.jl:","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"JLD2.@save \"/tmp/myplot.jld2\" pl\n\n# and loading elsewhere\nJLD2.@load \"/tmp/myplot.jld2\" pl","category":"page"},{"location":"concepts/2d_plotting/#Interactive-Plots,-Zoom,-Pan-(Gadfly.jl)","page":"Plotting (2D)","title":"Interactive Plots, Zoom, Pan (Gadfly.jl)","text":"","category":"section"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"See the following two discussions on Interactive 2D plots:","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"Interactivity\nInteractive-SVGs","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"note: Note\nRed and Green dyad lines represent the visualization-only assumption of X-forward and Y-left direction of Pose2.  The inference and manifold libraries surrounding Caesar.jl are agnostic to any particular choice of reference frame alignment, such as north east down (NED) or forward left up (common in mobile robotics).","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"note: Note\nAlso see Gadfly.jl notes about hstack and vstack to combine plots side by side or vertically.","category":"page"},{"location":"concepts/2d_plotting/#Plot-Pose-Individually","page":"Plotting (2D)","title":"Plot Pose Individually","text":"","category":"section"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"It is also possible to plot the belief density of a Pose2 on-manifold:","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plotPose(fg, :x6)","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/98864183-7f271100-2437-11eb-8422-8ed49c1186b9.png\" width=\"800\" border=\"0\" />\n</p>","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plotPose","category":"page"},{"location":"concepts/2d_plotting/#RoMEPlotting.plotPose","page":"Plotting (2D)","title":"RoMEPlotting.plotPose","text":"plotPose(pt, pp)\nplotPose(pt, pp, title; levels, c, legend, axis, scale, overlay, hdl)\n\n\nPlot pose belief as contour information on visually sensible manifolds.\n\nExample:\n\nfg = generateCanonicalFG_Hexagonal()\nsolveTree!(fg);\nplotPose(fg, :x6)\n\nRelated\n\nplotSLAM2D, plotSLAM2DPoses, plotKDE, plotKDECircular\n\n\n\n\n\nplotPose(fgl, syms; solveKey, levels, c, axis, scale, show, filepath, app, hdl)\n\n\nExample: pl = plotPose(fg, [:x1; :x2; :x3])\n\n\n\n\n\n","category":"function"},{"location":"concepts/2d_plotting/#Debug-With-Local-Graph-Product-Plot","page":"Plotting (2D)","title":"Debug With Local Graph Product Plot","text":"","category":"section"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"One useful function is to check that data in the factor graph makes sense.  While the full inference algorithm uses a Bayes (Junction) tree to assemble marginal belief estimates in an efficient manner, it is often useful for a straight forward graph based sanity check.  The plotLocalProduct projects through approxConv each of the factors connected to the target variable and plots the result.  This example looks at the loop-closure point around :x0, which is also pinned down by the only prior in the canonical Hexagonal factor graph.","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"@show ls(fg, :x0);\n# ls(fg, :x0) = [:x0f1, :x0x1f1, :x0l1f1]\n\npl = plotLocalProduct(fg, :x0, dims=[1;2], levels=1)","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/98868152-b00a4480-243d-11eb-83fe-8630d64355ee.png\" width=\"800\" border=\"0\" />\n</p>","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"While perhaps a little cluttered to read at first, this figure shows that a new calculation local to only the factor graph prod in greem matches well with the existing value curr in red in the fg from the earlier solveTree! call.  These values are close to the prior prediction :x0f1 in blue (fairly trivial case), while the odometry :x0x1f1 and landmark sighting projection :x0l1f1 are also well in agreement.","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plotLocalProduct","category":"page"},{"location":"concepts/2d_plotting/#RoMEPlotting.plotLocalProduct","page":"Plotting (2D)","title":"RoMEPlotting.plotLocalProduct","text":"plotLocalProduct(fgl, lbl; solveKey, N, dims, levels, show, dirpath, mimetype, sidelength, title)\n\n\nPlot the proposal belief from neighboring factors to lbl in the factor graph (ignoring Bayes tree representation), and show with new product approximation for reference.\n\nDevNotes\n\nTODO, standardize around ::MIME=\"image/svg\", see JuliaRobotics/DistributedFactorGraphs.jl#640\n\n\n\n\n\nplotLocalProduct(fgl, lbl; N, dims)\n\n\nPlot the proposal belief from neighboring factors to lbl in the factor graph (ignoring Bayes tree representation), and show with new product approximation for reference. String version is obsolete and will be deprecated.\n\n\n\n\n\n","category":"function"},{"location":"concepts/2d_plotting/#More-Detail-About-Density-Plotting","page":"Plotting (2D)","title":"More Detail About Density Plotting","text":"","category":"section"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"Multiple beliefs can be plotted at the same time, while setting levels=4 rather than the default value:","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plX1 = plotKDE(fg, [:x0; :x1], dims=[1;2], levels=4)\n\n# plX1 |> PNG(\"/tmp/testX1.png\")","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/42532963-656cef56-8456-11e8-9636-42592c0d148c.png\" width=\"800\" border=\"0\" />\n</p>","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"One dimensional (such as Θ) or a stack of all plane projections is also available:","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plTh = plotKDE(fg, [:x0; :x1], dims=[3], levels=4)\n\n# plTh |> PNG(\"/tmp/testTh.png\")","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/42533188-2dee90c4-8457-11e8-9844-0ef57fba1c82.png\" width=\"800\" border=\"0\" />\n</p>","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"plAll = plotKDE(fg, [:x0; :x1], levels=3)\n# plAll |> PNG(\"/tmp/testX1.png\",20cm,15cm)","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/42533225-42ddaf9c-8457-11e8-8b0d-b1f3695d8b00.png\" width=\"800\" border=\"0\" />\n</p>","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"note: Note\nThe functions hstack and vstack is provided through the Gadfly package and allows the user to build a near arbitrary composition of plots.","category":"page"},{"location":"concepts/2d_plotting/","page":"Plotting (2D)","title":"Plotting (2D)","text":"Please see KernelDensityEstimatePlotting package source for more features.","category":"page"},{"location":"examples/adding_variables_factors/#Creating-New-Variables-and-Factors","page":"Custom Variables and Factors","title":"Creating New Variables and Factors","text":"","category":"section"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"In most scenarios, the existing variables and factors should be sufficient for most robotics applications. Caesar however, is extensible and allows you to easily incorporate your own variable and factor types for specialized applications.","category":"page"},{"location":"examples/adding_variables_factors/#New-Variable/Factor-Considerations","page":"Custom Variables and Factors","title":"New Variable/Factor Considerations","text":"","category":"section"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"A couple of important points:","category":"page"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You do not need to modify/fork/edit internal Caesar/RoME/IncrementalInference source code to introduce new variable and factor types!\nAs long as the factors exist in the working space when the solver is run, the factors are automatically used – this is possible due to Julia's multiple dispatch design\nCaesar is designed to allow you to add new variables and factors to your own independent repository and incorporate them at will at compile-time or even run-time\nResidual function definitions for new factors types use a callable struct (a.k.a functor) architecture to simultaneously allow:  \nMultiple dispatch (i.e. 'polymorphic' behavior)\nMeta-data and in-place memory storage for advanced and performant code\nAn outside callback implementation style\nIn most robotics scenarios, there is no need for new variables or factors:\nVariables have various mechanisms that allow you to attach data to them, e.g. raw sensory data or identified April tags, so you do not need to create a new variable type just to store data\nNew variables are required only if you are representing a new state - TODO: Example of needed state\nNew factors are needed if:\nYou need to represent a constraint for a variable (known as a singleton) and that constraint type doesn't exist\nYou need to represent a constraint between two variables and that constraint type doesn't exist","category":"page"},{"location":"examples/adding_variables_factors/#Getting-Started","page":"Custom Variables and Factors","title":"Getting Started","text":"","category":"section"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"We suggest the following design pattern for developing and building new factors:","category":"page"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You have reviewed the variable and factor types available in Caesar, RoME, and IncrementalInference and a new type is required - please see Building and Solving Graphs if you want to review what is currently available\n[OPTIONAL] Create a GitHub repository to store the new types (new types in the Julia Main scope is perfectly okay!)\nCreate your new variable types\nCreate your new factor types\nImplement unit tests to validate the correct operation of the types\nSet up your solver to make use the custom types","category":"page"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"1.1. This is much easier than it sounds","category":"page"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"If the code is public and may be useful to the community, we ask if you could submit an issue against Caesar with information about the new types and the repository. Ideally we'd like to continually improve the core code and fold in community contributions.","category":"page"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"The remainder of this section discusses each of these steps.","category":"page"},{"location":"examples/adding_variables_factors/#[OPTIONAL]-Creating-a-Repository","page":"Custom Variables and Factors","title":"[OPTIONAL] Creating a Repository","text":"","category":"section"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You can fork the following template repository to construct your own Caesar Variable and Factor Examples.","category":"page"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"If this repository is going to be used for development of the new variables/factors as well as for the experiment (i.e. the code that builds the graph and solves it), you should probably start a simple end-to-end test that validates a basic version of your experimental setup (e.g. ):","category":"page"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"#### This example is a basic test of the new variables and factors\n#### that are added in this repo. The example is derived from\n#### the hexagonal test example.\n\nusing Caesar, RoME\nusing Caesar_VariableFactorExamples # Your new variable/factor repository\n# Using plotting for experiment validation\nusing RoMEPlotting\n\n# 1. Init factor graph\n#TODO\n\n# 2. Add variables\n#TODO\n\n# 3. Add factors\n# 3a. Add a new test prior\n#TODO\n# 3b. Add new types of odometry factors.\n#TODO\n\n# 4. Solve graph\nsolveTree!(fg)\n\n# 5. Graph solution - assuming that you have this open in Atom.\nplotSLAM2DPoses(fg)","category":"page"},{"location":"examples/adding_variables_factors/#Unit-Tests","page":"Custom Variables and Factors","title":"Unit Tests","text":"","category":"section"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"What you should test:","category":"page"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"Creation of the factor\nSampling of the factor\nResidual testing\nSolving using the variables and factors\nSerialization and deserialization","category":"page"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"An example of these tests can be seen for the trivial case shown in the example repo ExamplePrior Unit Tests.","category":"page"},{"location":"examples/adding_variables_factors/#Using-your-Types-with-the-Caesar-Solver","page":"Custom Variables and Factors","title":"Using your Types with the Caesar Solver","text":"","category":"section"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"As above, as long as you bring your factors into the workspace, you should be able to use them in your experimental setup.","category":"page"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You can validate this with the existence check code in Building and Solving Graphs.","category":"page"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"note: Note\nThis has been made available as IncrementalInference.getCurrentWorkspaceVariables() and IncrementalInference.getCurrentWorkspaceFactors().","category":"page"},{"location":"examples/adding_variables_factors/#Contributing-back-to-the-Community","page":"Custom Variables and Factors","title":"Contributing back to the Community","text":"","category":"section"},{"location":"examples/adding_variables_factors/","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"Consider contributioning back, so if you have developed variables and factors that may be useful to the community, please write up an issue in Caesar.jl or submit a PR to the relavent repo.  Note also that work is ongoing to simplify and consolidate the code structure given all previously known feature requests and requirements.","category":"page"},{"location":"examples/basic_slamedonut/#Range-only-SLAM,-Singular-–-i.e.-\"Under-Constrained\"","page":"Under-defined Trilateration, 2D","title":"Range only SLAM, Singular – i.e. \"Under-Constrained\"","text":"","category":"section"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Keywords: underdetermined, under-constrained, range-only, singular","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"This tutorial describes a range-only system where there are always more variable dimensions than range measurements made. The error distribution over ranges could be nearly anything, but are restricted to Gaussian-only in this example to illustrate an alternative point – other examples show inference results where highly non-Gaussian error distributions are used.","category":"page"},{"location":"examples/basic_slamedonut/#Presentation-Style-Discussion","page":"Under-defined Trilateration, 2D","title":"Presentation Style Discussion","text":"","category":"section"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"A presentation discussion of this example is available here:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"<iframe src=\"https://player.vimeo.com/video/474897929#t=4m42s\" width=\"800\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n<p><a href=\"https://vimeo.com/474897929\">Towards Real-Time Non-Gaussian SLAM</a> from <a href=\"https://vimeo.com/user35117400\">Dehann</a> on <a href=\"https://vimeo.com\">Vimeo</a>.</p>","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"A script to recreate this example is provided in RoME/examples here. This singular range-only illustration:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"<iframe src=\"https://player.vimeo.com/video/190052649\" width=\"800\" frameborder=\"0\" allow=\"autoplay; fullscreen\" allowfullscreen></iframe>\n<p><a href=\"https://vimeo.com/190052649\">Multi-modal iSAM range and distance only example</a> from <a href=\"https://vimeo.com/user35117400\">Dehann</a> on <a href=\"https://vimeo.com\">Vimeo</a>.</p>","category":"page"},{"location":"examples/basic_slamedonut/#Quick-Install","page":"Under-defined Trilateration, 2D","title":"Quick Install","text":"","category":"section"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"If you already have Julia 1.0 or above, alternatively see complete installation instructions here:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"julia> ]\n(v1.0) pkg> add RoME, Distributed\n(v1.0) pkg> add RoMEPlotting","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The Julia REPL/console is sufficient for this example (copy-paste from this page).  Note that more involved work in Julia is simplified by using the Juno IDE.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Note A recent test (May 2019, IIF v0.6.0) showed a possible bug was introduced with one of the solver upgrades.  THe figures shown on this example page are still, however, valid.  Previous versions of the solver, such as IncrementalInference v0.4.x and v0.5.x, should still work as expected.  Follow progress on issue 335 here as bug is being resolved.  Previous versions of the solver can be installed with the package manager, for example: (v1.0) pkg> add IncrementalInference@v0.5.7.  Please comment for further details.","category":"page"},{"location":"examples/basic_slamedonut/#Loading-The-Data","page":"Under-defined Trilateration, 2D","title":"Loading The Data","text":"","category":"section"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Starting a Juno IDE or Julia REPL session, the ground truth positions for vehicle positions GTp and landmark positions GTl can be loaded into memory directly with these values:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"GTp = Dict{Symbol, Vector{Float64}}()\nGTp[:l100] = [0.0;0]\nGTp[:l101] = [50.0;0]\nGTp[:l102] = [100.0;0]\nGTp[:l103] = [100.0;50.0]\nGTp[:l104] = [100.0;100.0]\nGTp[:l105] = [50.0;100.0]\nGTp[:l106] = [0.0;100.0]\nGTp[:l107] = [0.0;50.0]\nGTp[:l108] = [0.0;-50.0]\nGTp[:l109] = [0.0;-100.0]\nGTp[:l110] = [50.0;-100.0]\nGTp[:l111] = [100.0;-100.0]\nGTp[:l112] = [100.0;-50.0]\n\nGTl = Dict{Symbol, Vector{Float64}}()\nGTl[:l1] = [10.0;30]\nGTl[:l2] = [30.0;-30]\nGTl[:l3] = [80.0;40]\nGTl[:l4] = [120.0;-50]","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"NOTE 1. that by using location indicators :l1, :l2, ... or :l100, :l101, ... is of practical benefit when visualizing with existing RoMEPlotting functions.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"NOTE 2. Landmarks must be in range before range measurements can be made to them.","category":"page"},{"location":"examples/basic_slamedonut/#Creating-the-Factor-Graph-with-Point2","page":"Under-defined Trilateration, 2D","title":"Creating the Factor Graph with Point2","text":"","category":"section"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The first step is to load the required modules, and in our case we will add a few Julia processes to help with the compute later on.  ","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"# add more julia processes\nusing Distributed\nnprocs() < 4 ? addprocs(4-nprocs()) : nothing\n\n# tell Julia that you want to use these modules/namespaces\nusing RoME","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"NOTE Julia uses just-in-time compiling (unless pre-compiled), therefore each time a new function call on a Julia process will be slow, but all following calls to the same functions will be as fast as the statically compiled code.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"This example exclusively uses Point2 variable node types, which have dimension 2 and represent [x, y] position estimates in the world frame.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Next construct the factor graph containing the first pose :l100 (without any knowledge of where it is) and three measured beacons/landmarks :l1,:l2,:l3 – with prior location knowledge for :l1 and :l2:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"# create the factor graph object\nfg = initfg()\n\n# first pose with no initial estimate\naddVariable!(fg, :l100, Point2)\n\n# add three landmarks\naddVariable!(fg, :l1, Point2)\naddVariable!(fg, :l2, Point2)\naddVariable!(fg, :l3, Point2)\n\n# and put priors on :l101 and :l102\naddFactor!(fg, [:l1;], PriorPoint2(MvNormal(GTl[:l1], diagm(ones(2)))) )\naddFactor!(fg, [:l2;], PriorPoint2(MvNormal(GTl[:l2], diagm(ones(2)))) )","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The PriorPoint2 is assumed to be a multivariate normal distribution of covariance diagm(ones(2)). Note the API PriorPoint2(::T) where T <: SamplableBelief = PriorPoint2{T} to accept distribution objects, discussed further in subsection Various SamplableBelief Distribution Types.","category":"page"},{"location":"examples/basic_slamedonut/#Adding-Range-Measurements-Between-Variables","page":"Under-defined Trilateration, 2D","title":"Adding Range Measurements Between Variables","text":"","category":"section"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Next we connect the three range measurements from the vehicle location :l0 to the three beacons, respectively – and consider that the range measurements are completely relative between the vehicle and beacon position estimates:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"# first range measurement\nrhoZ1 = norm(GTl[:l1]-GTp[:l100])\nppr = Point2Point2Range( Normal(rhoZ1, 2) )\naddFactor!(fg, [:l100;:l1], ppr)\n\n# second range measurement\nrhoZ2 = norm(GTl[:l2]-GTp[:l100])\nppr = Point2Point2Range( Normal(rhoZ2, 3.0) )\naddFactor!(fg, [:l100; :l2], ppr)\n\n# second range measurement\nrhoZ3 = norm(GTl[:l3]-GTp[:l100])\nppr = Point2Point2Range( Normal(rhoZ3, 3.0) )\naddFactor!(fg, [:l100; :l3], ppr)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The ranging measurement standard deviation of 2.0 or 3.0 is taken, assuming a Gaussian measurement assumption.   Again, any distribution could have been used. The factor graph should look as follows:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"drawGraph(fg) # show the factor graph","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: rangesonlyfirstfg)","category":"page"},{"location":"examples/basic_slamedonut/#Inference-and-Visualizations","page":"Under-defined Trilateration, 2D","title":"Inference and Visualizations","text":"","category":"section"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"At this point we can call the solver start interpreting the first results:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"tree, smt, hist = solveTree!(fg)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The factor graph figure above showed the structure between variables and factors. In order to see the numerical values contained in the factor graph, a set of tools are provided by the RoMEPlotting and KernelDensityEstimatePlotting packages. For more details, please see the dedicated visualization discussion here.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"First look at the two landmark positions :l1, :l2 at (10.0,30),(30.0,-30) respectively.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"using RoMEPlotting\n\nplotKDE(fg, [:l1;:l2], dims=[1;2])","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl1_2)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Similarly, the belief estimate for the first vehicle position :l100 is bi-modal, due to the intersection of two range measurements:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"plotKDE(fg, :l100, dims=[1;2], levels=6)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl100)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"An alternative plotting interface can also be used, that shows a histogram of desired elements instead:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"drawLandms(fg, from=1, to=101, contour=false, drawhist=true)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testlall)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Notice the ring of particles which represents the belief on the third beacon/landmark :l3, which was not constrained by a prior factor. Instead, the belief over the position of :l3 is being estimated simultaneous to estimating the vehicle position :l100.","category":"page"},{"location":"examples/basic_slamedonut/#Implicit-Growth-and-Decay-of-Modes-(i.e.-Hypotheses)","page":"Under-defined Trilateration, 2D","title":"Implicit Growth and Decay of Modes (i.e. Hypotheses)","text":"","category":"section"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Next consider the vehicle moving a distance of 50 units–-and by design the direction of travel is not known–-to the next true position. The video above gives away the vehicle position with the cyan line, showing travel in the shape of a lower case 'e'. The following function handles (pseudo odometry) factors as range-only between positions and range-only measurement factors to beacons as the vehice travels.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"function vehicle_drives_to!(fgl::G, pos_sym::Symbol, GTp::Dict, GTl::Dict; measurelimit::R=150.0) where {G <: AbstractDFG, R <: Real}\n  currvar = union(ls(fgl)...)\n  prev_sym = Symbol(\"l$(maximum(Int[parse(Int,string(currvar[i])[2:end]) for i in 2:length(currvar)]))\")\n  if !(pos_sym in currvar)\n    println(\"Adding variable vertex $pos_sym, not yet in fgl<:AbstractDFG.\")\n    addVariable!(fgl, pos_sym, Point2)\n    @show rho = norm(GTp[prev_sym] - GTp[pos_sym])\n    ppr = Point2Point2Range( Normal(rho, 3.0) )\n    addFactor!(fgl, [prev_sym;pos_sym], ppr)\n  else\n    @warn \"Variable node $pos_sym already in the factor graph.\"\n  end\n  beacons = keys(GTl)\n  for ll in beacons\n    rho = norm(GTl[ll] - GTp[pos_sym])\n    # Check for feasible measurements:  vehicle within 150 units from the beacons/landmarks\n    if rho < measurelimit\n      ppr = Point2Point2Range( Normal(rho, 3.0) )\n      if !(ll in currvar)\n        println(\"Adding variable vertex $ll, not yet in fgl<:AbstractDFG.\")\n        addVariable!(fgl, ll, Point2)\n      end\n      addFactor!(fgl, [pos_sym;ll], ppr)\n    end\n  end\n  nothing\nend","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"After pasting (or running) this function in Julia, a new member definition vehicle_drives_to! can be used line any other function.  Julia will handle the just-in-time compiling for the type specific function required and cach the static code for repeat executions.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"NOTE The exclamation mark at the end of the function name has no syntactic significance in Julia, since the full UTF8 character set is available for functions or variables.  Instead, the exclamation serves as a Julia community convention to tell the caller that this function will modify the contents of at least some of the variables being passed into it – in this case the factor graph fg will be modified.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Now the actual driving event can be added to the factor graph:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"#drive to location :l101, then :l102\nvehicle_drives_to!(fg, :l101, GTp, GTl)\nvehicle_drives_to!(fg, :l102, GTp, GTl)\n\n# see the graph\ndrawGraph(fg, engine=\"neato\")","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"NOTE The distance traveled could be any combination of accrued direction and speeds, however, a straight line Gaussian error model is used to keep the visual presentation of this example as simple as possible.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The marginal posterior estimates are found by repeating inference over the factor graph, followed drawing all vehicle locations as a contour map:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"# solve and show message passing on Bayes (Junction) tree\ngetSolverParams(fg).drawtree=true\ngetSolverParams(fg).showtree=true\ntree, smt, hist = solveTree!(fg)\n\n# draw all vehicle locations\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 0:2], dims=[1;2])\n# Gadfly.draw(PDF(\"/tmp/testL100_102.pdf\", 20cm, 10cm),pl) # for storing image to disk\n\npl = plotKDE(fg, [:l3;:l4], dims=[1;2], levels=4)\n# Gadfly.draw(PNG(\"/tmp/testL3_4.png\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Notice how the vehicle positions have two hypotheses, one left to right and one diagonal right to bottom left – both are valid solutions!","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl100_102)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"The two \"free\" beacons/landmarks :l3,:l4 still have several modes each, implying insufficient data to constrain either to a strong unimodal belief.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl3_4)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"\nvehicle_drives_to!(fg, :l103, GTp, GTl)\nvehicle_drives_to!(fg, :l104, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 0:4], dims=[1;2])\n# Gadfly.draw(PDF(\"/tmp/testL100_104.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Moving up to position :l104 still shows strong multiodality in the vehicle position estimates:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl100_105)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"vehicle_drives_to!(fg, :l105, GTp, GTl)\nvehicle_drives_to!(fg, :l106, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\n\nvehicle_drives_to!(fg, :l107, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\n\nvehicle_drives_to!(fg, :l108, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\n\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 2:8], dims=[1;2], levels=6)\n# Gadfly.draw(PDF(\"/tmp/testL103_108.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Next we see a strong return to a single dominant mode in all vehicle position estimates, owing to the increased measurements to beacons/landmarks as well as more unimodal estimates in :l3, :l4 beacon/landmark positions.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"vehicle_drives_to!(fg, :l109, GTp, GTl)\nvehicle_drives_to!(fg, :l110, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\n\nvehicle_drives_to!(fg, :l111, GTp, GTl)\nvehicle_drives_to!(fg, :l112, GTp, GTl)\n\ntree, smt, hist = solveTree!(fg)\n\n\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 7:12], dims=[1;2])\n# Gadfly.draw(PDF(\"/tmp/testL106_112.pdf\", 20cm, 10cm),pl)\n\npl = plotKDE(fg, [:l1;:l2;:l3;:l4], dims=[1;2], levels=4)\n# Gadfly.draw(PDF(\"/tmp/testL1234.pdf\", 20cm, 10cm),pl)\n\npl = drawLandms(fg, from=100)\n# Gadfly.draw(PDF(\"/tmp/testLocsAll.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Several location belief estimates exhibit multimodality as the trajectory progresses (not shown), but collapses and finally collapses to a stable set of dominant position estimates.","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl106_112)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"Landmark estimates are also stable at one estimate:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testl1234)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"In addition, the SLAM 2D landmark visualization can be re-used to plot more information at once:","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"# pl = drawLandms(fg, from=100, to=200)\n# Gadfly.draw(PDF(\"/tmp/testLocsAll.pdf\", 20cm, 10cm),pl)\n\npl = drawLandms(fg)\n# Gadfly.draw(PDF(\"/tmp/testAll.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"(Image: testall)","category":"page"},{"location":"examples/basic_slamedonut/","page":"Under-defined Trilateration, 2D","title":"Under-defined Trilateration, 2D","text":"This example used the default of N=200 particles per marginal belief. By increasing the number to N=300 throughout the test many more modes and interesting features can be explored, and we refer the reader to an alternative and longer discussion on the same example, in Chapter 6 here.","category":"page"},{"location":"principles/bayestreePrinciples/#Principle:-Bayes-tree-prototyping","page":"Bayes (Junction) tree","title":"Principle: Bayes tree prototyping","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"This page describes how to visualize, study, test, and compare Bayes (Junction) tree concepts with special regard for variable ordering.","category":"page"},{"location":"principles/bayestreePrinciples/#Why-a-Bayes-(Junction)-tree","page":"Bayes (Junction) tree","title":"Why a Bayes (Junction) tree","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The tree is algebraicly equivalent–-but acyclic–-structure to the factor graph:  i.) Inference is easier on on acyclic graphs; ii.) We can exploit Smart Message Passing benefits (known from the full conditional independence structure encoded in the tree), since the tree represents the \"complete form\" when marginalizing each variable one at a time (also known as elimination game, marginalization, also related to smart factors).  In loose terms, the Bayes (Junction) tree has implicit access to all Schur complements (if it parametric and linearized) of each variable to all others.  Please see this page more information regarding advanced topics on the Bayes tree.","category":"page"},{"location":"principles/bayestreePrinciples/#What-is-a-Bayes-(Junction)-tree","page":"Bayes (Junction) tree","title":"What is a Bayes (Junction) tree","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The Bayes tree data structure is a rooted and directed Junction tree (maximal elimination clique tree). It allows for exact inference to be carried out by leveraging and exposing the variables' conditional independence and, very interestingly, can be directly associated with the sparsity pattern exhibited by a system's factorized upper triangular square root information matrix (see picture below).","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"(Image: graph and matrix analagos)","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"Following this matrix-graph parallel, the picture also shows what the associated matrix interpretation is for a factor graph (~first order expansion in the form of a measurement Jacobian) and its corresponding Markov random field (sparsity pattern corresponding to the information matrix).","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The procedure for obtaining the Bayes (Junction) tree is outlined in the figure shown below (factor graph to chrodal Bayes net via bipartite elimination game, and chordal Bayes net to Bayes tree via maximum cardinality search algorithm).","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"(Image: add the fg2net2tree outline)","category":"page"},{"location":"principles/bayestreePrinciples/#Constructing-a-Tree","page":"Bayes (Junction) tree","title":"Constructing a Tree","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"note: Note\nA visual illustration of factor graph to Bayes net to Bayes tree can be found in this PDF ","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"Trees and factor graphs are separated in the implementation, allowing the user to construct multiple different trees from one factor graph except for a few temporary values in the factor graph.","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"using IncrementalInference # RoME or Caesar will work too\n\n## construct a distributed factor graph object\nfg = generateCanonicalFG_Kaess()\n# add variables and factors\n# ...\n\n## build the tree\ntree = buildTreeReset!(fg)","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The temporary values are reset from the distributed factor graph object fg<:AbstractDFG and a new tree is constructed.  This buildTreeReset! call can be repeated as many times the user desires and results should be consistent for the same factor graph structure (regardless of numerical values contained within).","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"buildTreeReset!","category":"page"},{"location":"principles/bayestreePrinciples/#IncrementalInference.buildTreeReset!","page":"Bayes (Junction) tree","title":"IncrementalInference.buildTreeReset!","text":"buildTreeReset!(dfg)\nbuildTreeReset!(dfg, eliminationOrder; variableOrder, ordering, drawpdf, show, filepath, viewerapp, imgs, ensureSolvable, eliminationConstraints, variableConstraints)\n\n\nBuild a completely new Bayes (Junction) tree, after first wiping clean all temporary state in fg from a possibly pre-existing tree.\n\nDevNotes\n\nreplaces resetBuildTreeFromOrder!\n\nRelated:\n\nbuildTreeFromOrdering!, \n\n\n\n\n\n","category":"function"},{"location":"principles/bayestreePrinciples/#Variable-Ordering","page":"Bayes (Junction) tree","title":"Variable Ordering","text":"","category":"section"},{"location":"principles/bayestreePrinciples/#Getting-the-AMD-Variable-Ordering","page":"Bayes (Junction) tree","title":"Getting the AMD Variable Ordering","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The variable ordering is described as a ::Vector{Symbol}.  Note the automated methods can be varied between AMD, CCOLAMD, and others.","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"# get the automated variable elimination order\nvo = getEliminationOrder(fg)","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"It is also possible to manually define the Variable Ordering","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"vo = [:x1; :l3; :x2; ...]","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"And then reset the factor graph and build a new tree","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"buildTreeReset!(fg, vo)","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"note: Note\na list of variables or factors can be obtained through the ls and related functions, see Querying the FactorGraph.","category":"page"},{"location":"principles/bayestreePrinciples/#Interfacing-with-the-MM-iSAMv2-Solver","page":"Bayes (Junction) tree","title":"Interfacing with the MM-iSAMv2 Solver","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The following parmaters (set before calling solveTree!) will show the solution progress on the tree visualization:","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"getSolverParams(fg).drawtree = true\ngetSolverParams(fg).showtree = true\n\n# asybc process will now draw and show the tree in linux\ntree, smt, hist = solveTree!(fg)","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"note: Note\nSee the Solving Graphs section for more details on the solver.","category":"page"},{"location":"principles/bayestreePrinciples/#Get-the-Elimination-Order-Used","page":"Bayes (Junction) tree","title":"Get the Elimination Order Used","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The solver internally uses buildTreeReset! which sometimes requires the user extract the variable elimination order after the fact.  This can be done with:","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"getEliminationOrder","category":"page"},{"location":"principles/bayestreePrinciples/#IncrementalInference.getEliminationOrder","page":"Bayes (Junction) tree","title":"IncrementalInference.getEliminationOrder","text":"Determine the variable ordering used to construct both the Bayes Net and Bayes/Junction/Elimination tree.\n\nNotes\n\nHeuristic method – equivalent to QR or Cholesky.\nAre using Blas QR function to extract variable ordering.\nNOT USING SUITE SPARSE – which would requires commercial license.\nFor now A::Array{<:Number,2} as a dense matrix.\nColumns of A are system variables, rows are factors (without differentiating between partial or full factor).\ndefault is to use solvable=1 and ignore factors and variables that might be used for dead reckoning or similar.\n\nFuture\n\nTODO: A should be sparse data structure (when we exceed 10'000 var dims)\nTODO: Incidence matrix is rectagular and adjacency is the square.\n\n\n\n\n\ngetEliminationOrder(treel)\n\n\nReturn the variable elimination order stored in a tree object.\n\n\n\n\n\n","category":"function"},{"location":"principles/bayestreePrinciples/#Visualizing","page":"Bayes (Junction) tree","title":"Visualizing","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"IncrementalInference.jl includes functions for visualizing the Bayes tree, and uses outside packages such as GraphViz (standard) and Latex tools (experimental, optional) to do so.  ","category":"page"},{"location":"principles/bayestreePrinciples/#GraphViz","page":"Bayes (Junction) tree","title":"GraphViz","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"drawTree(tree, show=true) # , filepath=\"/tmp/caesar/mytree.pdf\"","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"drawTree","category":"page"},{"location":"principles/bayestreePrinciples/#IncrementalInference.drawTree","page":"Bayes (Junction) tree","title":"IncrementalInference.drawTree","text":"drawTree(treel; show, suffix, filepath, xlabels, dpi, viewerapp, imgs)\n\n\nDraw the Bayes (Junction) tree by means of graphviz .dot files.  Ensure Linux packages  are installed sudo apt-get install graphviz xdot.\n\nNotes\n\nxlabels is optional cliqid=>xlabel.\n\n\n\n\n\n","category":"function"},{"location":"principles/bayestreePrinciples/#Latex-Tikz-(Optional)","page":"Bayes (Junction) tree","title":"Latex Tikz (Optional)","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"EXPERIMENTAL, requiring special import.","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"First make sure the following packages are installed on your system:","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"$ sudo apt-get install texlive-pictures dot2tex\n$ pip install dot2tex","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"Then in Julia you should be able to do:","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"import IncrementalInference: generateTexTree\n\ngenerateTexTree(tree)","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"An example Bayes (Junction) tree representation obtained through generateTexTree(tree) for the sample factor graph shown above can be seen in the following image.","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/27132241/69210722-9e0c0380-0b53-11ea-9462-7964844b89b1.png\" width=\"200\" border=\"0\" />\n</p>","category":"page"},{"location":"principles/bayestreePrinciples/#Visualizing-Clique-Adjacency-Matrix","page":"Bayes (Junction) tree","title":"Visualizing Clique Adjacency Matrix","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"It is also possible to see the upward message passing variable/factor association matrix for each clique, requiring the Gadfly.jl package:","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"using Gadfly\n\nspyCliqMat(tree, :x1) # provided by IncrementalInference\n\n#or embedded in graphviz\ndrawTree(tree, imgs=true, show=true)","category":"page"},{"location":"principles/bayestreePrinciples/#Clique-State-Machine","page":"Bayes (Junction) tree","title":"Clique State Machine","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The mmisam solver is based on a state machine design to handle the inter and intra clique operations during a variety of situations.  Use of the clique state machine (CSM) makes debugging, development, verification, and modification of the algorithm real easy.  Contact us for any support regarding modifications to the default algorithm.  For pre-docs on working with CSM, please see IIF #443.","category":"page"},{"location":"principles/bayestreePrinciples/#STATUS-of-a-Clique","page":"Bayes (Junction) tree","title":"STATUS of a Clique","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"CSM currently uses the following statusses for each of the cliques during the inference process.","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"[:initialized;:upsolved;:marginalized;:downsolved;:uprecycled]","category":"page"},{"location":"principles/bayestreePrinciples/#Bayes-Tree-Legend-(from-IIF)","page":"Bayes (Junction) tree","title":"Bayes Tree Legend (from IIF)","text":"","category":"section"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"The color legend for the refactored CSM from issue.","category":"page"},{"location":"principles/bayestreePrinciples/","page":"Bayes (Junction) tree","title":"Bayes (Junction) tree","text":"Blank / white – uninitialized or unprocessed,\nOrange – recycled clique upsolve solution from previous tree passed into solveTree! – TODO,\nBlue – fully marginalized clique that will not be updated during upsolve (maybe downsolved),\nLight blue – completed downsolve,\nGreen – trying to up initialize,\nDarkgreen – initUp some could up init,\nLightgreen – initUp no aditional variables could up init,\nOlive – trying to down initialize,\nSeagreen – initUp some could down init,\nKhaki – initUp no aditional variables could down init,\nBrown – initialized but not solved yet (likely child cliques that depend on downward autoinit msgs),\nLight red – completed upsolve,\nTomato – partial dimension upsolve but finished,\nRed – CPU working on clique's Chapman-Kolmogorov inference (up),\nMaroon – CPU working on clique's Chapman-Kolmogorov inference (down),\nRed – If finished cliques in red are in ERROR_STATUS","category":"page"},{"location":"examples/examples/#Examples","page":"Caesar Examples","title":"Examples","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"The following examples demonstrate the conceptual operation of Caesar, highlighting specific features of the framework and its use.","category":"page"},{"location":"examples/examples/#Continuous-Scalar","page":"Caesar Examples","title":"Continuous Scalar","text":"","category":"section"},{"location":"examples/examples/#Calculating-a-Square-Root-(Underdetermined)","page":"Caesar Examples","title":"Calculating a Square Root (Underdetermined)","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"Probably the most minimal example that illustrates how factor graphs represent a mathematical framework is a reworking of the classic square root calculation.","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/98160784-b2542800-1eac-11eb-81ca-4997a8a7b25c.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"note: Note\nWIP, a combined type-definion and square root script is available as an example script.  We're working to present the example without having to define any types.","category":"page"},{"location":"examples/examples/#Continuous-Scalar-with-Mixtures","page":"Caesar Examples","title":"Continuous Scalar with Mixtures","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"This abstract continuous scalar example illustrates how IncrementalInference.jl enables algebraic relations between stochastic variables, and how a final posterior belief estimate is calculated from several pieces of information.","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx0123.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/examples/#Hexagonal-2D","page":"Caesar Examples","title":"Hexagonal 2D","text":"","category":"section"},{"location":"examples/examples/#Batch-Mode","page":"Caesar Examples","title":"Batch Mode","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"A simple 2D hexagonal robot trajectory example is expanded below using techniques developed in simultaneous localization and mapping (SLAM).","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/69353457-6cd82400-0c76-11ea-905c-8f435faa6b11.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/examples/#Bayes-Tree-Fixed-Lag-Solving-Hexagonal2D-Revisited","page":"Caesar Examples","title":"Bayes Tree Fixed-Lag Solving - Hexagonal2D Revisited","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"The hexagonal fixed-lag example shows how tree based clique recycling can be achieved.  A further example is given in the real-world underwater example below.","category":"page"},{"location":"examples/examples/#An-Underdetermined-Solution-(a.k.a.-SLAM-e-donut)","page":"Caesar Examples","title":"An Underdetermined Solution (a.k.a. SLAM-e-donut)","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"This tutorial describes (unforced multimodality) a range-only system where there are always more variable dimensions than range measurements made, see Underdeterminied Example here The error distribution over ranges could be nearly anything, but are restricted to Gaussian-only in this example to illustrate an alternative point – other examples show inference results where highly non-Gaussian error distributions are used.","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"Multi-modal range only example (click here or image for full Vimeo):   ","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"http://vimeo.com/190052649\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/JuliaRobotics/IncrementalInference.jl/master/doc/images/mmisamvid01.gif\" alt=\"IMAGE ALT TEXT HERE\" width=\"640\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#Towards-Real-Time-Underwater-Acoustic-Navigation","page":"Caesar Examples","title":"Towards Real-Time Underwater Acoustic Navigation","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"This example uses \"dead reckon tethering\" (DRT) to perform many of the common robot odometry and high frequency pose updated operations.  These features are a staple and standard part of the distributed factor graph system.","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"Click on image (or this link to Vimeo) for a video illustration:","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"http://vimeo.com/396532767\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/6412556/76251581-24ea0680-623f-11ea-9906-ecbe5d8ef790.gif\" alt=\"AUV SLAM\" width=\"640\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#Uncertain-Data-Associations,-(forced-multi-hypothesis)","page":"Caesar Examples","title":"Uncertain Data Associations, (forced multi-hypothesis)","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"This example presents a novel multimodal solution to an otherwise intractible multihypothesis SLAM problem.  This work spans the entire Victoria Park dataset, and resolves a solution over roughly 10000 variable dimensions with 2^1700 (yes to teh power 1700) theoretically possible modes.  At the time of first solution in 2016, a full batch solution took around 3 hours to compute on a very spartan early implementation.","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"<img src=\"https://user-images.githubusercontent.com/6412556/76264526-fc233a80-6259-11ea-98aa-192d40f504f4.gif\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"The fractional multi-hypothesis assignments addFactor!(..., multihypo=[1.0; 0.5;0.5]).  The Multihypothesis Section discusses this feature in more detail.  Similarly for tri-nary or higher multi-hypotheses.","category":"page"},{"location":"examples/examples/#Probabilistic-Data-Association-(Uncertain-loop-closures)","page":"Caesar Examples","title":"Probabilistic Data Association (Uncertain loop closures)","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"Example where the standard multihypothesis addFactor!(.., multihypo=[1.0;0.5;0.5]) interface is used.  This is from the Kitti driving dataset.  Video here.  The Multihypothesis Section discusses this feature in more detail.","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"https://www.youtube.com/watch?v=9hEonD8KDrs\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/6412556/53611733-9065b680-3b9d-11e9-8b0f-cb292a25fbb3.png\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#Synthetic-Aperture-Sonar-SLAM","page":"Caesar Examples","title":"Synthetic Aperture Sonar SLAM","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"The full functional (approximate sum-product) inference approach can be used to natively imbed single hydrophone acoustic waveform data into highly non-Gaussian SAS factors–that implicitly perform beamforming/micro-location–-for a simultaneous localization and mapping solution (image links to video).  See the Raw Correlator Probability (Matched Filter) Section for more details.","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"https://www.youtube.com/watch?v=_RfXLQ67N4o\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/6412556/52547229-3048d500-2d94-11e9-8a46-811316a45283.png\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#Marine-Surface-Vehicle-with-ROS","page":"Caesar Examples","title":"Marine Surface Vehicle with ROS","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"New marine surface vehicle code tutorial using ROS.","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"note: Note\nSee initial example here, and native ROS support section here.","category":"page"},{"location":"examples/examples/#Simulated-Ambiguous-SONAR-in-3D","page":"Caesar Examples","title":"Simulated Ambiguous SONAR in 3D","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"Intersection of ambiguous elevation angle from planar SONAR sensor:   ","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"http://vimeo.com/198237738\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/rovasfm02.gif\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"Bi-modal belief","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"http://vimeo.com/198872855\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/rovyaw90.gif\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#Multi-session-Indoor-Robot","page":"Caesar Examples","title":"Multi-session Indoor Robot","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"Multi-session Turtlebot example of the second floor in the Stata Center:","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/turtlemultisession.gif\" alt=\"Turtlebot Multi-session animation\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"See the multisession information page for more details, as well as academic work:","category":"page"},{"location":"examples/examples/#More-Examples","page":"Caesar Examples","title":"More Examples","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"Please see examples folders for Caesar and RoME for more examples, with expanded documentation in the works.","category":"page"},{"location":"examples/examples/#Adding-Factors-Simple-Factor-Design","page":"Caesar Examples","title":"Adding Factors - Simple Factor Design","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"Caesar can be extended with new variables and factors without changing the core code. An example of this design pattern is provided in this example.","category":"page"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"Defining New Variables and Factor","category":"page"},{"location":"examples/examples/#Adding-Factors-DynPose-Factor","page":"Caesar Examples","title":"Adding Factors - DynPose Factor","text":"","category":"section"},{"location":"examples/examples/","page":"Caesar Examples","title":"Caesar Examples","text":"Intermediate Example: Adding Dynamic Factors and Variables","category":"page"},{"location":"examples/basic_continuousscalar/#Tutorials","page":"ContinuousScalar as 1D Example","title":"Tutorials","text":"","category":"section"},{"location":"examples/basic_continuousscalar/#IncrementalInference.jl-ContinuousScalar","page":"ContinuousScalar as 1D Example","title":"IncrementalInference.jl ContinuousScalar","text":"","category":"section"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This tutorial illustrates how IncrementalInference enables algebraic relations (residual functions) between multiple stochastic variables, and how a final posterior belief estimate is calculated from several pieces of information. The application of this tutorial is presented in abstract from which the user is free to imagine any system of relationships:  For example, a robot driving in a one dimensional world; or a time traveler making uncertain jumps forwards and backwards in time. The tutorial implicitly shows a multi-modal uncertainty introduced and transmitted. The tutorial also illustrates consensus through an additional piece of information, which reduces all stochastic variable marginal beliefs to unimodal only beliefs. The example will also illustrate the use of non-Gaussian beliefs and global inference. Lastly, the tutorial demonstrates how automatic initialization of variables works.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This tutorial requires IncrementalInference v0.3.0+, RoME v0.1.0, RoMEPlotting packages be installed. In addition, the optional GraphViz package will allow easy visualization of the FactorGraph object structure.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"To start, the two major mathematical packages are brought into scope.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"using IncrementalInference\n# using Distributions # automatically reexported by IncrementalInference","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Guidelines for developing your own functions are discussed here in Adding Variables and Factors, and we note that mechanizations and manifolds required for robotic simultaneous localization and mapping (SLAM) has been tightly integrated with the expansion package RoME.jl.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The next step is to describe the inference problem with a graphical model with any of the existing concrete types that inherit from  <: AbstractDFG. The first step is to create an empty factor graph object and start populating it with variable nodes. The variable nodes are identified by Symbols, namely :x0, :x1, :x2, :x3.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"# Start with an empty factor graph\nfg = initfg()\n\n# add the first node\naddVariable!(fg, :x0, ContinuousScalar)\n\n# this is unary (prior) factor and does not immediately trigger autoinit of :x0.\naddFactor!(fg, [:x0], Prior(Normal(0,1)))","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Factor graphs are bipartite graphs with factors that act as mathematical structure between interacting variables. After adding node :x0, a singleton factor of type Prior (which was defined by the user earlier) is 'connected to' variable node :x0. This unary factor is taken as a Distributions.Normal distribution with zero mean and a standard devitation of 1. Graphviz can be used to visualize the factor graph structure, although the package is not installed by default – $ sudo apt-get install graphviz. Furthermore, the writeGraphPdf member definition is given at the end of this tutorial, which allows the user to store the graph image in graphviz supported image types.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"drawGraph(fg, show=true)","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The two node factor graph is shown in the image below.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx0.png\" width=\"120\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Automatic initialization of variables depend on how the factor graph model is constructed. This tutorial demonstrates this behavior by first showing that :x0 is not initialized:","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"@show isInitialized(fg, :x0) # false","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Why is :x0 not initialized? Since no other variable nodes have been 'connected to' (or depend) on :x0 and future intentions of the user are unknown, the initialization of :x0 is deferred until the latest possible moment. IncrementalInference.jl assumes that the user will generally populate new variable nodes with most of the associated factors before moving to the next variable. By delaying initialization of a new variable (say :x0) until a second newer uninitialized variable (say :x1) depends on :x0, the IncrementalInference algorithms hope to then initialize :x0 with the more information from previous and surrounding variables and factors. Also note that initialization of variables is a local operation based only on the neighboring nodes – global inference will over the entire graph is shows later in this tutorial.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"By adding :x1 and connecting it through the LinearRelative and Normal distributed factor, the automatic initialization of :x0 is triggered.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addVariable!(fg, :x1, ContinuousScalar)\n# P(Z | :x1 - :x0 ) where Z ~ Normal(10,1)\naddFactor!(fg, [:x0, :x1], LinearRelative(Normal(10.0,1)))\n@show isInitialized(fg, :x0) # true","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Note that the automatic initialization of :x0 is aware that :x1 is not initialized and therefore only used the Prior(Normal(0,1)) unary factor to initialize the marginal belief estimate for :x0. The structure of the graph has now been updated to two variable nodes and two factors.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx01.png\" width=\"240\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Global inference requires that the entire factor graph be initialized before the numerical belief computation algorithms can be performed. Notice how the new :x1 variable is not yet initialized:","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"@show isInitialized(fg, :x1) # false","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The RoMEPlotting.jl package allows visualization (plotting) of the belief state over any of the variable nodes. Remember the first time executions are slow given required code compilation, and that future versions of these package will use more precompilation to reduce first execution running cost.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"using RoMEPlotting\n\nplotKDE(fg, :x0)","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx0.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"By forcing the initialization of :x1 and plotting its belief estimate,","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"ensureAllInitialized!(fg)\nplotKDE(fg, [:x0, :x1])","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"the predicted influence of the P(Z| X1 - X0) = LinearRelative(Normal(10, 1)) is shown by the red trace.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx01.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The red trace (predicted belief of :x1) is noting more than the approximated convolution of the current marginal belief of :x0 with the conditional belief described by P(Z | X1 - X0).","category":"page"},{"location":"examples/basic_continuousscalar/#Defining-A-Mixture-Relative-on-ContinuousScalar","page":"ContinuousScalar as 1D Example","title":"Defining A Mixture Relative on ContinuousScalar","text":"","category":"section"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Another ContinuousScalar variable :x2 is 'connected' to :x1 through a more complicated MixtureRelative likelihood function.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addVariable!(fg, :x2, ContinuousScalar)\nmmo = Mixture(LinearRelative, \n              (hypo1=Rayleigh(3), hypo2=Uniform(30,55)), \n              [0.4; 0.6])\naddFactor!(fg, [:x1, :x2], mmo)","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx012.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The mmo variable illustrates how a near arbitrary mixture probability distribution can be used as a conditional relationship between variable nodes in the factor graph. In this case, a 40%/60% balance of a Rayleigh and truncated Uniform distribution which acts as a multi-modal conditional belief. Interpret carefully what a conditional belief of this nature actually means.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Following the tutorial's practical example frameworks (robot navigation or time travel), this multi-modal belief implies that moving from one of the probable locations in :x1 to a location in :x2 by some processes defined by mmo=P(Z | X2, X1) is uncertain to the same 40%/60% ratio. In practical terms, collapsing (through observation of an event) the probabilistic likelihoods of the transition from :x1 to :x2 may result in the :x2 location being at either 15-20, or 40-65-ish units. The predicted belief over :x2 is illustrated by plotting the predicted belief (green trace), after forcing initialization.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"ensureAllInitialized!(fg)\nplotKDE(fg, [:x0, :x1, :x2])","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx012.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Adding one more variable :x3 through another LinearRelative(Normal(-50,1))","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addVariable!(fg, :x3, ContinuousScalar)\naddFactor!(fg, [:x2, :x3], LinearRelative(Normal(-50, 1)))","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"expands the factor graph to to four variables and four factors.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx0123.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This part of the tutorial shows how a unimodal likelihood (conditional belief) can transmit the bimodal belief currently contained in :x2.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"ensureAllInitialized!(fg)\nplotKDE(fg, [:x0, :x1, :x2, :x3])","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Notice the blue trace (:x3) is a shifted and slightly spread out version of the initialized belief on :x2, through the convolution with the conditional belief P(Z | X2, X3).","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx0123.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Global inference over the entire factor graph has still not occurred, and will at this stage produce roughly similar results to the predicted beliefs shown above. Only by introducing more information into the factor graph can inference extract more precise marginal belief estimates for each of the variables. A final piece of information added to this graph is a factor directly relating :x3 with :x0.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addFactor!(fg, [:x3, :x0], LinearRelative(Normal(40, 1)))","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Pay close attention to what this last factor means in terms of the probability density traces shown in the previous figure. The blue trace for :x3 has two major modes, one that overlaps with :x0, :x1 near 0 and a second mode further to the left at -40. The last factor introduces a shift LinearRelative(Normal(40,1)) which essentially aligns the left most mode of :x3 back onto :x0.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx0123c.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This last factor forces a mode selection through consensus. By doing global inference, the new information obtained in :x3 will be equally propagated to :x2 where only one of the two modes will remain.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Global inference is achieved with local computation using two function calls, as follows.","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"tree, smt, hist = solveTree!(fg)\n\n# and visualization\nplotKDE(fg, [:x0, :x1, :x2, :x3])","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The resulting posterior marginal beliefs over all the system variables are:","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx0123infr.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"It is import to note that although this tutorial ends with all marginal beliefs having near Gaussian shape and are unimodal, that the package supports multi-modal belief estimates during both the prediction and global inference processes. In fact, many of the same underlying inference functions are involved with the automatic initialization process and the global multi-modal iSAM inference procedure. This concludes the ContinuousScalar tutorial particular to the IncrementalInference package.","category":"page"},{"location":"func_ref/#Additional-Function-Reference","page":"Caesar's Reference","title":"Additional Function Reference","text":"","category":"section"},{"location":"func_ref/","page":"Caesar's Reference","title":"Caesar's Reference","text":"Pages = [\n    \"func_ref.md\"\n]\nDepth = 3","category":"page"},{"location":"func_ref/#RoME","page":"Caesar's Reference","title":"RoME","text":"","category":"section"},{"location":"func_ref/","page":"Caesar's Reference","title":"Caesar's Reference","text":"getRangeKDEMax2D\ninitFactorGraph!\naddOdoFG!","category":"page"},{"location":"func_ref/#RoME.getRangeKDEMax2D","page":"Caesar's Reference","title":"RoME.getRangeKDEMax2D","text":"getRangeKDEMax2D(fgl, vsym1, vsym2)\n\n\nCalculate the cartesian distance between two vertices in the graph using their symbol name, and by maximum belief point.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#RoME.initFactorGraph!","page":"Caesar's Reference","title":"RoME.initFactorGraph!","text":"initFactorGraph!(fg; P0, init, N, lbl, solvable, firstPoseType, labels)\n\n\nInitialize a factor graph object as Pose2, Pose3, or neither and returns variable and factor symbols as array.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#RoME.addOdoFG!","page":"Caesar's Reference","title":"RoME.addOdoFG!","text":"addOdoFG!(fg, n, DX, cov; N, solvable, labels)\n\n\nCreate a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x<k+1> for new node new node and constraint factor are returned as a tuple.\n\n\n\n\n\naddOdoFG!(fgl, odo; N, solvable, labels)\n\n\nCreate a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x<k+1> for new node new node and constraint factor are returned as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference","page":"Caesar's Reference","title":"IncrementalInference","text":"","category":"section"},{"location":"func_ref/","page":"Caesar's Reference","title":"Caesar's Reference","text":"approxCliqMarginalUp!\nareCliqVariablesAllMarginalized\nattemptTreeSimilarClique\nchildCliqs\ncliqHistFilterTransitions\ncsmAnimate\ncycleInitByVarOrder!\ndoautoinit!\ndrawCliqSubgraphUpMocking\nfifoFreeze!\nfilterHistAllToArray\nfindRelatedFromPotential\nfmcmc!\ngetClique\ngetCliqAllVarIds\ngetCliqAllVarSyms\ngetCliqAssocMat\ngetCliqDepth\ngetCliqDownMsgsAfterDownSolve\ngetCliqFrontalVarIds\ngetCliqVarInitOrderUp\ngetCliqMat\ngetCliqSeparatorVarIds\ngetCliqSiblings\ngetCliqVarIdsPriors\ngetCliqVarSingletons\ngetParent\ngetTreeAllFrontalSyms\ngetVariableDim\ngetVariableInferredDim\nhasClique\nisInitialized\nisMarginalized\nisTreeSolved\nisPartial\nlocalProduct\nmakeCsmMovie\nparentCliq\npredictVariableByFactor\nprintCliqHistorySummary\nproductpartials!\nprodmultiplefullpartials\nprodmultipleonefullpartials\nresetBuildTreeFromOrder!\nresetCliqSolve!\nresetData!\nresetTreeCliquesForUpSolve!\nresetVariable!\nsandboxCliqResolveStep\nsetfreeze!\nsetValKDE!\nsetVariableInitialized!\nsetVariableInferDim!\nsolveCliq!\nsolveCliqWithStateMachine!\ntransferUpdateSubGraph!\ntreeProductDwn\ntreeProductUp\nunfreezeVariablesAll!\ndontMarginalizeVariablesAll!\nupdateFGBT!\nupGibbsCliqueDensity\nresetVariableAllInitializations!","category":"page"},{"location":"func_ref/#IncrementalInference.approxCliqMarginalUp!","page":"Caesar's Reference","title":"IncrementalInference.approxCliqMarginalUp!","text":"approxCliqMarginalUp!(csmc)\napproxCliqMarginalUp!(csmc, childmsgs; N, dbg, multiproc, logger, iters, drawpdf)\n\n\nApproximate Chapman-Kolmogorov transit integral and return separator marginals as messages to pass up the Bayes (Junction) tree, along with additional clique operation values for debugging.\n\nNotes\n\nonduplicate=true by default internally uses deepcopy of factor graph and Bayes tree, and does not update the given objects.  Set false to update fgl and treel during compute.\n\nFuture\n\nTODO: internal function chain is too long and needs to be refactored for maintainability.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.areCliqVariablesAllMarginalized","page":"Caesar's Reference","title":"IncrementalInference.areCliqVariablesAllMarginalized","text":"areCliqVariablesAllMarginalized(subfg, cliq)\n\n\nReturn true if all variables in clique are considered marginalized (and initialized).\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.attemptTreeSimilarClique","page":"Caesar's Reference","title":"IncrementalInference.attemptTreeSimilarClique","text":"attemptTreeSimilarClique(othertree, seeksSimilar)\n\n\nSpecial internal function to try return the clique data if succesfully identified in othertree::AbstractBayesTree, based on contents of seeksSimilar::BayesTreeNodeData.\n\nNotes\n\nUsed to identify and skip similar cliques (i.e. recycle computations)\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.childCliqs","page":"Caesar's Reference","title":"IncrementalInference.childCliqs","text":"childCliqs(treel, cliq)\n\n\nReturn a vector of child cliques to cliq.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.cliqHistFilterTransitions","page":"Caesar's Reference","title":"IncrementalInference.cliqHistFilterTransitions","text":"cliqHistFilterTransitions(hist, nextfnc)\n\n\nReturn state machine transition steps from history such that the nextfnc::Function.\n\nRelated:\n\nprintCliqHistorySummary, filterHistAllToArray, sandboxCliqResolveStep\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.cycleInitByVarOrder!","page":"Caesar's Reference","title":"IncrementalInference.cycleInitByVarOrder!","text":"cycleInitByVarOrder!(subfg, varorder; logger)\n\n\nCycle through var order and initialize variables as possible in subfg::AbstractDFG. Return true if something was updated.\n\nNotes:\n\nassumed subfg is a subgraph containing only the factors that can be used.\nincluding the required up or down messages\nintended for both up and down initialization operations.\n\nDev Notes\n\nShould monitor updates based on the number of inferred & solvable dimensions\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.doautoinit!","page":"Caesar's Reference","title":"IncrementalInference.doautoinit!","text":"doautoinit!(dfg, xi; singles, N, logger)\n\n\nEXPERIMENTAL: initialize target variable xi based on connected factors in the factor graph fgl.  Possibly called from addFactor!, or doCliqAutoInitUp! (?).\n\nNotes:\n\nSpecial carve out for multihypo cases, see issue 427.\n\nDevelopment Notes:\n\nTarget factor is first (singletons) or second (dim 2 pairwise) variable vertex in xi.\n\nTODO use DFG properly with local operations and DB update at end.\nTODO get faster version of isInitialized for database version.\nTODO: Persist this back if we want to here.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.drawCliqSubgraphUpMocking","page":"Caesar's Reference","title":"IncrementalInference.drawCliqSubgraphUpMocking","text":"drawCliqSubgraphUpMocking(fgl, treel, frontalSym; show, filepath, engine, viewerapp)\n\n\nConstruct (new) subgraph and draw the subgraph associated with clique frontalSym::Symbol.\n\nNotes\n\nSee drawGraphCliq/writeGraphPdf for details on keyword options.\n\nRelated\n\ndrawGraphCliq, spyCliqMat, drawTree, buildCliqSubgraphUp, buildSubgraphFromLabels!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.fifoFreeze!","page":"Caesar's Reference","title":"IncrementalInference.fifoFreeze!","text":"fifoFreeze!(dfg)\n\n\nFreeze nodes that are older than the quasi fixed-lag length defined by fg.qfl, according to fg.fifo ordering.\n\nFuture:\n\nAllow different freezing strategies beyond fifo.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.filterHistAllToArray","page":"Caesar's Reference","title":"IncrementalInference.filterHistAllToArray","text":"filterHistAllToArray(tree, hists, frontals, nextfnc)\n\n\nReturn state machine transition steps from all cliq histories with transition nextfnc::Function.\n\nRelated:\n\nprintCliqHistorySummary, cliqHistFilterTransitions, sandboxCliqResolveStep\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.findRelatedFromPotential","page":"Caesar's Reference","title":"IncrementalInference.findRelatedFromPotential","text":"findRelatedFromPotential(dfg, fct, target)\nfindRelatedFromPotential(dfg, fct, target, measurement; N, solveKey, dbg)\n\n\nCompute proposal belief on vertid through fct representing some constraint in factor graph. Always full dimension variable node – partial constraints will only influence subset of variable dimensions. The remaining dimensions will keep pre-existing variable values.\n\nNotes\n\nfulldim is true when \"rank-deficient\" – TODO swap to false (or even float)\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.fmcmc!","page":"Caesar's Reference","title":"IncrementalInference.fmcmc!","text":"fmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter)\nfmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter, dbg)\nfmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter, dbg, logger)\nfmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter, dbg, logger, multithreaded)\n\n\nIterate successive approximations of clique marginal beliefs by means of the stipulated proposal convolutions and products of the functional objects for tree clique cliq.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getClique","page":"Caesar's Reference","title":"IncrementalInference.getClique","text":"getClique(tree, cId)\n\n\nReturn the TreeClique node object that represents a clique in the Bayes (Junction) tree, as defined by one of the frontal variables frt<:AbstractString.\n\nNotes\n\nFrontal variables only occur once in a clique per tree, therefore is a unique identifier.\n\nRelated:\n\ngetCliq, getTreeAllFrontalSyms\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqAllVarIds","page":"Caesar's Reference","title":"IncrementalInference.getCliqAllVarIds","text":"getCliqAllVarIds(cliq)\n\n\nGet all cliq variable ids::Symbol.\n\nRelated\n\ngetCliqVarIdsAll, getCliqAllFactIds, getCliqVarsWithFrontalNeighbors\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqAllVarSyms","page":"Caesar's Reference","title":"IncrementalInference.getCliqAllVarSyms","text":"Get all cliq variable labels as ::Symbol.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqAssocMat","page":"Caesar's Reference","title":"IncrementalInference.getCliqAssocMat","text":"getCliqAssocMat(cliq)\n\n\nReturn boolean matrix of factor by variable (row by column) associations within clique, corresponds to order presented by getCliqFactorIds and getCliqAllVarIds.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqDepth","page":"Caesar's Reference","title":"IncrementalInference.getCliqDepth","text":"getCliqDepth(tree, cliq)\n\n\nReturn depth in tree as ::Int, with root as depth=0.\n\nRelated\n\ngetCliq\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqDownMsgsAfterDownSolve","page":"Caesar's Reference","title":"IncrementalInference.getCliqDownMsgsAfterDownSolve","text":"getCliqDownMsgsAfterDownSolve(subdfg, cliq)\n\n\nReturn dictionary of down messages consisting of all frontal and separator beliefs of this clique.\n\nNotes:\n\nFetches numerical results from subdfg as dictated in cliq.\nreturn LikelihoodMessage\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqFrontalVarIds","page":"Caesar's Reference","title":"IncrementalInference.getCliqFrontalVarIds","text":"getCliqFrontalVarIds(cliqdata)\n\n\nGet the frontal variable IDs ::Int for a given clique in a Bayes (Junction) tree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqVarInitOrderUp","page":"Caesar's Reference","title":"IncrementalInference.getCliqVarInitOrderUp","text":"getCliqVarInitOrderUp(subfg)\n\n\nReturn the most likely  ordering for initializing factor (assuming up solve sequence).\n\nNotes:\n\nsorts id (label) for increasing number of connected factors using the clique subfg with messages already included.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqMat","page":"Caesar's Reference","title":"IncrementalInference.getCliqMat","text":"getCliqMat(cliq; showmsg)\n\n\nReturn boolean matrix of factor variable associations for a clique, optionally including (showmsg::Bool=true) the upward message singletons.  Variable order corresponds to getCliqAllVarIds.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqSeparatorVarIds","page":"Caesar's Reference","title":"IncrementalInference.getCliqSeparatorVarIds","text":"getCliqSeparatorVarIds(cliqdata)\n\n\nGet cliq separator (a.k.a. conditional) variable ids::Symbol.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqSiblings","page":"Caesar's Reference","title":"IncrementalInference.getCliqSiblings","text":"getCliqSiblings(treel, cliq)\ngetCliqSiblings(treel, cliq, inclusive)\n\n\nReturn a vector of all siblings to a clique, which defaults to not inclusive the calling cliq.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqVarIdsPriors","page":"Caesar's Reference","title":"IncrementalInference.getCliqVarIdsPriors","text":"getCliqVarIdsPriors(cliq)\ngetCliqVarIdsPriors(cliq, allids)\ngetCliqVarIdsPriors(cliq, allids, partials)\n\n\nGet variable ids::Int with prior factors associated with this cliq.\n\nNotes:\n\ndoes not include any singleton messages from upward or downward message passing.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliqVarSingletons","page":"Caesar's Reference","title":"IncrementalInference.getCliqVarSingletons","text":"getCliqVarSingletons(cliq)\ngetCliqVarSingletons(cliq, allids)\ngetCliqVarSingletons(cliq, allids, partials)\n\n\nGet cliq variable IDs with singleton factors – i.e. both in clique priors and up messages.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getParent","page":"Caesar's Reference","title":"IncrementalInference.getParent","text":"getParent(treel, afrontal)\n\n\nReturn cliq's parent clique.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getTreeAllFrontalSyms","page":"Caesar's Reference","title":"IncrementalInference.getTreeAllFrontalSyms","text":"getTreeAllFrontalSyms(_, tree)\n\n\nReturn one symbol (a frontal variable) from each clique in the ::BayesTree.\n\nNotes\n\nFrontal variables only occur once in a clique per tree, therefore is a unique identifier.\n\nRelated:\n\nwhichCliq, printCliqHistorySummary\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getVariableDim","page":"Caesar's Reference","title":"IncrementalInference.getVariableDim","text":"getVariableDim(vard)\n\n\nReturn the number of dimensions this variable vertex var contains.\n\nRelated\n\ngetVariableInferredDim, getVariableInferredDimFraction\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getVariableInferredDim","page":"Caesar's Reference","title":"IncrementalInference.getVariableInferredDim","text":"getVariableInferredDim(vard)\ngetVariableInferredDim(vard, saturate)\n\n\nReturn the number of projected dimensions into a variable during inference.\n\nNotes\n\nsaturate clamps return value to no greater than variable dimension\n\nRelated\n\ngetVariableDim, getVariableInferredDimFraction, getVariableInferredDim, getVariableDim\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.hasClique","page":"Caesar's Reference","title":"IncrementalInference.hasClique","text":"hasClique(bt, frt)\n\n\nReturn boolean on whether the frontal variable frt::Symbol exists somewhere in the ::BayesTree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#DistributedFactorGraphs.isInitialized","page":"Caesar's Reference","title":"DistributedFactorGraphs.isInitialized","text":"isInitialized(var)\nisInitialized(var, key)\n\n\nReturns state of variable data .initialized flag.\n\nNotes:\n\nused by both factor graph variable and Bayes tree clique logic.\n\n\n\n\n\nisInitialized(cliq)\n\n\nReturns state of Bayes tree clique .initialized flag.\n\nNotes:\n\nused by Bayes tree clique logic.\nsimilar method in DFG\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.isMarginalized","page":"Caesar's Reference","title":"IncrementalInference.isMarginalized","text":"isMarginalized(vert)\n\n\nReturn ::Bool on whether this variable has been marginalized.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.isTreeSolved","page":"Caesar's Reference","title":"IncrementalInference.isTreeSolved","text":"isTreeSolved(treel; skipinitialized)\n\n\nReturn true or false depending on whether the tree has been fully initialized/solved/marginalized.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.isPartial","page":"Caesar's Reference","title":"IncrementalInference.isPartial","text":"Return ::Bool on whether factor is a partial constraint.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.localProduct","page":"Caesar's Reference","title":"IncrementalInference.localProduct","text":"localProduct(dfg, sym; solveKey, N, dbg, logger)\n\n\nUsing factor graph object dfg, project belief through connected factors (convolution with conditional) to variable sym followed by a approximate functional product.\n\nReturn: product belief, full proposals, partial dimension proposals, labels\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.makeCsmMovie","page":"Caesar's Reference","title":"IncrementalInference.makeCsmMovie","text":"makeCsmMovie(fg, tree)\nmakeCsmMovie(fg, tree, cliqs; assignhist, show, filename, frames)\n\n\nConvenience function to assign and make video of CSM state machine for cliqs.\n\nNotes\n\nProbably several teething issues still (lower priority).\nUse assignhist if solver params async was true, or errored.\n\nRelated\n\ncsmAnimate, printCliqHistorySummary\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.parentCliq","page":"Caesar's Reference","title":"IncrementalInference.parentCliq","text":"parentCliq(treel, cliq)\n\n\nReturn cliq's parent clique.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#RoME.predictVariableByFactor","page":"Caesar's Reference","title":"RoME.predictVariableByFactor","text":"predictVariableByFactor(dfg, targetsym, fct, prevars)\n\n\nMethod to compare current and predicted estimate on a variable, developed for testing a new factor before adding to the factor graph.\n\nNotes\n\nfct does not have to be in the factor graph – likely used to test beforehand.\nfunction is useful for detecting if multihypo should be used.\napproxConv will project the full belief estimate through some factor but must already be in factor graph.\n\nExample\n\n# fg already exists containing :x7 and :l3\npp = Pose2Point2BearingRange(Normal(0,0.1),Normal(10,1.0))\n# possible new measurement from :x7 to :l3\ncurr, pred = predictVariableByFactor(fg, :l3, pp, [:x7; :l3])\n# example of naive user defined test on fit score\nfitscore = minkld(curr, pred)\n# `multihypo` can be used as option between existing or new variables\n\nRelated\n\napproxConv\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.printCliqHistorySummary","page":"Caesar's Reference","title":"IncrementalInference.printCliqHistorySummary","text":"printCliqHistorySummary(fid, hist)\nprintCliqHistorySummary(fid, hist, cliqid)\n\n\nPrint a short summary of state machine history for a clique solve.\n\nRelated:\n\ngetTreeAllFrontalSyms, animateCliqStateMachines, printHistoryLine, printCliqHistorySequential\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.productpartials!","page":"Caesar's Reference","title":"IncrementalInference.productpartials!","text":"productpartials!(pGM, dummy, partials, manis)\n\n\nMultiply different dimensions from partial constraints individually.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.prodmultiplefullpartials","page":"Caesar's Reference","title":"IncrementalInference.prodmultiplefullpartials","text":"prodmultiplefullpartials(dens, partials, Ndims, N, manis)\n\n\nMultiply various full and partial dimension constraints.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.prodmultipleonefullpartials","page":"Caesar's Reference","title":"IncrementalInference.prodmultipleonefullpartials","text":"Multiply a single full and several partial dimension constraints.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.resetCliqSolve!","page":"Caesar's Reference","title":"IncrementalInference.resetCliqSolve!","text":"resetCliqSolve!(dfg, treel, cliq; solveKey)\n\n\nReset the state of all variables in a clique to not initialized.\n\nNotes\n\nresets numberical values to zeros.\n\nDev Notes\n\nTODO not all kde manifolds will initialize to zero.\nFIXME channels need to be consolidated\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.resetData!","page":"Caesar's Reference","title":"IncrementalInference.resetData!","text":"resetData!(vdata)\n\n\nPartial reset of basic data fields in ::VariableNodeData of ::FunctionNode structures.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.resetTreeCliquesForUpSolve!","page":"Caesar's Reference","title":"IncrementalInference.resetTreeCliquesForUpSolve!","text":"resetTreeCliquesForUpSolve!(treel)\n\n\nReset the Bayes (Junction) tree so that a new upsolve can be performed.\n\nNotes\n\nWill change previous clique status from DOWNSOLVED to INITIALIZED only.\nSets the color of tree clique to lightgreen.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.resetVariable!","page":"Caesar's Reference","title":"IncrementalInference.resetVariable!","text":"resetVariable!(varid; solveKey)\n\n\nReset the solve state of a variable to uninitialized/unsolved state.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setfreeze!","page":"Caesar's Reference","title":"IncrementalInference.setfreeze!","text":"setfreeze!(dfg, sym)\n\n\nSet variable(s) sym of factor graph to be marginalized – i.e. not be updated by inference computation.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setValKDE!","page":"Caesar's Reference","title":"IncrementalInference.setValKDE!","text":"setValKDE!(vd, pts, bws)\nsetValKDE!(vd, pts, bws, setinit)\nsetValKDE!(vd, pts, bws, setinit, inferdim)\n\n\nSet the point centers and bandwidth parameters of a variable node, also set isInitialized=true if setinit::Bool=true (as per default).\n\nNotes\n\ninitialized is used for initial solve of factor graph where variables are not yet initialized.\ninferdim is used to identify if the initialized was only partial.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setVariableInitialized!","page":"Caesar's Reference","title":"IncrementalInference.setVariableInitialized!","text":"setVariableInitialized!(varid, status)\n\n\nSet variable initialized status.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setVariableInferDim!","page":"Caesar's Reference","title":"IncrementalInference.setVariableInferDim!","text":"setVariableInferDim!(varid, val)\n\n\nSet method for the inferred dimension value in a variable.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.solveCliq!","page":"Caesar's Reference","title":"IncrementalInference.solveCliq!","text":"solveCliq!(dfgl, tree, cliqid; verbose, recordcliq, async)\n\n\nPerform inference over one clique in the Bayes tree according to opt::SolverParams.\n\nExample\n\ntree = buildTreeReset!(fg)\nsmt, hist = solveCliq!(fg, tree, :x1 [,cliqHistories=hist] )\n\nRelated\n\nsolveTree!, buildTreeReset!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.solveCliqWithStateMachine!","page":"Caesar's Reference","title":"IncrementalInference.solveCliqWithStateMachine!","text":"Standalone state machine solution for a single clique.\n\nRelated:\n\ninitInferTreeUp!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.transferUpdateSubGraph!","page":"Caesar's Reference","title":"IncrementalInference.transferUpdateSubGraph!","text":"transferUpdateSubGraph!(dest, src)\ntransferUpdateSubGraph!(dest, src, syms)\ntransferUpdateSubGraph!(dest, src, syms, logger; updatePPE, solveKey)\n\n\nTransfer contents of src::AbstractDFG variables syms::Vector{Symbol} to dest::AbstractDFG. Notes\n\nReads, dest := src, for all syms\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.treeProductDwn","page":"Caesar's Reference","title":"IncrementalInference.treeProductDwn","text":"treeProductDwn(fg, tree, cliq, sym; N, dbg)\n\n\nCalculate a fresh–-single step–-approximation to the variable sym in clique cliq as though during the downward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variable based on the structure of variables, factors, and incoming messages to this clique. Which clique to be used is defined by frontal variable symbols (cliq in this case) – see getClique(...) for more details.  The sym symbol indicates which symbol of this clique to be calculated.  Note that the sym variable must appear in the clique where cliq is a frontal variable.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.treeProductUp","page":"Caesar's Reference","title":"IncrementalInference.treeProductUp","text":"treeProductUp(fg, tree, cliq, sym; N, dbg)\n\n\nCalculate a fresh (single step) approximation to the variable sym in clique cliq as though during the upward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variables based on the structure of the clique, factors, and incoming messages. Which clique to be used is defined by frontal variable symbols (cliq in this case) – see getClique(...) for more details.  The sym symbol indicates which symbol of this clique to be calculated.  Note that the sym variable must appear in the clique where cliq is a frontal variable.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.unfreezeVariablesAll!","page":"Caesar's Reference","title":"IncrementalInference.unfreezeVariablesAll!","text":"unfreezeVariablesAll!(fgl)\n\n\nFree all variables from marginalization.\n\nRelated\n\ndontMarginalizeVariablesAll!\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.dontMarginalizeVariablesAll!","page":"Caesar's Reference","title":"IncrementalInference.dontMarginalizeVariablesAll!","text":"dontMarginalizeVariablesAll!(fgl)\n\n\nFree all variables from marginalization.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.updateFGBT!","page":"Caesar's Reference","title":"IncrementalInference.updateFGBT!","text":"updateFGBT!(fg, cliq, IDvals; dbg, fillcolor, logger)\n\n\nUpdate cliq cliqID in Bayes (Juction) tree bt according to contents of urt – intended use is to update main clique after a upward belief propagation computation has been completed per clique.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.upGibbsCliqueDensity","page":"Caesar's Reference","title":"IncrementalInference.upGibbsCliqueDensity","text":"upGibbsCliqueDensity(dfg, cliq, inmsgs)\nupGibbsCliqueDensity(dfg, cliq, inmsgs, N)\nupGibbsCliqueDensity(dfg, cliq, inmsgs, N, dbg)\nupGibbsCliqueDensity(dfg, cliq, inmsgs, N, dbg, iters)\nupGibbsCliqueDensity(dfg, cliq, inmsgs, N, dbg, iters, logger)\n\n\nPerform computations required for the upward message passing during belief propation on the Bayes (Junction) tree. This function is usually called as via remote_call for multiprocess dispatch.\n\nNotes\n\nfg factor graph,\ntree Bayes tree,\ncliq which cliq to perform the computation on,\nparent the parent clique to where the upward message will be sent,\nchildmsgs is for any incoming messages from child cliques.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.resetVariableAllInitializations!","page":"Caesar's Reference","title":"IncrementalInference.resetVariableAllInitializations!","text":"resetVariableAllInitializations!(fgl)\n\n\nReset initialization flag on all variables in ::AbstractDFG.\n\nNotes\n\nNumerical values remain, but inference will overwrite since init flags are now false.\n\n\n\n\n\n","category":"function"},{"location":"concepts/concepts/#Caesar-Concepts","page":"Initial Concepts","title":"Caesar Concepts","text":"","category":"section"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"A factor graph is a bipartite representation where variables (denoted by larger nodes) are interconnected by a set of factors (smaller nodes) that represent some algebraic interaction between the variables.  Factors must adhere to the limits of probabilistic models – for example conditional likelihoods (between multiple variables) or priors (unary to one variable).  A more heterogeneous factor graph example is shown below, see a broader discussion in realted literature here:","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"(Image: factorgraphexample).","category":"page"},{"location":"concepts/concepts/#Why/Where-does-non-Gaussian-data-come-from?","page":"Initial Concepts","title":"Why/Where does non-Gaussian data come from?","text":"","category":"section"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"Gaussian error models in measurement or data cues will only be Gaussian (normally distributed) if all physics/decisions/systematic-errors/calibration/etc. has a correct algebraic model in all circumstances.  Caesar.jl and MM-iSAMv2 is heavily focussed on state-estimation from a plethora of heterogenous data that may not yet have perfect algebraic models.  Four major categories of non-Gaussian errors have thus far been considered:","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"Uncertain decisions (a.k.a. data association), such as a robot trying to decide if a navigation loop-closure can be deduced from a repeat observation of a similar object or measurement from current and past data.  These issues are commonly also referred to as multi-hypothesis.\nUnderdetermined or underdefined systems where there are more variables than constraining measurements to fully define the system as a single mode–-a.k.a solution ambiguity.  For example, in 2D consider two range measurements resulting in two possible locations through trilateration.\nNonlinearity.  For example in 2D, consider a Pose2 odometry where the orientation is uncertain:  The resulting belief of where a next pose might be (convolution with odometry factor) results in a banana shape curve, even though the entire process is driven by assumed Gaussian belief.\nPhysics of the measurement process.  Many measurement processes exhibit non-Gaussian behaviour.  For example, acoustic/radio time-of-flight measurements, using either pulse-train or matched filtering, result in an \"energy intensity\" over time/distance of what the range to a scattering-target/source might be–i.e. highly non-Gaussian.","category":"page"},{"location":"concepts/concepts/#What-are-Variables-and-Factors","page":"Initial Concepts","title":"What are Variables and Factors","text":"","category":"section"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"Factor graphs are bipartite, i.e. variables and factors.  The terminology of nodes and edges is reserved for actually storing the data on some graph-based technology.","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"Variables in the factor graph have not been observed, but we want to back them out given the observed values and algebra defining the structure between all observations.  Mathematically speaking, factors are actually \"observed variables\" that are stochastically \"fixed\".  Waving hands over the fact that factors encode both the algebraic model AND the observed measurement values.  If factors are constructed from statistically independent measurements (i.e. no direct correlations between measurements other than the known algebraic model that might connect them), then we can use Probabilistic Chain rule to write inference operation down (unnormalized):","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"P(Theta  Z)  propto  P(Z  Theta) P(Theta)","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"This unnormalized \"Bayes rule\" is a consequence of two ideas, namely the probabilistic chain rule where Theta represents all variables and Z represents all measurements or data","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"P(Theta  Z) = P(Z  Theta) P(Theta)","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"or similarly,","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"P(Theta Z) = P(Theta  Z) P(Z)","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"Second, the uncorrelated measurement process assumption implies that P(Z) constant given the algebraic model.","category":"page"},{"location":"concepts/concepts/#Getting-Started-with-Caesar","page":"Initial Concepts","title":"Getting Started with Caesar","text":"","category":"section"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"This section discusses the various concepts in the Caesar framework.","category":"page"},{"location":"concepts/concepts/#Julia-and-Help","page":"Initial Concepts","title":"Julia and Help","text":"","category":"section"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"When launching the REPL in a terminal or and IDE like VS Code (see link for documtation website):","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"$ julia -O3\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.5.2 (2020-09-23)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"The -O 3 is for level 3 code compilation optimization and is a useful habit for slightly faster execution, but slightly slower first run just-in-time compilation of any new function.","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"To get help with a function, just start with the ? character followed by the function name, e.g.:","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"?sin\n# help?> sin\nsearch: sin sinh sind sinc sinpi sincos sincosd SingleThreaded SingularException asin using isinf asinh asind isinteger isinteractive\n\n  sin(x)\n\n  Compute sine of x, where x is in radians.\n\n  ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\n  sin(A::AbstractMatrix)\n\n  Compute the matrix...","category":"page"},{"location":"concepts/concepts/#Loading-Packages","page":"Initial Concepts","title":"Loading Packages","text":"","category":"section"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"Assuming you just loaded an empty REPL, or at the start of a script, or working inside the VSCode IDE, the first thing to do is load the necessary Julia packages.  Caesar.jl is an umbrella package potentially covering over 100 Julia Packages.  For this reason the particular parts of the code are broken up amongst more focussed vertical purpose library packages.  Usually for Robotics either Caesar or less expansive RoME will do.  Other non-Geometric sensor processing applications might build in the MM-iSAMv2, Bayes tree, and DistributedFactorGraph libraries.  Any of these packages can be loaded as follows:","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"# umbrella containing most functional packages including RoME\nusing Caesar\n# contains the IncrementalInference and other geometric manifold packages\nusing RoME\n# contains among others DistributedFactorGraphs.jl and ApproxManifoldProducts.jl\nusing IncrementalInference","category":"page"},{"location":"concepts/concepts/#Requires.jl-for-Optional-Package-Loading","page":"Initial Concepts","title":"Requires.jl for Optional Package Loading","text":"","category":"section"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"Many of these packages have additional features that are not included by default.  For example, the Flux.jl machine learning package will introduce several additional features when loaded, e.g.:","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"julia> using Flux, RoME\n\n[ Info: IncrementalInference is adding Flux related functionality.\n[ Info: RoME is adding Flux related functionality.","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"For completeness, so too with packages like Images.jl, RobotOS.jl, and others:","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"using Caesar, Images","category":"page"},{"location":"concepts/concepts/#Parallel-Processing","page":"Initial Concepts","title":"Parallel Processing","text":"","category":"section"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"note: Note\nKeywords: parallel processing, multi-threading, multi-process","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"Julia allows high-performance, parallel processing from the ground up.  Depending on the configuration, Caesar.jl can utilize a combination of four styles of multiprocessing: i) separate memory multi-process; ii) shared memory multi-threading; iii) asynchronous shared-memory (forced-atomic) co-routines; and iv) multi-architecture such as JuliaGPU.  As of Julia 1.4, the most reliable method of loading all code into all contexts (for multi-processor speedup) is as follows.","category":"page"},{"location":"concepts/concepts/#Multithreading-and-Multiprocessing","page":"Initial Concepts","title":"Multithreading and Multiprocessing","text":"","category":"section"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"Make sure the environment variable JULIA_NUM_THREADS is set as default or per call and recommended to use 4 as starting point.","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"JULIA_NUM_THREADS=4 julia -O3","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"In addition to multithreading, Caesar.jl utilizes multiprocessing to distribute computation during the inference steps.  Following standard Julia, more processes can be added as follows:","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"# load the required packages into procid()==1\nusing Flux, RoME, Caesar, RoMEPlotting\n\n# then start more processes\nusing Distributed\naddprocs(8) # note this yields 6*8=40 possible processing threads\n\n# now make sure all code is loaded everywhere (for separate memory cases)\n@everywhere using Flux, RoME, Caesar","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"It might also be convenient to warm up some of the Just-In-Time compiling:","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"# solve a few graphs etc, to get majority of solve code compiled before running a robot.\n[warmUpSolverJIT() for i in 1:3];","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"The best way to avoid compile time (when not developing) is to use the established Julia \"first time to plot\" approach based on PackageCompiler.jl, and more details are provided at Ahead of Time compiling, and a few common questions might be answered via FAQ here.","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"The next section describes the initial steps in constructing and solving graphs will be discussed in the upcoming documentation page Building and Solving Graphs.  We also recommend reviewing the various examples available in the Examples section.  The variables and factors in Caesar should be sufficient for the majority of robotic applications, however Caesar allows users to extend the framework without changing the core code. This is discussed in Creating New Variables and Factors.  Caesar supports both in-memory solving (fast, for moderately-sized graphs) as well as shared data persistence and inference for massive graphs, multiple sessions, and multiple agents.","category":"page"},{"location":"concepts/concepts/","page":"Initial Concepts","title":"Initial Concepts","text":"Although Caesar is Julia-based, it provides multi-language support with a ZMQ interface. This is discussed in Caesar Multi-Language Support.  Caesar.jl also supports various visualizations and plots by using Arena, RoMEPlotting, and Director. This is discussed in Visualization with Arena.jl and RoMEPlotting.jl.","category":"page"},{"location":"concepts/entry_data/#Additional-(Large)-Data","page":"Entry=>Data Blob","title":"Additional (Large) Data","text":"","category":"section"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"There are a variety of situations that require more data to be stored natively in the factor graph object. This page will showcase some of Entry=>Data features available.","category":"page"},{"location":"concepts/entry_data/#Adding-A-FolderStore","page":"Entry=>Data Blob","title":"Adding A FolderStore","text":"","category":"section"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"Caesar.jl (with DFG) supports storage and retrieval of larger data blobs by means of various database/datastore technologies.  To get going, you can use a conventional FolderStore: ","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"getSolverParams(fg).logpath = pwd()\nstoreDir = joinLogPath(fg,\"data\")\nmkpath(storeDir)\n# requires IIF v0.15, DFG v0.10\ndatastore = FolderStore{Vector{UInt8}}(:default_folder_store, storeDir) \naddBlobStore!(fg, datastore)","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"note: Note\nThis example places the data folder in the .logpath location which defaults to /tmp/caesar/UNIQUEDATETIME. This is not a long term storage location since /tmp is periodically cleared by the operating system. Note that the data folder can be used in combination with loading and saving factor graph objects.","category":"page"},{"location":"concepts/entry_data/#Adding-Data-Blobs","page":"Entry=>Data Blob","title":"Adding Data Blobs","text":"","category":"section"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"Just showcasing a JSON Dict approach","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"using JSON2\nsomeDict = Dict(:name => \"Jane\", :data => randn(100))\naddData!(fg, :default_folder_store, :x1, :datalabel, Vector{UInt8}(JSON2.write( someDict )), mimeType=\"application/json/octet-stream\"  )\n# see retrieval example below...","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"This approach allows the maximum flexibility, for example it is also possible to do:","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"# from https://juliaimages.org/stable/install/\nusing TestImages, Images, ImageView\nimg = testimage(\"mandrill\")\nimshow(img)\n\n# TODO, convert to Vector{UInt8}\nusing ImageMagick, FileIO\n# convert image to PNG bytestream\nio = IOBuffer()\npngSm = Stream(format\"PNG\", io)\nsave(pngSm, img)  # think FileIO is required for this\npngBytes = take!(io)\naddData!(fg, :default_folder_store, :x1, :testImage, pngBytes, mimeType=\"image/png\", description=\"mandrill test image\"  )","category":"page"},{"location":"concepts/entry_data/#Retrieving-a-Data-Blob","page":"Entry=>Data Blob","title":"Retrieving a Data Blob","text":"","category":"section"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"Data is stored as an Entry => Blob relationship, and the entries associated with a variable can be found via","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"julia> listDataEntries(fg, :x6)\n1-element Array{Symbol,1}:\n :JOYSTICK_CMD_VALS\n :testImage","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"And retrieved via:","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"rawData = getData(fg, :x6, :JOYSTICK_CMD_VALS);\nimgEntry, imgBytes = getData(fg, :x1, :testImage)","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"Looking at rawData in a bit more detail:","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"julia> rawData[1]\nBlobStoreEntry(:JOYSTICK_CMD_VALS, UUID(\"d21fc841-6214-4196-a396-b1d5ef95be49\"), :default_folder_store, \"deeb3ed0cba6ffd149298de21c361af26a207e565e27a3cd3fa6c807b9aaa44d\", \"DefaultUser|DefaultRobot|Session_851d81|x6\", \"\", \"application/json/octet-stream\", TimeZones.ZonedDateTime(2020, 8, 15, 14, 26, 36, 397, tz\"UTC-04:00\"))\n\njulia> rawData[2]\n3362-element Array{UInt8,1}:\n 0x5b\n 0x5b\n 0x32\n#...","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"For :testImage the data was packed in a familiar image/png and can be converted backto bitmap (array) format:","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"rgb = ImageMagick.readblob(imgBytes); # automatically detected as PNG format\n\nusing ImageView\nimshow(rgb)","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"In the other case where data was packed as \"application/json/octet-stream\":","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"myData = JSON2.read(IOBuffer(rawData[2]))\n\n# as example\njulia> myData[1]\n3-element Array{Any,1}:\n                2017\n 1532558043061497600\n                    (buttons = Any[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], axis = Any[0, 0.25026196241378784, 0, 0, 0, 0])","category":"page"},{"location":"concepts/entry_data/#Quick-Camera-Calibration-Storage-Example","page":"Entry=>Data Blob","title":"Quick Camera Calibration Storage Example","text":"","category":"section"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"Consider storing camera calibration data inside the factor graph tar.gz object for later use:","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"fx = 341.4563903808594\nfy = 341.4563903808594\ncx = 329.19091796875\ncy = 196.3658447265625\n\nK = [-fx 0  cx;\n      0 fy cy]\n\n# Cheap way to include data as a Blob.  Also see the more hacky `Smalldata` alternative for situations that make sense.\ncamCalib = Dict(:size=>size(K), :vecK=>vec(K))\naddData!(dfg,:default_folder_store,:x0,:camCalib,\n         Vector{UInt8}(JSON2.write(camCalib)), mimeType=\"application/json/octet-stream\", \n         description=\"reshape(camCalib[:vecK], camCalib[:size]...)\") ","category":"page"},{"location":"concepts/entry_data/#Working-with-Binary-Data-(BSON)","page":"Entry=>Data Blob","title":"Working with Binary Data (BSON)","text":"","category":"section"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"Sometime it's useful to store binary data.  Let's combine the example of storing a Flux.jl Neural Network object using the existing BSON approach.  Also see BSON wrangling snippets here.","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"note: Note\nWe will store binary data as Base64 encoded string to avoid other framing problems.  See Julia Docs on Base64","category":"page"},{"location":"concepts/entry_data/","page":"Entry=>Data Blob","title":"Entry=>Data Blob","text":"# the object you wish to store as binary\nmodel = Chain(Dense(5,2), Dense(2,3))\n\nio = IOBuffer()\n\n# using BSON\nBSON.@save io model\n\n# get base64 binary\nmdlBytes = take!(io)\n\naddData!(dfg,:default_folder_store,:x0,:nnModel,\n         mdlBytes, mimeType=\"application/bson/octet-stream\", \n         description=\"BSON.@load PipeBuffer(readBytes) model\") ","category":"page"},{"location":"concepts/flux_factors/#Incorporating-Neural-Network-Factors","page":"Flux (NN) Factors","title":"Incorporating Neural Network Factors","text":"","category":"section"},{"location":"concepts/flux_factors/","page":"Flux (NN) Factors","title":"Flux (NN) Factors","text":"IncrementalInference.jl and RoME.jl has native support for using Neural Networks (via Flux.jl) as non-Gaussian factors.  Documentation is forthcoming, but meanwhile see the following generic Flux.jl factor structure.  Note also that a standard Mixture approach already exists too.","category":"page"},{"location":"principles/initializingOnBayesTree/#Advanced-Topics-on-Bayes-Tree","page":"Advanced Bayes Tree Topics","title":"Advanced Topics on Bayes Tree","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/#Definitions","page":"Advanced Bayes Tree Topics","title":"Definitions","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Squashing or collapsing the Bayes tree back into a 'flat' Bayes net, by chain rule: ","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"p(xy) = p(xy)p(y) = p(yx)p(x) \np(xyz) = p(xyz)p(yz) = p(xyz)p(z) = p(xyz)p(yz)p(z) \np(xyz) = p(xyz)p(y)p(z)  textiff y is independent of z  also p(yz)=p(y)","category":"page"},{"location":"principles/initializingOnBayesTree/#Are-cliques-in-the-Bayes-(Junction)-tree-densly-connected?","page":"Advanced Bayes Tree Topics","title":"Are cliques in the Bayes (Junction) tree densly connected?","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Yes and no. From the chordal Bayes net's perspective (obtained through the elimination game in order to build the clique tree), the nodes of the Bayes tree are indeed fully connected subgraphs (they are called cliques after all!). From the perspective of the subgraph of the original factor graph induced by the clique's variables, cliques need not be fully connected, since we are assuming the factor graph as sparse, and that no new information can be created out of nothing–-hence each clique must be sparse.  That said, the potential exists for the inference within a clique to become densly connected (experience full \"fill-in\").  See the paper on square-root-SAM, where the connection between dense covariance matrix of a Kalman filter (EKF-SLAM) is actually related to the inverse square root (rectangular) matrix which structure equivalent to the clique subgraph adjacency matrix.  ","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Also remember that the intermediate Bayes net (which has densly connected cliques) hides the underlying tree structure – think of the Bayes net as looking at the tree from on top or below, thereby encoding the dense connectivity in the structure of the tree itself.  All information below any clique of the tree is encoded in the upward marginal belief messages at that point (i.e. the densly connected aspects pertained lower down in the tree).","category":"page"},{"location":"principles/initializingOnBayesTree/#LU/QR-vs.-Belief-Propagation","page":"Advanced Bayes Tree Topics","title":"LU/QR vs. Belief Propagation","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"LU/QR is a special case (Parametric/Linear) of more general belief propagation.  The story though is more intricate, where QR/LU assume that product-factors can be formed through the chain rule – using congruency – it is not that straight forward with general beliefs.  In the general case we are almost forced to use belief propagation, which in turn implies special care is needed to describe the relationship between sparse factor graph fragments in cliques on the tree, and the more densely connected structure of the Bayes Net.","category":"page"},{"location":"principles/initializingOnBayesTree/#Bayes-Tree-vs-Bayes-Net","page":"Advanced Bayes Tree Topics","title":"Bayes Tree vs Bayes Net","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"The Bayes tree is a purely symbolic structure – i.e. special grouping of factors that all come from the factor graph joint product (product of independently sampled likelihood/conditional models):","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Theta  Z propto prod_i   Z_i=z_i  Theta_i ","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"A sparse factor graph problem can be squashed into smaller dense problem of product-factor conditionals (from variable elimination).  Therefore each product-factor (aka \"smart factor\" in other uses of the language) represent both the factors as well as the sequencing of cliques in that branch.  This process repeats recursively from the root down to the leaves.  The leaves of the tree have no further reduced product factors condensing child cliques below, and therefore sparse factor fragments can be computed to start the upward belief propagation process.  More importantly, as belief propagation progresses up the tree, upward belief messages (on clique separators) capture the same structure as the densely connected Bayes net but each clique in the Bayes tree still only contains sparse fragments from the original factor graph.  The structure of the tree (combined parent-child relationships) encodes the same information as the product-factor conditionals!","category":"page"},{"location":"principles/initializingOnBayesTree/#Initialization-on-the-Tree","page":"Advanced Bayes Tree Topics","title":"Initialization on the Tree","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"It more challenging but possible to initialize all variables in a factor graph through belief propagation on the Bayes tree.","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"As a thought experiment: Wouldn't it be awesome if we could compile the upsolve as a symbolic process only, and only assign numerical values once during a single downsolve procedure.  The origin of this idea comes from the realization that a complete upsolve on the Bayes (Junction) tree is very nearly the same thing finding good numerical initialization values for the factor graph.  If the up-init-solve can be performed as a purely symbolic process, it would greatly simplify numerical computations by deferring them to the down solve alone.","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Trying to do initialization for real, we might want to replace up-init-symbolic operations with numerical equivalents.  Either way, it would be worth knowing what the equivalent numerical operations of a full up-init-solve of an uninitialized factor graph would look like.","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"In general, if a clique can not be initialized based on information from lower down in that branch of the tree; more information is need from the parent.  In the Gaussian (more accurately the congruent factor) case, all information lower down in the branch–-i.e. the relationships between variables in parent–-can be summarized by a new conditional product-factor that is computed with the probabilistic chain rule.  To restate, the process of squashing the Bayes tree branch back down into a Bayes net, is effectively the the chain rule process used in variable elimination.","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"note: Note\nQuestion, are cascading up and down solves are required if you do not use eliminated factor conditionals in parent cliques.","category":"page"},{"location":"principles/initializingOnBayesTree/#Gaussian-only-special-case","page":"Advanced Bayes Tree Topics","title":"Gaussian-only special case","text":"","category":"section"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"Elimination of variables and factors using chain rule reduction is a special case of belief propagation, and thus far only the reduction of congruent beliefs (such as Gaussian) is known.","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"These computations can be parallelized depending on the conditional independence structure of the Bayes tree – separate branches are effectively separate chain rule instances.  This is precisely the same process exploited by multi-frontal QR matrix factorization.","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"On the down solve the conditionals–-from eliminated chains of previously eliminated variables and factors–-can be used for inference directly in the parent.  ","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"See node x1 to x3 in IncrementalInference issue 464. It does not branch or provide additional prior information. so it is collapsed into one factor between x1 and x3, solved in the root and the individual variable can be solved by inference.","category":"page"},{"location":"principles/initializingOnBayesTree/","page":"Advanced Bayes Tree Topics","title":"Advanced Bayes Tree Topics","text":"note: Note\nQuestion, what does the Jacobian in Gaussian only case mean with regard to a symbolic upsolve?","category":"page"},{"location":"faq/#Frequently-Asked-Questions","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#Factor-Graphs:-why-not-just-filter?","page":"FAQ","title":"Factor Graphs: why not just filter?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Why can't I just filter, or what is the connection with FGs? See the \"Principles\" section in the documentation. ","category":"page"},{"location":"faq/#Why-worry-about-non-Gaussian-Probabilities","page":"FAQ","title":"Why worry about non-Gaussian Probabilities","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The non-Gaussian/multimodal section in the docs is dedicated to precisely this question.","category":"page"},{"location":"faq/#Why-Julia","page":"FAQ","title":"Why Julia","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The JuliaLang and (JuliaPro) is an open-source Just-In-Time (JIT) & optionally precompiled, strongly-typed, and high-performance programming language. The algorithmic code is implemented in Julia for many reasons, such as agile development, high level syntax, performance, type safety, multiple dispatch replacement for object oriented which exhibits several emergent properties, parallel computing, dynamic development, cross compilable (with gcc and clang) and foundational cross-platform (LLVM) technologies.   See JuliaCon2018 highlights video.  Julia can be thought of as either {C+, Mex (done right), or as a modern Fortran replacement}.","category":"page"},{"location":"faq/#Current-Julia-version?","page":"FAQ","title":"Current Julia version?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Caesar.jl and packages are currently targeting Julia version as per the local install page.","category":"page"},{"location":"faq/#Just-In-Time-Compiling-(i.e.-why-are-first-runs-slow?)","page":"FAQ","title":"Just-In-Time Compiling (i.e. why are first runs slow?)","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Julia uses just-in-time compilation (unless already pre-compiled)  which takes additional time the first time a new function is called. Additional calls to a cached function are fast from the second call onwards since the static binary code is now cached and ready for use.","category":"page"},{"location":"faq/#How-does-garbage-collection-work?","page":"FAQ","title":"How does garbage collection work?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"A short description of Julia's garbage collection is described in Discourse here.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"note: Note\nGarbage collection can be influenced in a few ways to allow more certainty about operational outcome, see the Julia Docs Garbage Collection Internal functions like enable, preserve, safepoint, etc.","category":"page"},{"location":"faq/#Using-Julia-in-real-time-systems?","page":"FAQ","title":"Using Julia in real-time systems?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"See the JuliaCon presentation by rdeits here.","category":"page"},{"location":"faq/#Can-Caesar.jl-be-used-in-other-languages-beyond-Julia?-Yes.","page":"FAQ","title":"Can Caesar.jl be used in other languages beyond Julia? Yes.","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The Caesar.jl project is expressly focused on making this algorithmic code available to C/Fortran/C++/C#/Python/Java/JS.  Julia itself offers many additional interops.  ZMQ and HTTP/WebSockets are the standardized interfaces of choice, please see details at the multi-language section).  Consider opening issues or getting in touch for more information.","category":"page"},{"location":"faq/#Static,-Shared-Object-.so-Compilation","page":"FAQ","title":"Static, Shared Object .so Compilation","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Packages are already compiled to static objects (.ji files), but can also be compiled to more common .so files.  See this AOT vs JIT compiling blog post for a deeper discussion.  Also see this Julia Binaries Blog.  See recent dedicated issue tracker here.  Initial work is for system image is described in the docs here.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"note: Note\nrecent developments announced on discourse..  Also see new brute force sysimg work at Fezzik.jl.","category":"page"},{"location":"faq/#Can-Julia-be-Embedded-into-C/C","page":"FAQ","title":"Can Julia be Embedded into C/C++","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Yes, see the Julia embedding documentation page.","category":"page"},{"location":"faq/#ROS-Integration","page":"FAQ","title":"ROS Integration","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"ROS and ZMQ interfaces are closely related.  Please see the ROS Integration Page for details on using ROS with Caesar.jl.","category":"page"},{"location":"faq/#Why-ZMQ-Middleware-Layer-(multilang)?","page":"FAQ","title":"Why ZMQ Middleware Layer (multilang)?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Zero Message Queue (ZMQ) is a widely used data transport layer used to build various other multiprocess middleware with wide support among other programming languages.  Caesar.jl has on been used with a direct ZMQ type link, which is similar to a ROS workflow.  Contributions are welcome for binding ZMQ endpoints for a non-ROS messaging interface.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Note ZMQ work has been happening on and off based on behind the main priority on resolving abstractions with the DistributedFactorGraphs.jl framework.  See ongoing work for the ZMQ interface.","category":"page"},{"location":"faq/#What-is-supersolve?","page":"FAQ","title":"What is supersolve?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"When multiple numerical values/solutions exists for the (or nearly) same factor graph – then solutions, including a reference solution (ground truth) can just be stacked in that variable.  See and comment on a few cases here.","category":"page"},{"location":"faq/#Variable-Scope-in-For-loop-Error","page":"FAQ","title":"Variable Scope in For loop Error","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Julia wants you to be specific about global variables, and variables packed in a development script at top level are created as globals.  Globals can be accessed using the global varname at the start of the context.  When writing for loops (using Julia versions 0.7 through 1.3) stricter rules on global scoping applied.  The purest way to ensure scope of variables are properly managed in the REPL or Juno script Main context is using the let syntax (not required post Julia 1.4).","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"fg = ...\ntree, smt, hist = solveTree!(fg)\n...\n# and then a loop here:\nlet tree=tree, fg=fg\nfor i 2:100\n   # global tree, fg # forcing globals is the alternative\n   # add variables and stuff\n   ...\n   # want to solve again\n   tree, smt, hist = solveTree!(fg, tree)\n   ...\n   # more stuff\nend\nend # let block","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"See Stack overflow on let or the Julia docs page on scoping.  Also note it is good practice to use local scope (i.e. inside a function) variables for performance reasons.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"note: Note\nThis behaviour is going to change in Julia 1.5 back to what Julia 0.6 was in interactive cases, and therefore likely less of a problem in future versions.  See Julia 1.5 Change Notes, ([#28789], [#33864]).","category":"page"},{"location":"faq/#How-to-Enable-@debug-Logging.jl","page":"FAQ","title":"How to Enable @debug Logging.jl","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"https://stackoverflow.com/questions/53548681/how-to-enable-debugging-messages-in-juno-julia-editor","category":"page"},{"location":"faq/#Julia-Images.jl-Axis-Convention","page":"FAQ","title":"Julia Images.jl Axis Convention","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Julia Images.jl follows the common `::Array column-major–-i.e. vertical-major–-index convention","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"That is img[vertical, horizontal]\nSee https://evizero.github.io/Augmentor.jl/images/#Vertical-Major-vs-Horizontal-Major-1 for more details.\nAlso, https://juliaimages.org/latest/pkgs/axes/#Names-and-locations","category":"page"},{"location":"faq/#How-does-JSON-Schema-work?","page":"FAQ","title":"How does JSON-Schema work?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Caesar.jl intends to follow json-schema.org, see step-by-step guide here.","category":"page"},{"location":"faq/#How-to-get-Julia-memory-allocation-points?","page":"FAQ","title":"How to get Julia memory allocation points?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"See discourse discussion.","category":"page"},{"location":"faq/#Increase-Linux-Open-File-Limit?","page":"FAQ","title":"Increase Linux Open File Limit?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you see the error \"Open Files Limit\", please follow these intructions on your local system.  This is likely to happen when debug code and a large number of files are stored in the general solution specific logpath.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Hexagonal-2D-with-Fixed-Lag-Solving","page":"Fixed-Lag Solving 2D","title":"Hexagonal 2D with Fixed-Lag Solving","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"note: Note\nThis feature has recently been updated and the documentation below needs to be updated.  The new interface is greatly simplified from the example below.  The results presented below are also out of date, new performance figures are expected to be faster (2Q2020).  ","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"This example provides an overview of how to enable it and the benefits of using fixed-lag solving. The objective is to provide a near-constant solve time for ever-growing graphs by only recalculating the most recent portion. Think of this as a placeholder, as we develop the solution this tutorial will be updated to demonstrate how that is achieved.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Example-Code","page":"Fixed-Lag Solving 2D","title":"Example Code","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"The complete code for this example can be found in the fixed-lag branch of RoME: Hexagonal Fixed-Lag Example.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Introduction","page":"Fixed-Lag Solving 2D","title":"Introduction","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Fixed-lag solving is enabled when creating the factor-graph. Users provide a window–-the quasi fixed-lag constant (QFL)–-which defines how many of the most-recent variables should be calculated. Any other variables are 'frozen.' The objective of this example is to explore providing a near-constant solve time for ever-growing graphs by only recalculating the most recent portion.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Example-Overview","page":"Fixed-Lag Solving 2D","title":"Example Overview","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"In the example, the basic Hexagonal 2D is grown to solve 200 variables. The original example remains the same, i.e., a vehicle is driving around in a hexagon and seeing the same bearing+range landmark as it crosses the starting point. At every 20th variable, a solve is invoked. Rather than use solveTree!(fg), the solve is performed in parts (construction of Bayes tree, solving the graph) to get performance statistics as the graph grows.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"numVariables = 200\nsolveEveryNVariables = 20\nlagLength = 30\n\n# Standard Hexagonal example for totalIterations - solve every iterationsPerSolve iterations.\nfunction runHexagonalExample(fg::G, totalIterations::Int, iterationsPerSolve::Int)::DataFrame where {G <: AbstractDFG}\n    # Add the first pose :x0\n    addVariable!(fg, :x0, Pose2)\n\n    # dummy tree used later for incremental updates\n    tree = wipeBuildNewTree!(fg)\n\n    # Add at a fixed location PriorPose2 to pin :x0 to a starting location\n    addFactor!(fg, [:x0], PriorPose2(MvNormal(zeros(3), 0.01*Matrix{Float64}(LinearAlgebra.I, 3,3))))\n\n    # Add a landmark l1\n    addVariable!(fg, :l1, Point2, tags=[:LANDMARK])\n\n    # Drive around in a hexagon a number of times\n    solveTimes = DataFrame(GraphSize = [], TimeBuildBayesTree = [], TimeSolveGraph = [])\n    for i in 0:totalIterations\n        psym = Symbol(\"x$i\")\n        nsym = Symbol(\"x$(i+1)\")\n        @info \"Adding pose $nsym...\"\n        addVariable!(fg, nsym, Pose2)\n        pp = Pose2Pose2(MvNormal([10.0;0;pi/3], Matrix(Diagonal( [0.1;0.1;0.1].^2 ) )))\n        @info \"Adding odometry factor between $psym -> $nsym...\"\n        addFactor!(fg, [psym;nsym], pp )\n\n        if i % 6 == 0\n            @info \"Creating factor between $psym and l1...\"\n            p2br = Pose2Point2BearingRange(Normal(0,0.1),Normal(20.0,1.0))\n            addFactor!(fg, [psym; :l1], p2br)\n        end\n        if i % iterationsPerSolve == 0 && i != 0\n            @info \"Performing inference!\"\n            if getSolverParams(fg).isfixedlag\n                @info \"Quasi fixed-lag is enabled (a feature currently in testing)!\"\n                fifoFreeze!(fg)\n            end\n            tInfer = @timed tree, smt, hist = solveTree!(fg, tree)\n            graphSize = length([ls(fg)[1]..., ls(fg)[2]...])\n            push!(solveTimes, (graphSize, tInfer[2], tInfer[2]))\n        end\n    end\n    return solveTimes\nend","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Two cases are set up:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"One solving the full graph every time a solve is performed:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"# start with an empty factor graph object\nfg = initfg()\n# DO NOT enable fixed-lag operation\nsolverTimesForBatch = runHexagonalExample(fg, numVariables, solveEveryNVariables)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"The other enabling fixed-lag with a window of 20 variables:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"fgFixedLag = initfg()\nfgFixedLag.solverParams.isfixedlag = true\nfgFixedLag.solverParams.qfl = lagLength\n\nsolverTimesFixedLag = runHexagonalExample(fgFixedLag, numVariables, solveEveryNVariables)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"The resultant path of the robot can be seen by using RoMEPlotting and is drawn if the visualization lines are uncommented:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"#### Visualization\n\n# Plot the many iterations to see that it succeeded.\n# Batch\n# drawPosesLandms(fg)\n\n# Fixed lag\n# drawPosesLandms(fgFixedLag)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Lastly, the timing results of both scenarios are merged into a single DataFrame table, exported to CSV, and a summary graph is shown using GadFly.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"using Gadfly\nusing Colors\nusing CSV\n\n# Make a clean dataset\nrename!(solverTimesForBatch, :TimeBuildBayesTree => :Batch_BayedBuild, :TimeSolveGraph => :Batch_SolveGraph);\nrename!(solverTimesFixedLag, :TimeBuildBayesTree => :FixedLag_BayedBuild, :TimeSolveGraph => :FixedLag_SolveGraph);\ntimingMerged = DataFrames.join(solverTimesForBatch, solverTimesFixedLag, on=:GraphSize)\nCSV.write(\"timing_comparison.csv\", timingMerged)\n\nPP = []\npush!(PP, Gadfly.layer(x=timingMerged[:GraphSize], y=timingMerged[:FixedLag_SolveGraph], Geom.path, Theme(default_color=colorant\"green\"))[1]);\npush!(PP, Gadfly.layer(x=timingMerged[:GraphSize], y=timingMerged[:Batch_SolveGraph], Geom.path, Theme(default_color=colorant\"magenta\"))[1]);\n\nplt = Gadfly.plot(PP...,\n    Guide.title(\"Solving Time vs. Iteration for Fixed-Lag Operation\"),\n    Guide.xlabel(\"Solving Iteration\"),\n    Guide.ylabel(\"Solving Time (seconds)\"),\n    Guide.manual_color_key(\"Legend\", [\"fixed\", \"batch\"], [\"green\", \"magenta\"]))\nGadfly.draw(PNG(\"results_comparison.png\", 12cm, 15cm), plt)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Results","page":"Fixed-Lag Solving 2D","title":"Results","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"warning: Warning\nNote these results are out of date, much improved performance is possible and work is in progress to improve the documentation around this feature.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Preliminary results for the comparison can be seen below. However, this is just a start and we need to perform more testing. At the moment we are working on providing consistent results and further improving performance/flattening the fixed-lag time. It should be noted that the below graph is not to demonstrate the absolute solve time, but rather the relative behavior of full-graph solve vs. fixed-lag.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"(Image: Timing comparison of full solve vs. fixed-lag)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"NOTE Work is underway (aka \"Project Tree House\") to reduce overhead computations that result in poorer fixed-lag solving times.  We expect the fixed-lag performance to improve in the coming months (Written Nov 2018).  Please file issues if a deeper discussion is required.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Additional-Example","page":"Fixed-Lag Solving 2D","title":"Additional Example","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Work In Progress, but In the mean time see the following examples:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"https://github.com/JuliaRobotics/Caesar.jl/blob/master/examples/wheeled/racecar/apriltagandzed_slam.jl","category":"page"},{"location":"examples/basic_hexagonal2d/#Hexagonal-2D-SLAM-Example-(Local-Compute)","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM Example (Local Compute)","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"A simple 2D robot trajectory example is expanded below using techniques developed in simultaneous localization and mapping (SLAM). This example is available as a single script here.","category":"page"},{"location":"examples/basic_hexagonal2d/#Creating-the-Factor-Graph-with-Pose2","page":"Hexagonal 2D SLAM","title":"Creating the Factor Graph with Pose2","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"The first step is to load the required modules, and in our case we will add a few Julia processes to help with the compute later on.  ","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# add more julia processes\nnprocs() < 4 ? addprocs(4-nprocs()) : nothing\n\n# tell Julia that you want to use these modules/namespaces\nusing RoME, Distributions, LinearAlgebra","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"After loading the RoME and Distributions modules, we construct a local factor graph object in memory:","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# start with an empty factor graph object\nfg = initfg()\n\n# Add the first pose :x0\naddVariable!(fg, :x0, Pose2)\n\n# Add at a fixed location PriorPose2 to pin :x0 to a starting location\naddFactor!(fg, [:x0], PriorPose2(MvNormal(zeros(3), 0.01*Matrix(LinearAlgebra.I,3,3))) )","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"A factor graph object fg (of type <:AbstractDFG) has been constructed; the first pose :x0 has been added; and a prior factor setting the origin at [0,0,0] over variable node dimensions [x,y,θ] in the world frame. The type Pose2 is used to indicate what variable is stored in the node. Caesar.jl allows a little more freedom in how factor and variable nodes can be connected, while still allowing for type-assertion to occur.","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"NOTE Julia uses just-in-time compilation (unless pre-compiled)  which is slow the first time a function is called but fast from the second call onwards, since the static function is now cached and ready for use.","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"The next 6 nodes are added with odometry in an counter-clockwise hexagonal manner. Note how variables are denoted with symbols, :x2 == Symbol(\"x2\"):","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# Drive around in a hexagon\nfor i in 0:5\n  psym = Symbol(\"x$i\")\n  nsym = Symbol(\"x$(i+1)\")\n  addVariable!(fg, nsym, Pose2)\n  pp = Pose2Pose2(MvNormal([10.0;0;pi/3], Matrix(Diagonal([0.1;0.1;0.1].^2))))\n  addFactor!(fg, [psym;nsym], pp )\nend","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"At this point it would be good to see what the factor graph actually looks like:","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"drawGraph(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"You should see the program evince open with this visual:","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: exfg2d)","category":"page"},{"location":"examples/basic_hexagonal2d/#Performing-Inference","page":"Hexagonal 2D SLAM","title":"Performing Inference","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"Let's run the multimodal-incremental smoothing and mapping (mm-iSAM) solver against this fg object:","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# perform inference, and remember first runs are slower owing to Julia's just-in-time compiling\ntree, smt, hist = solveTree!(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"This will take a couple of seconds (including first time compiling for all Julia processes).  If you wanted to see the Bayes tree operations during solving, set the following parameters before calling the solver:","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"getSolverParams(fg).drawtree = true\ngetSolverParams(fg).showtree = true","category":"page"},{"location":"examples/basic_hexagonal2d/#Some-Visualization-Plot","page":"Hexagonal 2D SLAM","title":"Some Visualization Plot","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"2D plots of the factor graph contents is provided by the RoMEPlotting package. See further discussion on visualizations and packages here.","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"## Inter-operating visualization packages for Caesar/RoME/IncrementalInference exist\nusing RoMEPlotting\n\n# For Juno/Jupyter style use\npl = drawPoses(fg)\n\n# For scripting use-cases you can export the image\npl |> Gadfly.PDF(\"/tmp/test.pdf\") # or PNG(...)","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: test)","category":"page"},{"location":"examples/basic_hexagonal2d/#Adding-Landmarks-as-Point2","page":"Hexagonal 2D SLAM","title":"Adding Landmarks as Point2","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"Suppose some sensor detected a feature of interest with an associated range and bearing measurement. The new variable and measurement can be included into the factor graph as follows:","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# Add landmarks with Bearing range measurements\naddVariable!(fg, :l1, Point2, tags=[:LANDMARK;])\np2br = Pose2Point2BearingRange(Normal(0,0.1),Normal(20.0,1.0))\naddFactor!(fg, [:x0; :l1], p2br)\n\n# Initialize :l1 numerical values but do not rerun solver\nensureAllInitialized!(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"NOTE The default behavior for initialization of variable nodes implies the last variable node added will not have any numerical values yet, please see ContinuousScalar Tutorial for deeper discussion on automatic initialization (autoinit). A slightly expanded plotting function will draw both poses and landmarks (and currently assumes labels starting with :x and :l respectively)–-notice the new landmark bottom right:","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"drawPosesLandms(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: test)","category":"page"},{"location":"examples/basic_hexagonal2d/#One-type-of-Loop-Closure","page":"Hexagonal 2D SLAM","title":"One type of Loop-Closure","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"Loop-closures are a major part of SLAM based state estimation. One illustration is to take a second sighting of the same :l1 landmark from the last pose :x6; followed by repeating the inference and re-plotting the result–-notice the tighter confidences over all variables:","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# Add landmarks with Bearing range measurements\np2br2 = Pose2Point2BearingRange(Normal(0,0.1),Normal(20.0,1.0))\naddFactor!(fg, [:x6; :l1], p2br2)\n\n# solve\ntree, smt, hist = solveTree!(fg, tree)\n\n# redraw\npl = drawPosesLandms(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: test)","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"This concludes the Hexagonal 2D SLAM example.","category":"page"},{"location":"examples/basic_hexagonal2d/#Interest:-The-Bayes-(Junction)-tree","page":"Hexagonal 2D SLAM","title":"Interest: The Bayes (Junction) tree","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"The Bayes (Junction) tree is used as an acyclic (has no loops) computational object, an exact algebraic refactorizating of factor graph, to perform the associated sum-product inference. The visual structure of the tree can be extracted by modifying the command tree = wipeBuildNewTree!(fg, drawpdf=true) to produce representations such as this in bt.pdf.","category":"page"},{"location":"examples/basic_hexagonal2d/","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: exbt2d)","category":"page"},{"location":"concepts/multisession/#Multisession-Operation","page":"Multi-session/agent Solving","title":"Multisession Operation","text":"","category":"section"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Having all the data consolidated in a factor graph allows us to do something we find really exciting: reason against data for different robots, different robot sessions, even different users. Of course, this is all optional, and must be explicitly configured, but if enabled, current inference solutions can make use of historical data to continually improve their solutions.","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Consider a single robot working in a common environment that has driven around the same area a number of times and has identified a landmark that is (probably) the same. We can automatically close the loop and use the information from the prior data to improve our current solution. This is called a multisession solve.","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"To perform a multisession solve, you need to specify that a session is part of a common environment, e.g 'lab'. A user then requests a multisession solve (manually for the moment), and this creates relationships between common landmarks. The collective information is used to produce a consensus on the shared landmarks. A chain of session solves is then created, and the information is propagated into the individual sessions, improving their results.","category":"page"},{"location":"concepts/multisession/#Steps-in-Multisession-Solve","page":"Multi-session/agent Solving","title":"Steps in Multisession Solve","text":"","category":"section"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"The following steps are performed by the user:","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Indicate which sessions are part of a common environment - this is done via GraffSDK when the session is created\nRequest a multisession solve","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Upon request, the solver performs the following actions:","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Updates the common existing multisession landmarks with any new information (propagation from session to common information)\nBuilds common landmarks for any new sessions or updated data\nSolves the common, multisession graph\nPropagates the common consensus result to the individual sessions\nFreezes all the session landmarks so that the session solving does not update the consensus result\nRequests session solves for all the updated sessions","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Note the current approach is well positioned to transition to the \"Federated Bayes (Junction) Tree\" multisession solving method, and will be updated accordingly in due coarse.  The Federated method will allow faster multi-session solving times by avoiding the current iterated approach.","category":"page"},{"location":"concepts/multisession/#Example","page":"Multi-session/agent Solving","title":"Example","text":"","category":"section"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Consider three sessions which exist in the same, shared environment. In this environment, during each session the robot identified the same l0 landmark, as shown in the below figure. (Image: Independent Sessions)","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"If we examine this in terms of the estimates of the actual landmarks, we have three independent densities (blue, green, and orange) giving measures of l0 located at (20, 0):","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"(Image: Independent densities)","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"Now we trigger a multisession solve. For each landmark that is seen in multiple session, we produce a common landmark (we call a prime landmark) and link it to the session landmarks via factors - all denoted in black outline.","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"(Image: Linked landmarks)","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"A multisession solve is performed, which for each common (prime) landmark, we produce a common estimate. In terms of densities, this is a single answer for the disparate information, as shown in red in the below figure (for a slightly different dataset):","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"(Image: Prime density)","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"This information is then propagated back to the individual session landmarks, giving one common density for each landmark. As above, our green, blue, and orange individual densities are now all updated to match the consensus shown in black:","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"(Image: Prime density)","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"The session landmarks are then frozen, and individual session solves are triggered to propagate the information back into the sessions.  Until the federated upgrade is completed, the above process is iterated a few times to allow information to cross propagate through all sessions.  There federated tree solution requires only a single iteration up and down the federated Bayes (Junction) tree. ","category":"page"},{"location":"concepts/multisession/#Next-Steps","page":"Multi-session/agent Solving","title":"Next Steps","text":"","category":"section"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"This provides an initial implementation for stitching data from multiple sessions, robots, and users. In the short term, we may trigger this automatically for any shared environments.  Multisession solving along with other automated techniques for additional measurement discovery in data allows the system to 'dream' – i.e. reducing succint info from the large volumes of heterogenous sensor data.","category":"page"},{"location":"concepts/multisession/","page":"Multi-session/agent Solving","title":"Multi-session/agent Solving","text":"In the medium future we will extend this functionality to operate in the Bayes tree, which we call 'federated solving', so that we perform the operation using cached results of subtrees. ","category":"page"},{"location":"principles/multiplyingDensities/#Principle:-Multiplying-Functions-(Python)","page":"Multiplying Functions (.py)","title":"Principle: Multiplying Functions (Python)","text":"","category":"section"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"This example illustrates a central concept in Caesar.jl (and the multimodal-iSAM algorithm), whereby different probability belief functions are multiplied together. The true product between various likelihood beliefs is very complicated to compute, but a good approximations exist. In addition, ZmqCaesar offers a ZMQ interface to the factor graph solution for multilanguage support.  This example is a small subset that shows how to use the ZMQ infrastructure, but avoids the larger factor graph related calls.","category":"page"},{"location":"principles/multiplyingDensities/#Products-of-Infinite-Objects-(Functionals)","page":"Multiplying Functions (.py)","title":"Products of Infinite Objects (Functionals)","text":"","category":"section"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Consider multiplying multiple belief density functions together, for example","category":"page"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"f = f_1 times f_2 times f_3","category":"page"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"which is a core operation required for solving the Chapman-Kolmogorov transit equations.","category":"page"},{"location":"principles/multiplyingDensities/#Direct-Julia-Calculation","page":"Multiplying Functions (.py)","title":"Direct Julia Calculation","text":"","category":"section"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"The ApproxManifoldProducts.jl package (experimental) is meant to unify many on-manifold product operations, and can be called directly in Julia:","category":"page"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"using ApproxManifoldProducts\n\nf1 = manikde!(randn(100,1).-3.0, (:Euclid,))\nf2 = manikde!(randn(100,1).+3.0, (:Euclid,))\n...\n\nf12 = maniproduct([f1;f2], (:Euclid,))","category":"page"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Also see previous KernelDensityEstimate.jl.","category":"page"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"To make Caesar.jl usable from other languages, a ZMQ server interface model has been developed which can also be used to test this principle functional product operation.","category":"page"},{"location":"principles/multiplyingDensities/#Not-Susceptible-to-Particle-Depletion","page":"Multiplying Functions (.py)","title":"Not Susceptible to Particle Depletion","text":"","category":"section"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"The product process of say f1*f2 is not a importance sampling procedure that is commonly used in particle filtering, but instead a more advanced Bayesian inference process based on a wide variety of academic literature.  The KernelDensityEstimate method is a stochastic method, what active research is looking into deterministic homotopy/continuation methods.","category":"page"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"The easy example that demonstrates that particle depletion is avoided here, is where f1 and f2 are represented by well separated and evenly weighted samples – the Bayesian inference 'product' technique efficiently produces new (evenly weighted) samples for f12 somewhere in between f1 and f2, but clearly not overlapping the original population of samples used for f1 and f2.  In contrast, conventional particle filtering measurement updates would have \"de-weighted\" particles of either input function and then be rejected during an eventual resampling step, thereby depleting the sample population.","category":"page"},{"location":"principles/multiplyingDensities/#Starting-the-ZMQ-server","page":"Multiplying Functions (.py)","title":"Starting the ZMQ server","text":"","category":"section"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Caesar.jl provides a startup script for a default ZMQ instance.  Start a server and allow precompilations to finish, as indicated by a printout message \"waiting to receive...\".  More details here.","category":"page"},{"location":"principles/multiplyingDensities/#Functional-Products-via-Python","page":"Multiplying Functions (.py)","title":"Functional Products via Python","text":"","category":"section"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Clone the Python GraffSDK.py code here and look at the product.py file.","category":"page"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"import sys\nsys.path.append('..')\n\nimport numpy as np\nfrom graff.Endpoint import Endpoint\nfrom graff.Distribution.Normal import Normal\nfrom graff.Distribution.SampleWeights import SampleWeights\nfrom graff.Distribution.BallTreeDensity import BallTreeDensity\n\nfrom graff.Core import MultiplyDistributions\n\nimport matplotlib.pyplot as plt\n\nif __name__ == '__main__':\n    e = Endpoint()\n\n    e.Connect('tcp://192.168.0.102:5555')\n    print(e.Status())\n\n    N = 1000\n    u1 = 0.0\n    s1 = 10.0\n    x1 = u1+s1*np.random.randn(N)\n\n    u2 = 50.0\n    s2 = 10.0\n    x2 = u2+s2*np.random.randn(N)\n    b1 = BallTreeDensity('Gaussian', np.ones(N), np.ones(N), x1)\n    b2 = BallTreeDensity('Gaussian', np.ones(N), np.ones(N), x2)\n\n    rep = MultiplyDistributions(e, [b1,b2])\n    print(rep)\n    x = np.array(rep['points'] )\n    # plt.stem(x, np.ones(len(x)) )\n    plt.hist(x, bins = int(len(x)/10.0), color= 'm')\n    plt.hist(x1, bins = int(len(x)/10.0),color='r')\n    plt.hist(x2, bins = int(len(x)/10.0),color='b')\n    plt.show()\n\n    e.Disconnect()","category":"page"},{"location":"principles/multiplyingDensities/#A-Basic-Factor-Graph-Product-Illustration","page":"Multiplying Functions (.py)","title":"A Basic Factor Graph Product Illustration","text":"","category":"section"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Using the factor graph methodology, we can repeat the example by adding variable and two prior factors.  This can be done directly in Julia (or via ZMQ in the further Python example below)","category":"page"},{"location":"principles/multiplyingDensities/#Products-of-Functions-(Factor-Graphs-in-Julia)","page":"Multiplying Functions (.py)","title":"Products of Functions (Factor Graphs in Julia)","text":"","category":"section"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Directly in Julia:","category":"page"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"using IncrementalInference\n\nfg = initfg()\n\naddVariable!(fg, :x0, ContinuousScalar)\naddFactor!(fg, [:x0], Prior(Normal(-3.0,1.0)))\naddFactor!(fg, [:x0], Prior(Normal(+3.0,1.0)))\n\nsolveTree!(fg)\n\n# plot the results\nusing KernelDensityEstimatePlotting\n\nplotKDE(getKDE(fg, :x0))","category":"page"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Example figure:","category":"page"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/productexample.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"principles/multiplyingDensities/#Products-of-Functions-(Via-Python-and-ZmqCaesar)","page":"Multiplying Functions (.py)","title":"Products of Functions (Via Python and ZmqCaesar)","text":"","category":"section"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"We repeat the example using Python and the ZMQ interface:","category":"page"},{"location":"principles/multiplyingDensities/","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"import sys\nsys.path.append('..')\n\nimport numpy as np\nfrom graff.Endpoint import Endpoint\nfrom graff.Distribution.Normal import Normal\nfrom graff.Distribution.SampleWeights import SampleWeights\nfrom graff.Distribution.BallTreeDensity import BallTreeDensity\n\nfrom graff.Core import MultiplyDistributions\n\n\nif __name__ == '__main__':\n    \"\"\"\n\n    \"\"\"\n    e.Connect('tcp://127.0.0.1:5555')\n    print(e.Status())\n\n    # Add the first pose x0\n    x0 = Variable('x0', 'ContinuousScalar')\n    e.AddVariable(x0)\n\n    # Add at a fixed location PriorPose2 to pin x0 to a starting location\n    prior = Factor('Prior', ['x0'], Normal(np.zeros(1,1)-3.0, np.eye(1)) )\n    e.AddFactor(prior)\n    prior = Factor('Prior', ['x0'], Normal(np.zeros(1,1)+3.0, np.eye(1)) )\n    e.AddFactor(prior)","category":"page"},{"location":"concepts/database_interactions/#Using-The-Cloud-Server","page":"Cloud Server/Database","title":"Using The Cloud Server","text":"","category":"section"},{"location":"concepts/database_interactions/","page":"Cloud Server/Database","title":"Cloud Server/Database","text":"See ongoing work at:","category":"page"},{"location":"concepts/database_interactions/","page":"Cloud Server/Database","title":"Cloud Server/Database","text":"DistributedFactorGraphs.jl, \nGraffSDK.jl.","category":"page"},{"location":"concepts/database_interactions/#Cloud-Server-offers-Multi-session/agent-Support","page":"Cloud Server/Database","title":"Cloud Server offers Multi-session/agent Support","text":"","category":"section"},{"location":"concepts/database_interactions/","page":"Cloud Server/Database","title":"Cloud Server/Database","text":"Next page Multisession","category":"page"},{"location":"concepts/dataassociation/#Data-Association-and-Hypotheses","page":"Multi-Modal/Hypothesis","title":"Data Association and Hypotheses","text":"","category":"section"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"Ambiguous data and processing often produce complicated data association situations.  In SLAM, loop-closures are a major source of concern when developing autonomous subsystems or behaviors. To illustrate this point, consider the two scenarios depicted below:","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/76276600-2686ef00-627e-11ea-9c86-fd21852ef793.png\" width=\"640\" border=\"0\" />\n</p>","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"In conventional parametric Gaussian-only systems an incorrect loop-closure can occur, resulting in highly unstable numerical solutions. The mm-iSAM algorithm was conceived to directly address these (and other related) issues by changing the fundamental manner in which the statistical inference is performed.","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"The data association problem applies well beyond just loop-closures including (but not limited to) navigation-affordance matching and discrepancy detection, and indicates the versatility of the IncrementalInference.jl standardized multihypo interface.  Note that much more is possible, however, the so-called single-fraction multihypo approach already yields significant benefits and simplicity.","category":"page"},{"location":"concepts/dataassociation/#Multihypothesis","page":"Multi-Modal/Hypothesis","title":"Multihypothesis","text":"","category":"section"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"Consider for example a regular three variable factor [:pose;:landmark;:calib] that due to some decision has a triple association uncertainty about the middle variable.  This fractional certainty can easily be modelled via:","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"addFactor!(fg, [:p10, :l1_a,:l1_b,:l1_c, :c], PoseLandmCalib, multihypo=[1; 0.6;0.3;0.1; 1])","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"Therefore, the user can \"partition\" certainty about one variable using any arbitrary n-ary factor.  The 100% certain variables are indicated as 1, while the remaining uncertainties regarding the uncertain data association decision are grouped as positive fractions that sum to 1. In this example, the values 0.6,0.3,0.1 represent the confidence about the association between :p10 and  either of :l1_a,:l1_b,:l1_c.","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"A more classical binary multihypothesis example is illustated in the multimodal (non-Gaussian) factor graph below:","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/76276833-dfe5c480-627e-11ea-9d84-2df1e1138bbf.png\" width=\"640\" border=\"0\" />\n</p>","category":"page"},{"location":"concepts/dataassociation/#Mixture-Models","page":"Multi-Modal/Hypothesis","title":"Mixture Models","text":"","category":"section"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"Mixture is a different kind of multi-modal modeling where different hypotheses of the measurement itself are unknown.  It is possible to also model uncertain data associations as a Mixture(Prior,...) but this is a feature of factor graph modeling something different than data association uncertainty in n-ary factors: e.g. it is possible to use Mixture together with multihypo= and be sure to take the time to understand the different and how these concepts interact. The Caesar.jl solution is more general than simply allocating different mixtures to different association decisions.  All these elements together can create quite the multi-modal soup.  A practical example from SLAM is a loop-closure where a robot observes an object similar to one previously seen.  The measurement observation is one thing (can maybe be a Mixture) and the association of this \"measurement\" with this or that variable is a multihypothesis selection.","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"See the familiar RobotFourDoor.jl as example as a highly simplified case using priors where these elements effectively all the same thing.  Again, Mixture is something different than multihypo= and the two can be used together.","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"A mixture can be created from any existing prior or relative likelihood factor, for example:","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"mlr = Mixture(LinearRelative, \n              (correlator=AliasingScalarSampler(...), naive=Normal(0.5,5), lucky=Uniform(0,10)),\n              [0.5;0.4;0.1])\n\naddFactor!(fg, [:x0;:x1], mlr)","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"See a example with Defining A Mixture Relative on ContinuousScalar for more details.","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"Mixture","category":"page"},{"location":"concepts/dataassociation/#IncrementalInference.Mixture","page":"Multi-Modal/Hypothesis","title":"IncrementalInference.Mixture","text":"struct Mixture{N, F<:FunctorInferenceType, S, T<:Tuple} <: FunctorInferenceType\n\nA Mixture object for use with either a <: AbstractPrior or <: AbstractRelative.\n\nNotes\n\nThe internal data representation is a ::NamedTuple, which allows total type-stability for all component types.\nVarious construction helpers can accept a variety of inputs, including <: AbstractArray and Tuple.\n\nDevNotes\n\nTODO on sampling see #1099 and #1094 and #1069 \n\nExample\n\n# prior factor\nmsp = Mixture(PriorSphere1, \n              [model=Normal(0,0.1), Uniform(-pi/1,pi/2)],\n              [0.5;0.5])\n\naddFactor!(fg, [:head], msp, tags=[:MAGNETOMETER;])\n\n# Or relative\nmlr = Mixture(LinearRelative, \n              (correlator=AliasingScalarSampler(...), naive=Normal(0.5,5), lucky=Uniform(0,10)),\n              [0.5;0.4;0.1])\n\naddFactor!(fg, [:x0;:x1], mlr)\n\n\n\n\n\n","category":"type"},{"location":"concepts/dataassociation/#Raw-Correlator-Probability-(Matched-Filter)","page":"Multi-Modal/Hypothesis","title":"Raw Correlator Probability (Matched Filter)","text":"","category":"section"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"Realistic measurement processes are based on physical process observations such as wave function interferometry or matched filtering correlation.  This style of measurement is common in RADAR and SONAR systems, and can be directly incorporated in Caesar.jl since the measurement likelihood models need not be parametric.  There the raw correlator output from a sensor measurement can be directly modelled and included as part of the factor algebriac likelihood probability function:","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"# Building a samplable likelihood, using softmax to convert intensity-energy into a pseudo-probability\nrangeLikeli = AliasingScalarSampler(rangeIndex, Flux.softmax(correlatorIntensity))\n\n# or alternatively with existing samples similar to a what a particle filter would have done\nrangeLikeli = manikde!(probPoints, Euclid{1})\n\n# add the relative algebra, and remember you can construct your own highly non-linear factor\nrangeFct = Pose2Point2Range(rangeLikeli)\n\naddFactor!(fg, [:x8, :beacon_8], rangeFct)","category":"page"},{"location":"concepts/dataassociation/#Various-SamplableBelief-Distribution-Types","page":"Multi-Modal/Hypothesis","title":"Various SamplableBelief Distribution Types","text":"","category":"section"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"Also recognize that other features like multihypo= and Mixture readily be combined with object like this rangeFct shown above.  These tricks are all possible due to the multiple dispatch magic of JuliaLang, more explicitly the following is code will all return true:","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"IIF.AliasingScalarSampler <: IIF.SamplableBelief\nIIF.Mixture <: IIF.SamplableBelief\nKDE.BallTreeDensity <: IIF.SamplableBelief\nDistribution.Rayleigh <: IIF.SamplableBelief\nDistribution.Uniform <: IIF.SamplableBelief\nDistribution.MvNormal <: IIF.SamplableBelief","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"One of the more exotic examples is to natively represent Synthetic Aperture Sonar (SAS) as a deeply non-Gaussian factor in the factor graph.  See Synthetic Aperture Sonar SLAM.  Also see the full AUV stack using a single reference beacon and Towards Real-Time Underwater Acoustic Navigation.","category":"page"},{"location":"concepts/dataassociation/#Null-Hypothesis","page":"Multi-Modal/Hypothesis","title":"Null Hypothesis","text":"","category":"section"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"Sometimes there is basic uncertainty about whether a measurement is at all valid.  Note that the above examples (multihypo and Mixture) still accept that a certain association definitely exists. A null hypothesis models the situation in which a factor might be completely bogus, in which case it should be ignored.  The underlying mechanics of this approach are not entirely straightforward since removing one or more factors essentially changes the structure of the graph.  That said, IncrementalInference.jl employs a reasonable stand-in solution that does not require changing the graph structure and can simply be included for any factor.","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"addFactor!(fg, [:x7;:l13], Pose2Point2Range(...), nullhypo=0.1)","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"This keyword indicates to the solver that there is a 10% chance that this factor is not valid.","category":"page"},{"location":"concepts/dataassociation/","page":"Multi-Modal/Hypothesis","title":"Multi-Modal/Hypothesis","text":"note: Note\nAn entirely separate page is reserved for incorporating Flux neural network models into Caesar.jl as highly plastic and trainable (i.e. learnable) factors.","category":"page"},{"location":"concepts/multilang/#Multi-Language-and-Shared-Objects","page":"Multi-Language Support","title":"Multi-Language and Shared Objects","text":"","category":"section"},{"location":"concepts/multilang/#Multilanguage-Interops:-Caesar-SDKs-and-APIs","page":"Multi-Language Support","title":"Multilanguage Interops: Caesar SDKs and APIs","text":"","category":"section"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"The Caesar framework is not limited to direct Julia use. The following Github projects provide access to features of Caesar in their language:","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"Julia Web interface:\nGraffSDK.jl\nZMQ Interface\nC/C++:\nGraff Cpp\nCaesar LCM\nPython:\nGraffSDK.py","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"Contributions are welcome! If you are developing an extension we would like to help, please feel free to contact us (details below).","category":"page"},{"location":"concepts/multilang/#ZMQ-Messaging-Interface","page":"Multi-Language Support","title":"ZMQ Messaging Interface","text":"","category":"section"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"Caesar.jl has a ZMQ messaging interface (interested can see code here  here) that allows users to interact with the solver code base in a variety of ways.  The messaging interface is not meant to replace static .so library file compilation–see below–-but rather a more versatile and flexible development strategy.","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"The current known interface implementations to Caesar.jl are:","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"C/C++ GraffCPP,\nPython GraffSDK.py (needs to be updated),","category":"page"},{"location":"concepts/multilang/#Starting-the-Caesar-ZMQ-Navigation-Server","page":"Multi-Language Support","title":"Starting the Caesar ZMQ Navigation Server","text":"","category":"section"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"Start the Caesar.ZmqCaesar server in a Julia session with a few process cores and full optimization:","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"julia -p4 -O3","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"Then run the following commands, and note these steps have also been scripted here:","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"#import the required modules\nusing Caesar, Caesar.ZmqCaesar\n\n# create empty factor graph and config objects\nfg = initfg()\nconfig = Dict{String, String}()\nzmqConfig = ZmqServer(fg, config, true, \"tcp://*:5555\");\n\n# Start the server over ZMQ\nstart(zmqConfig)\n\n# give the server a minute to start up ...","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"The current tests are a good place to see some examples of the current interfacing functions.  Feel free to change the ZMQ interface for to any of the ZMQ supported modes of data transport, such as Interprocess Communication (IPC) vs. TCP.","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"TODO: expand the ZMQ documentation","category":"page"},{"location":"concepts/multilang/#ROS-Integration","page":"Multi-Language Support","title":"ROS Integration","text":"","category":"section"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"Yes, but not yet.  See:","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"FAQ: ROS Integration","category":"page"},{"location":"concepts/multilang/#Static,-Shared-Object-.so-Compilation","page":"Multi-Language Support","title":"Static, Shared Object .so Compilation","text":"","category":"section"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"FAQ: Static, Shared Object .so Compilation","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"The plan for the Caesar.jl & the mm-iSAM is to use PackageCompiler.jl to generate linkable .o or .so files; or maybe even full executables.","category":"page"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"Please add your comments to this issue discussion.","category":"page"},{"location":"concepts/multilang/#Alternative-Methods","page":"Multi-Language Support","title":"Alternative Methods","text":"","category":"section"},{"location":"concepts/multilang/","page":"Multi-Language Support","title":"Multi-Language Support","text":"Interfacing from languages like Python may also be achieved using PyCall.jl although little work has been done in the Caesar.jl framework to explore this path.  Julia is itself interactive/dynamic and has plenty of line-by-line and Integrated Development Environment support – consider trying Julia for your application.","category":"page"},{"location":"principles/filterCorrespondence/#Build-your-own-(Bayes)-Filter","page":"Filters vs. Graphs","title":"Build your own (Bayes) Filter","text":"","category":"section"},{"location":"principles/filterCorrespondence/#Correspondence-with-Kalman-Filtering?","page":"Filters vs. Graphs","title":"Correspondence with Kalman Filtering?","text":"","category":"section"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"A frequent discussion point is the correspondence between Kalman/particle/log-flow filtering strategies and factor graph formulations.  This section aims to shed light on the relationship, and to show that factor graph interpretations are a powerful generalization of existing filtering techniques.  The discussion follows a build-your-own-filter style and combines the Approximate Convolution and Multiplying Densities pages as the required prediction and update cycle steps, respectively.  Using the steps described here, the user will be able to build fully-functional–-i.e. non-Gaussian–-(Bayes) filters.  ","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"note: Note\nA simple 1D predict correct Bayesian filtering example (using underlying convolution and product operations of the mmisam algorithm) can be used as a rough template to familiarize yourself on the correspondence between filters and newer graph-based operations.","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"This page tries to highlight some of the reasons why using a factor graph approach (w/ Bayes/junction tree inference) in a incremental/fixed-lag/federated sense–-e.g. simultaneous localization and mapping (SLAM) approach–-has merit.  The described steps form part of the core operations used by the multimodal incremental smoothing and mapping (mmisam) algorithm.","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Further topics on factor graph (and Bayes/junction tree) inference formulation, including how out-marginalization works is discussed separately as part of the Bayes tree description page.  It is also worth reiterating the section on why do we even care about non-Gaussian signal processing.","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"note: Note\nComing soon, the steps described on this page will be fully accessible via multi-language interfaces (middleware) – some of these interfaces already exist.","category":"page"},{"location":"principles/filterCorrespondence/#Causality-and-Markov-Assumption","page":"Filters vs. Graphs","title":"Causality and Markov Assumption","text":"","category":"section"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"WIP: Causal connection explanation:  How is the graph based method the same as Kalman filtering variants (UKF, EKF), including Bayesian filtering (PF, etc.), and the Hidden Markov Model (HMM) methodology.  ","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Furthermore, see below for connection to EKF-SLAM too.","category":"page"},{"location":"principles/filterCorrespondence/#Joint-Probability-and-Chapman-Kolmogorov","page":"Filters vs. Graphs","title":"Joint Probability and Chapman-Kolmogorov","text":"","category":"section"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"WIP; The high level task is to \"invert\" measurements Z give the state of the world Theta","category":"page"},{"location":"principles/filterCorrespondence/#Maximum-Likelihood-vs.-Message-Passing","page":"Filters vs. Graphs","title":"Maximum Likelihood vs. Message Passing","text":"","category":"section"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"WIP; This dicussion will lead towards Bayesian Networks (Pearl) and Bayes Trees (Kaess et al., Fourie et al.).","category":"page"},{"location":"principles/filterCorrespondence/#The-Target-Tracking-Problem-(Conventional-Filtering)","page":"Filters vs. Graphs","title":"The Target Tracking Problem (Conventional Filtering)","text":"","category":"section"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Consider a common example, two dimensional target tracking, where a projectile transits over a tracking station using various sensing technologies [Zarchan 2013].  Position and velocity estimates of the target","category":"page"},{"location":"principles/filterCorrespondence/#Prediction-Step-using-a-Factor-Graph","page":"Filters vs. Graphs","title":"Prediction Step using a Factor Graph","text":"","category":"section"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Assume a constant velocity model from which the estimate will be updated through the measurement model described in the next section.  A constant velocity model is taken as (cartesian)","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"fracdxdt = 0 + eta_x\nfracdydt = 0 + eta_y","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"or polar coordinates","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"fracdrhodt = 0 + eta_rho\nfracdthetadt = 0 + eta_theta","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"In this example, noise is introduced as an affine slack variable \\eta, but could be added as any part of the process model:","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"eta_j sim p()","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"where p is any allowable noise probability density/distribution model – discussed more in the next section.","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"After integration (assume zeroth order) the associated residual function can be constructed:","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"delta_i (theta_k theta_k-1 fracd theta_kdt Delta t) = theta_k - (theta_k-1 + fracd theta_kdt Delta t)","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Filter prediction steps are synonymous with a binary factor (conditional likelihood) between two variables where a prior estimate from one variable is projected (by means of a convolution) to the next variable.  The convolutional principle page describes a more detailed example on how a convolution can be computed. ","category":"page"},{"location":"principles/filterCorrespondence/#Measurement-Step-using-a-Factor-Graph","page":"Filters vs. Graphs","title":"Measurement Step using a Factor Graph","text":"","category":"section"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"The measurement update is a product operation of infinite functional objects (probability densities)","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"p(X_k  X_k-1 Z_a Z_b) approx p(X_k  X_k-1 Z_a) times p(X_k  Z_b)","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"where Z_. represents conditional information for two beliefs on the same variable.  The product of the two functional estimates (beliefs) are multiplied by a stochastic algorithm described in more detail on the multiplying functions page.","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Direct state observations can be added to the factor graph as prior factors directly on the variables.  An illustration of both predictions (binary likelihood process model) and direct observations (measurements) is presented:","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/68166954-e45e4180-ff5b-11e9-91cb-0741d90a0c02.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Alternatively, indirect measurements of the state variables are should be modeled with the most sensible function","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"y = h(theta eta)\ndelta_j(theta_j eta_j) = ominus h_j(theta_j eta_j) oplus y_j","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"which approximates the underlying (on-manifold) stochastics and physics of the process at hand.  The measurement models can be used to project belief through a measurement function, and should be recognized as a standard representation for a Hidden Markov Model (HMM):","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/71652397-105c3000-2d1d-11ea-92bc-282ddbe3eabc.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"principles/filterCorrespondence/#Beyond-Filtering","page":"Filters vs. Graphs","title":"Beyond Filtering","text":"","category":"section"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"Consider a multi-sensory system along with data transmission delays, variable sampling rates, etc.;  when designing a filtering system to track one or multiple targets, it quickly becomes difficult to augment state vectors with the required state and measurement histories.  In contrast, the factor graph as a language allows for heterogeneous data streams to be combined in a common inference framework, and is discussed further in the building distributed factor graphs section.","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"note: Note\nFactor graphs are constructed along with the evolution of time which allows the mmisam inference algorithm to resolve variable marginal estimates both forward and backwards in time.  Conventional filtering only allows for forward-backward \"smoothing\" as two separate processes.  When inferring over a factor graph, all variables and factors are considered simultaneously according the topological connectivity irrespective of when and where which measurements were made or communicated – as long as the factor graph (probabilistic model) captures the stochastics of the situation with sufficient accuracy.  ","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"TODO: Multi-modal (belief) vs. multi-hypothesis – see thesis work on multimodal solutions in the mean time.","category":"page"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"note: Note\nMmisam allows for parametric, non-parametric, or intensity noise models which can be incorporated into any differentiable residual function.","category":"page"},{"location":"principles/filterCorrespondence/#Anecdotal-Example-(EKF-SLAM-/-MSC-KF)","page":"Filters vs. Graphs","title":"Anecdotal Example (EKF-SLAM / MSC-KF)","text":"","category":"section"},{"location":"principles/filterCorrespondence/","page":"Filters vs. Graphs","title":"Filters vs. Graphs","text":"WIP: Explain how this method is similar to EKF-SLAM and MSC-KF...","category":"page"},{"location":"examples/basic_definingfactors/#Defining-New-Factors","page":"Creating Factors","title":"Defining New Factors","text":"","category":"section"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"Julia's type inference allows overloading of member functions outside a module.  Therefore new factors can be defined at any time.  To better illustrate, in this example we will add new factors into the Main context after construction of the factor graph has already begun.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"using IncrementalInference\n\n# You must import this to later overload\nimport IncrementalInference: getSample","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"Let's start with some factor graph:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"# empty factor graph object\nfg = initfg()\n\n# add a variable in 1 dimension\naddVariable!(fg, :x0, ContinuousEuclid{1})\naddVariable!(fg, :x1, ContinuousEuclid{1})\n\n# and a basic IIF.Prior from existing factors and Distributions.jl\npr0 = Prior(Normal(0,1))\naddFactor!(fg, [:x0], pr0)\n\n# making fg slightly more interesting -- i.e. x0 and x1 are 10 units apart on 1D Euclidean space\naddFactor!(fg, [:x0; :x1], LinearRelative(Normal(10,1)))","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"tip: Tip\nIIF is a convenient const alias of the module IncrementalInference, similarly AMP for ApproxManifoldProducts.","category":"page"},{"location":"examples/basic_definingfactors/#Defining-a-New-Prior-(Absolute-/-Gauge)","page":"Creating Factors","title":"Defining a New Prior (Absolute / Gauge)","text":"","category":"section"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"Now lets define in Main scope our own prior, MyPrior which allows for arbitrary distributions that inherit from <: IIF.SamplableBelief:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"\nstruct MyPrior{T <: SamplableBelief} <: IIF.AbstractPrior\n  Z::T\nend\n\n# import IncrementalInference: getSample\n# sampling function\ngetSample(cfo::CalcFactor{<:MyPrior}, N::Int=1) = (reshape(rand(cfo.factor.Z,N),1,:), )","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"Note the following critical aspects that allows IIF to use the new definition:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"<:AbstractPrior as a unary factor that introduces absolute (or gauge) information about only one variable.\ngetSample is overloaded with dispatch on:\n(cfo::CalcFactor{<:MyPrior}, ::Int)\ngetSample must return a ::Tuple, even if there is only stochastic value (as is the case above).\nThe first value in the tuple is special, and must be of type <:AbstractMatrix{<:Real}.  We ensure that with the reshape.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"IIF internally uses the number of rows in the first element of the getSample return tuple (i.e. the matrix) to extract the measurement dimension for this factor.  In this case it is 1 dimensional.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"To recap, the new getSample function in this example factor returns a measurement which is of type ::Tuple{::Matrix{Float64}}.  The ::Tuple is slightly clunky but was borne out of necessity to allow for versatility when multiple values from sampling are used during residual function evaluation.  Previous uses  include cases such as ::Tuple{<:Matrix, <:Vector, <:Function}.","category":"page"},{"location":"examples/basic_definingfactors/#Ready-to-Use","page":"Creating Factors","title":"Ready to Use","text":"","category":"section"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"This new prior can now readily be added to an ongoing factor graph:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"# lets generate a random nonparametric belief\npts = 8 .+ 2*rand(1,75)\nsomeBelief = manikde!(pts, ContinuousEuclid{1})\n\n# and build your new factor as an object\nmyprior = MyPrior(someBelief)","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"and add it to the existing factor graph from earlier, lets say:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"addFactor!(fg, :x1, myprior)","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"Thats it, this factor is now part of the graph.  This should be a solvable graph:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"solveGraph!(fg); # exact alias of solveTree!(fg)","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"Later we will see how to ensure these new factors can be properly serialized to work with features like saveDFG and loadDFG.","category":"page"},{"location":"examples/basic_definingfactors/#What-is-CalcFactor","page":"Creating Factors","title":"What is CalcFactor","text":"","category":"section"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"CalcFactor is part of the IIF interface to all factors.  It contains metadata and other important bits of information that are useful in a wide swath of applications.  As work requires more interesting features from the code base, it is likely that the cfo::CalcFactor object will contain such data.  If not, please open an issue with Caesar.jl so that the necessary options may be added.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"The cfo object contains the field .factor::T which is the type of the user factor being used, e.g. myprior from above example.  That is cfo.factor::MyPrior.  This is why getSample is using rand(cfo.factor.Z).","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"CalcFactor was introduced in IncrementalInference v0.20 to consolidate and standardize a variety of features that had previously been diseparate and unwieldy.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"tip: Tip\nMany factors already exists in IncrementalInference, RoME, and Caesar.  Please see their src directories for more details.","category":"page"},{"location":"examples/basic_definingfactors/#Relative-Factors","page":"Creating Factors","title":"Relative Factors","text":"","category":"section"},{"location":"examples/basic_definingfactors/#One-Dimension-Roots-Example","page":"Creating Factors","title":"One Dimension Roots Example","text":"","category":"section"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"Previously we looked at adding a prior.  This section demonstrates the first of two <:AbstractRelative factor types.  These are factors that introduce only relative information between variables in the factor graph.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"This example is on <:AbstractRelativeRoots.  First, lets create the factor as before ","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"struct MyFactor{T <: SamplableBelief} <: IIF.AbstractRelativeRoots\n  Z::T\nend\ngetSample(cfo::CalcFactor{<:MyFactor}, N::Int=1) = (reshape(rand(cfo.factor.Z,N) ,1,N), )\n\nfunction (cfo::CalcFactor{<:MyFactor})( res::AbstractVector{<:Real},\n                                        measurement_z,\n                                        x1,\n                                        x2  )\n  #\n  res[1] = measurement_z - (x2[1] - x1[1])\n  nothing\nend","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"The selection of <:AbstractRelativeRoots, akin to earlier <:AbstractPrior, instructs IIF to find the roots of the provided residual function.  That is the one dimensional residual function, res[1] = measurement - prediction, is used during inference to approximate the convolution of conditional beliefs from the approximate beliefs of the connected variables in the factor graph.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"Important aspects to note, <:AbstractRelativeRoots requires all elements length(res) (the factor measurement dimension) to have a feasible zero crossing solution.  A two dimensional system will solve for variables where both res[1]==0 and res[2].","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"warn: Warn\nThe values of vector res should be updated.  The reference to which memory res is pointing should be left alone – i.e. this is good res[1:2] = my2dresidual, but this is bad res = my2dresidual.","category":"page"},{"location":"examples/basic_definingfactors/#Two-Dimension-Minimize-Example","page":"Creating Factors","title":"Two Dimension Minimize Example","text":"","category":"section"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"The second type is <:AbstractRelativeMinimize which simply minimizes the return value of the user factor (must also be applied in res[1]).  This type is useful for partial constraint situations where the residual function is always gauranteed to have zero crossings in all dimensions and the problem is converted into a minimization problem instead:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"struct OtherFactor{T <: SamplableBelief} <: IIF.AbstractRelativeMinimize\n  Z::T             # assuming something 2 dimensional\n  userdata::String # or whatever is necessary\nend\n\n# just illustrating some arbitraty second value in tuple of different size\ngetSample(cfo::CalcFactor{<:OtherFactor}, N::Int=1) = (rand(cfo.factor.z,N), rand())\n\nfunction (cfo::CalcFactor{<:OtherFactor})(res::AbstractVector{<:Real},\n                                          z,\n                                          second_val,\n                                          x1,\n                                          x2 )\n  #\n  # @assert length(z) == 2\n  # not doing anything with `second_val` but illustrating\n  # not doing anything with `cfo.factor.userdata` either\n  \n  # the broadcast operators with automatically vectorize\n  res[1:2] .= z .- (x1[1:2] .- x1[1:2])\n  nothing\nend","category":"page"},{"location":"examples/basic_definingfactors/#Special-Considerations","page":"Creating Factors","title":"Special Considerations","text":"","category":"section"},{"location":"examples/basic_definingfactors/#Partial-Factors","page":"Creating Factors","title":"Partial Factors","text":"","category":"section"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"In some cases a factor only effects a partial set of dimensions of a variable.  For example a magnetometer being added onto a Pose2 variable would look something like this:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"struct MyMagnetoPrior{T<:SamplableBelief} <: AbstractPrior\n  Z::T\n  partial::Tuple{Int}\nend\n\n# define a helper constructor\nMyMagnetoPrior(z) = MyMagnetoPrior(z, (3,))\n\ngetSample(cfo::CalcFactor{<:MyMagnetoPrior}, N::Int=1) = (reshape(rand(cfo.factor.Z,N),1,N),)","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"Similarly for <:AbstractRelativeMinimize, and note that the Roots version currently does not support the .partial option.","category":"page"},{"location":"examples/basic_definingfactors/#Metadata","page":"Creating Factors","title":"Metadata","text":"","category":"section"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"The MM-iSAMv2 algorithm relies on the Kolmogorov-Criteria as well as uncorrelated factor sampling.  This means that when generating fresh samples for a factor, those samples should not depend on values of variables in the graph or independent volatile variables.  That said, if you are comfortable or have a valid reason for introducing correlation between the factor sampling process with values inside the factor graph then you can do so via the cfo.CalcFactor interface.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"At present cfo contains three main fields:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"cfo.factor::MyFactor the factor object as defined in the struct definition,\ncfo.metadata::FactorMetadata, which is currently under development and likely to change.\nThis contains references to the connected variables to the factor and more, and is useful for large data retrieval such as used in Terrain Relative Navigation (TRN).\ncfo._sampleIdx is the index of which computational sample is currently being calculated.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"note: Note\nThe old .specialSampler framework has been replaced with the standardized ::CalcFactor interface.  See http://www.github.com/JuliaRobotics/IIF.jl/issues/467 for details.","category":"page"},{"location":"examples/basic_definingfactors/#Multithreading","page":"Creating Factors","title":"Multithreading","text":"","category":"section"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"Julia and therefore IIF has strong support for shared-memory multithreading.  The thing to keep in mind is what parts of residual factor computation is shared memory.  The most sensible breakdown into threaded work is for separate samples (i.e. cfo._sampleIdx) to be calculated in separate threads.  The user residual function itself could likely also be broken down further into more threaded operations.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"The example above introduced OtherFactor.userdata.  This could cause problems if the residual calculations are actively using userdata for some volatile internal computation.  In that case it might be useful for the user to instead use Threads.nthreads() and Threads.threadid() to make sure the shared-memory issues are avoided:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"struct OtherFactor{T <: SamplableBelief} <: IIF.AbstractRelativeMinimize\n  Z::T             # assuming something 2 dimensional\n  inplace::Vector{MyInplaceMem}\nend\n\n# helper function\nOtherFactor(z) = OtherFactor(z, [MyInplaceMem(0) for i in 1:Threads.nthreads()])\n\n# in residual function just use `thr_inplace = cfo.factor.inplace[Threads.threadid()]`","category":"page"},{"location":"examples/basic_definingfactors/#[OPTIONAL]-Standardized-Serialization","page":"Creating Factors","title":"[OPTIONAL] Standardized Serialization","text":"","category":"section"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"To take advantage of features like DFG.saveDFG and DFG.loadDFG a user specified type should be able to serialize via JSON standards.  The decision was taken to require bespoke factor types to always be converted into a JSON friendly struct which must be prefixed as type name with PackedMyPrior{T}.   Similarly, the user must also overload Base.convert as follows:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"# necessary for overloading Base.convert\nimport Base: convert\n\nstruct PackedMyPrior <: PackedInferenceType\n  Z::String\nend\n\n# IIF provides convert methods for `SamplableBelief` types\nconvert(::Type{PackedMyPrior}, pr::MyPrior{<:SamplableBelief}) = PackedMyPrior(convert(PackedSamplableBelief, pr.Z))\nconvert(::Type{MyPrior}, pr::PackedMyPrior) = MyPrior(IIF.convert(SamplableBelief, pr.Z))","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"Now you should be able to saveDFG and loadDFG your own factor graph types to Caesar.jl / FileDFG standard .tar.gz format.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"fg = initfg()\naddVariable!(fg, :x0, ContinuousScalar)\naddFactor!(fg, [:x0], MyPrior(Normal()))\n\n# generate /tmp/myfg.tar.gz\nsaveDFG(\"/tmp/myfg\", fg)\n\n# test loading the .tar.gz (extension optional)\nfg2 = loadDFG(\"/tmp/myfg\")\n\n# list the contents\nls(fg2), lsf(fg2)\n# should see :x0 and :x0f1 listed","category":"page"},{"location":"examples/basic_definingfactors/#Summary","page":"Creating Factors","title":"Summary","text":"","category":"section"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"All factors inherit from one of the following types, depending on their function:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"AbstractPrior: AbstractPrior are priors (unary factors) that provide an absolute constraint for a single variable. A simple example of this is an absolute GPS prior, or equivalently a (0, 0, 0) starting location in a Pose2 scenario.\nRequires: A getSample function\nAbstractRelativeMinimize: AbstractRelativeMinimize are relative factors that introduce an algebraic relationship between two or more variables. A simple example of this is an odometry factor between two pose variables, or a range factor indicating the range between a pose and another variable.\nRequires: A getSample function and a residual function definition\nThe minimize suffix specifies that the residual function of this factor will be enforced by numerical minimization (find me the minimum of this function)\nAbstractRelativeRoots: AbstractRelativeRoots are relative factors that introduce algebraic relationships between two or more variables. They are the same as AbstractRelativeMinimize, however they use root finding to find the zero crossings (rather than numerical minimization).\nRequires: A getSample function and a residual function definition","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"How do you decide which to use?","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"If you are creating factors for world-frame information that will be tied to a single variable, inherit from <:AbstractPrior\nGPS coordinates should be priors\nIf you are creating factors for local-frame relationships between variables, inherit from AbstractRelativeMinimize\nOdometry and bearing deltas should be introduced as pairwise factors and should be local frame","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"TBD: Users should start with AbstractRelativeMinimize, discuss why and when they should promote their factors to AbstractRelativeRoots.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"note: Note\nAbstractRelativeMinimize does not imply that the overall inference algorithm only minimizes an objective function. The Multi-model iSAM algorithm is built around fixed-point analysis. Minimization is used here to locally enforce the residual function.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"What you need to build in the new factor:","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"A struct for the factor itself\nA sampler function to return measurements from the random ditributions\nIf you are building a AbstractRelativeMinimize or a AbstractRelativeRoots you need to define a residual function to introduce the relative algebraic relationship between the variables\nMinimization function should be lower-bounded and smooth\nA packed type of the factor which must be named Packed[Factor name], and allows the factor to be packed/transmitted/unpacked\nSerialization and deserialization methods\nThese are convert functions that pack and unpack the factor (which may be highly complex) into serialization-compatible formats\nAs the factors are mostly comprised of distributions (of type SamplableBelief), functions are provided to pack and unpack the distributions:\nPacking: To convert from a SamplableBelief to a serializable obhect, use convert(PackedSamplableBelief, ::SamplableBelief)\nUnpacking: To convert from string back to a SamplableBelief, use convert(SamplableBelief, ::PackedSamplableBelief)  ","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"An example of this is the Pose2Point2BearingRange, which provides a bearing+range relationship between a 2D pose and a 2D point.","category":"page"},{"location":"examples/basic_definingfactors/","page":"Creating Factors","title":"Creating Factors","text":"AbstractRelativeMinimize\nAbstractRelativeRoots","category":"page"},{"location":"installation_environment/#Welcome","page":"Installation","title":"Welcome","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"Caesar.jl is one of the packages within the JuliaRobotics community, and adheres to the code-of-conduct.","category":"page"},{"location":"installation_environment/#Local-Dependencies","page":"Installation","title":"Local Dependencies","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"The following system packages are used by Caesar.jl:","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"# required packages\nsudo apt-get install hdf5-tools imagemagick\n\n# optional packages\nsudo apt-get install graphviz xdot","category":"page"},{"location":"installation_environment/#New-to-Julia-and-want-a-full-Development-Install","page":"Installation","title":"New to Julia and want a full Development Install","text":"","category":"section"},{"location":"installation_environment/#Local-Installation-of-Julia","page":"Installation","title":"Local Installation of Julia","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"Although Julia (or JuliaPro) can be installed on a Linux computer using the apt package manager, we are striving for a fully local installation environment which is highly reproducible on a variety of platforms.","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"The easiest method is–-via the terminal–-to download the desired version of Julia as a binary, extract, setup a symbolic link, and run:","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"cd ~\nmkdir -p .julia\ncd .julia\nwget https://julialang-s3.julialang.org/bin/linux/x64/1.5/julia-1.5.2-linux-x86_64.tar.gz\ntar -xvf julia-1.5.2-linux-x86_64.tar.gz\nrm julia-1.5.2-linux-x86_64.tar.gz\ncd /usr/local/bin\nsudo ln -s ~/.julia/julia-1.5.2/bin/julia julia","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"note: Note\nFeel free to modify this setup as you see fit.","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"This should allow any terminal or process on the computer to run the Julia REPL by type julia and testing with:","category":"page"},{"location":"installation_environment/#[Optional]-Quick-Test-that-Julia-is-Working","page":"Installation","title":"[Optional] Quick Test that Julia is Working","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"Run Julia in REPL (console) mode:","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"$ julia\njulia> println(\"hello world\")\n\"hello world\"","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"Maybe a script, or command:","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"user@...$ echo \"println(\\\"hello again\\\")\" > myscript.jl\nuser@...$ julia myscript.jl\nhello again\nuser@...$ rm myscript.jl\n\nuser@...$ julia -e \"println(\\\"one more time.\\\")\"\none more time.\nuser@...$ julia -e \"println(\\\"...testing...\\\")\"\n...testing...\n","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"note: Note\nWhen searching for Julia related help online, use the phrase 'julialang' instead of just 'julia'.  For example, search for 'julialang workflow tips' or 'julialang performance tips'. Also, see FAQ - Why are first runs slow?, which is due to Just-In-Time/Pre compiling and caching.","category":"page"},{"location":"installation_environment/#Setup-VSCode-IDE-Environment","page":"Installation","title":"Setup VSCode IDE Environment","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"VSCode IDE allows for interactive development of Julia code using the Julia Extension.  After installing and running VSCode, install the Julia Language Support Extension:","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/97769200-444fdf80-1aff-11eb-8ca4-dc6d7a3830fd.png\" width=\"800\" border=\"0\" />\n</p>","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"In VSCode, open the command pallette by pressing Ctrl + Shift + p.  There are a wealth of tips and tricks on how to use VSCode.  See this JuliaCon presentation for as a general introduction into 'piece-by-piece' code execution and much much more.  Working in one of the Julia IDEs like VS Code or Juno should feel something like this (Gif borrowed from DiffEqFlux.jl):","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/1814174/88589293-e8207f80-d026-11ea-86e2-8a3feb8252ca.gif\" width=\"800\" border=\"0\" />\n</p>","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"There are a variety of useful packages in VSCode, such as GitLens, LiveShare, and Todo Browser as just a few highlights.  These VSCode Extensions are independent of the already vast JuliaLang Package Ecosystem (see JuliaObserver.com).","category":"page"},{"location":"installation_environment/#Julia-Packages","page":"Installation","title":"Julia Packages","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"The philosophy around Julia packages are discussed at length in the Julia core documentation, where each Julia package relates to a git repository likely found on Github.com. To install a Julia package, simply open a julia REPL (equally the julia REPL in Atom/Juno) and type:","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"] # activate Pkg manager\n(v1.5) pkg> add Caesar","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"These are registered packages maintained by JuliaRegistries/General. Unregistered latest packages can also be installed with using only the Pkg.develop function:","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"# Caesar is registered on JuliaRegistries/General\njulia> ]\n(v1.5) pkg> add Caesar","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"See Pkg.jl for details and features regarding package management, development, version control, virtual environments and much more.","category":"page"},{"location":"installation_environment/#Install-Visualization-Tools","page":"Installation","title":"Install Visualization Tools","text":"","category":"section"},{"location":"installation_environment/#RoMEPlotting.jl-for-2D-plots","page":"Installation","title":"RoMEPlotting.jl for 2D plots","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"RoMEPlotting.jl (2D) and Arena.jl (3D) as optional visualization packages:","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"(v1.5) pkg> add RoMEPlotting","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"note: Note\nAs of 1Q2020 it is likely that most systems won’t require a system install of libpango or even libcairo. Previous versions of libraries required the following Linux system packages be installed:sudo apt-get install libfontconfig1\nsudo apt-get install gettext\nsudo apt-get install libcairo2\nsudo apt-get install libpango1.0-0  # or libpango1.0-1","category":"page"},{"location":"installation_environment/#Install-3D-Visualization-Utils-(e.g.-Arena.jl)","page":"Installation","title":"Install 3D Visualization Utils (e.g. Arena.jl)","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"3D Visualizations are provided by Arena.jl as well as development package Amphitheater.jl. Please follow instructions on the Visualizations page for a variety of 3D utilities.","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"note: Note\nArena.jl and Amphitheater.jl are currently being refactored as part of the broader DistributedFactorGraph migration, the features are are in beta stage (1Q2020).","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"Install the latest master branch version with","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"(v1.5) pkg> add Arena#master","category":"page"},{"location":"installation_environment/#Running-Unit-Tests-Locally","page":"Installation","title":"Running Unit Tests Locally","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"Unit tests can further be performed for the upstream packages as follows – NOTE first time runs are slow since each new function call or package must first be precompiled.","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"# the multimodal incremental smoothing and mapping solver\n(v1.5) pkg> test IncrementalInference\n...\n# robotics related variables and factors to work with IncrementalInference -- can be used standalone SLAM system\n(v1.5) pkg> test RoME\n...\n# umbrella framework with interaction tools and more -- allows stand alone and server based solving\n(v1.5) pkg> test Caesar\n...","category":"page"},{"location":"installation_environment/#Install-Repos-for-Development","page":"Installation","title":"Install Repos for Development","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"Alternatively, the dev command:","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"(v1.5) pkg> dev https://github.com/JuliaRobotics/Caesar.jl","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"warn: Warn\nDevelopment packages are NOT managed by Pkg.jl, so you have to manage this Git repo manually.  Development packages can usually be found at, e.g. Caesar~/.julia/dev/Caesar","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"If you'd like to modify or contribute then feel free to fork the specific repo from JuliaRobotics, complete the work on branches in the fork as is normal with a Git workflow and then submit a PR back upstream.  We try to keep PRs small, specific to a task and preempt large changes by first merging smaller non-breaking changes and finally do a small switch over PR.  We also follow a backport onto release/vX.X branch strategy with common master as the development lobby that builds successfully 99.999% of the time.","category":"page"},{"location":"installation_environment/#Ahead-Of-Time-Compile-RoME.so","page":"Installation","title":"Ahead Of Time Compile RoME.so","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"In RoME, run the compileRoME/compileRoMESysimage.jl script","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"To use RoME with the newly created sysimage, start julia with:","category":"page"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"julia -O3 -J ~/.julia/dev/RoME/compileRoME/RoMESysimage.so","category":"page"},{"location":"installation_environment/#Install-\"Just-the-ZMQ/ROS-Runtime-Solver\"-(Linux)","page":"Installation","title":"Install \"Just the ZMQ/ROS Runtime Solver\" (Linux)","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"Work in progress (see issue #278).","category":"page"},{"location":"installation_environment/#Contributing,-Issues,-or-Comments","page":"Installation","title":"Contributing, Issues, or Comments","text":"","category":"section"},{"location":"installation_environment/","page":"Installation","title":"Installation","text":"Please feel free to open issues with Caesar.jl or even Fork and Pull Request as required. General conversations or comments can be made in the Caesar Gist.","category":"page"},{"location":"concepts/building_graphs/#Building-and-Solving-Graphs","page":"Building Factor Graphs","title":"Building and Solving Graphs","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Irrespective of your application - real-time robotics, batch processing of survey data, or really complex multi-hypothesis modeling - you're going to need to add factors and variables to a graph. This section discusses how to do that in Caesar.","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"The following sections discuss the steps required to construct a graph and solve it:","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Initialing the Factor Graph\nAdding Variables and Factors to the Graph\nSolving the Graph\nInforming the Solver About Ready Data","category":"page"},{"location":"concepts/building_graphs/#Familiar-Canonical-Factor-Graphs","page":"Building Factor Graphs","title":"Familiar Canonical Factor Graphs","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Starting with a shortcut to just quickly getting a small predefined canonical graph containing a few variables and factors can be done with (try tab-completion in the REPL):","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"fg = generateCanonicalFG_Kaess()\nfg = generateCanonicalFG_LineStep()\nfg = generateCanonicalFG_Hexagonal()\nfg = generateCanonicalFG_Circle()","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Any one of these function generate a standard factor graph object that is useful for orientation, testing, learning, or validation.  You can generate any of these factor graphs at any time, for example when quickly wanting to test some idea midway through building a more sophisiticated fg, you might just want to quickly do:","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"fg_ = generateCanonicalFG_Hexagonal()","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"and then work with fg_ to try out something risky.","category":"page"},{"location":"concepts/building_graphs/#Building-a-new-Graph","page":"Building Factor Graphs","title":"Building a new Graph","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"The first step is to model the data (using the most appropriate factors) among variables of interest.  To start model, first create a distributed factor graph object:","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"# start with an empty factor graph object\nfg = initfg()","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"initfg","category":"page"},{"location":"concepts/building_graphs/#IncrementalInference.initfg","page":"Building Factor Graphs","title":"IncrementalInference.initfg","text":"initfg()\ninitfg(dfg; sessionname, robotname, username, cloudgraph)\n\n\nInitialize an empty in-memory DistributedFactorGraph ::DistributedFactorGraph object.\n\n\n\n\n\n","category":"function"},{"location":"concepts/building_graphs/#Variables","page":"Building Factor Graphs","title":"Variables","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Variables (a.k.a. poses or states in navigation lingo) are created with the addVariable! fucntion call.","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"# Add the first pose :x0\naddVariable!(fg, :x0, Pose2)\n# Add a few more poses\nfor i in 1:10\n  addVariable!(fg, Symbol(\"x$(i)\"), Pose2)\nend","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Variables contain a label, a data type (e.g. in 2D RoME.Point2 or RoME.Pose2). Note that variables are solved - i.e. they are the product, what you wish to calculate when the solver runs - so you don't provide any measurements when creating them.","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"addVariable!\ndeleteVariable!","category":"page"},{"location":"concepts/building_graphs/#DistributedFactorGraphs.addVariable!","page":"Building Factor Graphs","title":"DistributedFactorGraphs.addVariable!","text":"Add a DFGVariable to a DFG.\n\n\n\n\n\naddVariable!(dfg, label, varTypeU; N, solvable, timestamp, nanosecondtime, dontmargin, labels, tags, smalldata, checkduplicates, initsolvekeys)\n\n\nAdd a variable node label::Symbol to dfg::AbstractDFG, as varType<:InferenceVariable.\n\nNotes\n\nkeyword nanosecondtime is experimental and intended as the whole subsection portion – i.e. accurateTime = (timestamp MOD second) + Nanosecond\n\nExample\n\nfg = initfg()\naddVariable!(fg, :x0, Pose2)\n\n\n\n\n\n","category":"function"},{"location":"concepts/building_graphs/#DistributedFactorGraphs.deleteVariable!","page":"Building Factor Graphs","title":"DistributedFactorGraphs.deleteVariable!","text":"deleteVariable!(dfg, label)\n\n\nDelete a DFGVariable from the DFG using its label.\n\n\n\n\n\ndeleteVariable!(dfg, variable)\n\n\nDelete a referenced DFGVariable from the DFG.\n\nNotes\n\nReturns Tuple{AbstractDFGVariable, Vector{<:AbstractDFGFactor}}\n\n\n\n\n\n","category":"function"},{"location":"concepts/building_graphs/#Initializing-Variables","page":"Building Factor Graphs","title":"Initializing Variables","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"The MM-iSAMv2 algorithm uses one of two approaches to automatically initialize variables.  The initManual! function can be used if you wish to overwrite or pre-empt this initialization.","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"initManual!","category":"page"},{"location":"concepts/building_graphs/#IncrementalInference.initManual!","page":"Building Factor Graphs","title":"IncrementalInference.initManual!","text":"initManual!(variable::DFGVariable, ptsArr::BallTreeDensity)\n\n\nMethod to manually initialize a variable using a set of points.\n\nNotes\n\nDisable automated graphinit on `addFactor!(fg, ...; graphinit=false)\nany un-initialized variables will automatically be initialized by solveTree!\n\nExample:\n\n# some variable is added to fg\naddVariable!(fg, :somepoint3, ContinuousEuclid{2})\n\n# data is organized as (row,col) == (dimension, samples)\npts = randn(2,100)\ninitManual!(fg, :somepoint3, pts)\n\n# manifold management should be done automatically.\n# note upgrades are coming to consolidate with Manifolds.jl, see RoME #244\n\n## it is also possible to initManual! by using existing factors, e.g.\ninitManual!(fg, :x3, [:x2x3f1])\n\nDevNotes\n\nTODO better document graphinit and treeinit.\n\n\n\n\n\n","category":"function"},{"location":"concepts/building_graphs/#Factors","page":"Building Factor Graphs","title":"Factors","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Factors are algebraic relationships between variables based on data cues such as sensor measurements. Examples of factors are absolute (pre-resolved) GPS readings (unary factors/priors) and odometry changes between pose variables. All factors encode a stochastic measurement (measurement + error), such as below, where a generic Prior belief is add to x0 (using the addFactor! call) as a normal distribution centered around [0,0,0].","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"addFactor!\ndeleteFactor!","category":"page"},{"location":"concepts/building_graphs/#DistributedFactorGraphs.addFactor!","page":"Building Factor Graphs","title":"DistributedFactorGraphs.addFactor!","text":"Add a DFGFactor to a DFG.\n\naddFactor!(dfg, factor)\n\n\n\n\n\n\naddFactor!(dfg, variables, factor)\n\n\n\n\n\n\naddFactor!(dfg, variableLabels, factor)\n\n\n\n\n\n\nAdd factor with user defined type <: FunctorInferenceType to the factor graph object. Define whether the automatic initialization of variables should be performed.  Use order sensitive multihypo keyword argument to define if any variables are related to data association uncertainty.\n\n\n\n\n\n","category":"function"},{"location":"concepts/building_graphs/#DistributedFactorGraphs.deleteFactor!","page":"Building Factor Graphs","title":"DistributedFactorGraphs.deleteFactor!","text":"Delete a DFGFactor from the DFG using its label.\n\n\n\n\n\nDelete the referened DFGFactor from the DFG.\n\n\n\n\n\n","category":"function"},{"location":"concepts/building_graphs/#Priors","page":"Building Factor Graphs","title":"Priors","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"# Add at a fixed location Prior to pin :x0 to a starting location (0,0,pi/6.0)\naddFactor!(fg, [:x0], PriorPose2( MvNormal([0; 0; pi/6.0], Matrix(Diagonal([0.1;0.1;0.05].^2)) )))","category":"page"},{"location":"concepts/building_graphs/#Factors-Between-Variables","page":"Building Factor Graphs","title":"Factors Between Variables","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"# Add odometry indicating a zigzag movement\nfor i in 1:10\n  pp = Pose2Pose2(MvNormal([10.0;0; (i % 2 == 0 ? -pi/3 : pi/3)], Matrix(Diagonal([0.1;0.1;0.1].^2))))\n  addFactor!(fg, [Symbol(\"x$(i-1)\"); Symbol(\"x$(i)\")], pp )\nend","category":"page"},{"location":"concepts/building_graphs/#[OPTIONAL]-Understanding-Internal-Factor-Naming-Convention","page":"Building Factor Graphs","title":"[OPTIONAL] Understanding Internal Factor Naming Convention","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"The factor name used by Caesar is automatically generated from ","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"addFactor!(fg, [:x0; :x1],...)","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"will create a factor with name :x0x1f1","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"When you were to add a another factor betweem :x0, :x1:","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"addFactor!(fg, [:x0; :x1],...)","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"will create a second factor with the name :x0x1f2.","category":"page"},{"location":"concepts/building_graphs/#Adding-Tags","page":"Building Factor Graphs","title":"Adding Tags","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"It is possible to add tags to variables and factors that make later graph management tasks easier, e.g.:","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"addVariable!(fg, :l7_3, Pose2, tags=[:APRILTAG; :LANDMARK])","category":"page"},{"location":"concepts/building_graphs/#Drawing-the-Factor-Graph","page":"Building Factor Graphs","title":"Drawing the Factor Graph","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Once you have a graph, you can visualize the graph as follows (beware though if the fg object is large):","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"# requires `sudo apt-get install graphviz\ndrawGraph(fg, show=true)","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"By setting show=true, the application evince will be called to show the fg.pdf file that was created using GraphViz.  A GraphPlot.jl visualization engine is also available.","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"using GraphPlot\ndfgplot(fg)","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"drawGraph","category":"page"},{"location":"concepts/building_graphs/#IncrementalInference.drawGraph","page":"Building Factor Graphs","title":"IncrementalInference.drawGraph","text":"drawGraph(fgl; viewerapp, filepath, engine, show)\n\n\nDraw and show the factor graph <:AbstractDFG via system graphviz and xdot app.\n\nNotes\n\nRequires system install on Linux of sudo apt-get install xdot\nShould not be calling outside programs.\nNeed long term solution\nDFG's toDotFile a better solution – view with xdot application.\nalso try engine={\"sfdp\",\"fdp\",\"dot\",\"twopi\",\"circo\",\"neato\"}\n\nNotes:\n\nCalls external system application xdot to read the .dot file format\ntoDot(fg,file=...); @async run(`xdot file.dot`)\n\nRelated\n\ndrawGraphCliq, drawTree, printCliqSummary, spyCliqMat\n\n\n\n\n\n","category":"function"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"For more details, see the DFG docs on Drawing Graphs.","category":"page"},{"location":"concepts/building_graphs/#When-to-Instantiate-Poses-(i.e.-new-Variables-in-Factor-Graph)","page":"Building Factor Graphs","title":"When to Instantiate Poses (i.e. new Variables in Factor Graph)","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Consider a robot traversing some area while exploring, localizing, and wanting to find strong loop-closure features for consistent mapping.  The creation of new poses and landmark variables is a trade-off in computational complexity and marginalization errors made during factor graph construction.  Common triggers for new poses are:","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Time-based trigger (eg. new pose a second or 5 minutes if stationary)\nDistance traveled (eg. new pose every 0.5 meters)\nRotation angle (eg. new pose every 15 degrees)","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Computation will progress faster if poses and landmarks are very sparse.  To extract the benefit of dense reconstructions, one approach is to use the factor graph as sparse index in history about the general progression of the trajectory and use additional processing from dense sensor data for high-fidelity map reconstructions.  Either interpolations, or better direct reconstructions from inertial data can be used for dense reconstruction.","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"For completeness, one could also re-project the most meaningful measurements from sensor measurements between pose epochs as though measured from the pose epoch.  This approach essentially marginalizes the local dead reckoning drift errors into the local interpose re-projections, but helps keep the pose count low.","category":"page"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"In addition, see fixed-lag discussion for limiting during inference the number of fluid variables manually to a user desired count.","category":"page"},{"location":"concepts/building_graphs/#Which-Variables-and-Factors-to-use","page":"Building Factor Graphs","title":"Which Variables and Factors to use","text":"","category":"section"},{"location":"concepts/building_graphs/","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"See the next page on available variables and factors","category":"page"},{"location":"dev/wiki/#Developers-Documentation","page":"Wiki Pointers","title":"Developers Documentation","text":"","category":"section"},{"location":"dev/wiki/#High-Level-Requirements","page":"Wiki Pointers","title":"High Level Requirements","text":"","category":"section"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"Wiki to formalize some of the overall objectives.","category":"page"},{"location":"dev/wiki/#Standardizing-the-API,-verbNoun-Definitions:","page":"Wiki Pointers","title":"Standardizing the API, verbNoun Definitions:","text":"","category":"section"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"The API derives from a set of standard definitions for verbs and Nouns, please see the developer wiki regarding these definitions.","category":"page"},{"location":"dev/wiki/#DistributedFactorGraphs.jl-Docs","page":"Wiki Pointers","title":"DistributedFactorGraphs.jl Docs","text":"","category":"section"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"These are more hardy developer docs, such as the lower level data management API etc.","category":"page"},{"location":"dev/wiki/#Design-Wiki,-Data-and-Architecture","page":"Wiki Pointers","title":"Design Wiki, Data and Architecture","text":"","category":"section"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"More developer zone material will be added here in the future, but for the time being check out the Caesar Wiki.","category":"page"},{"location":"dev/wiki/#Tree-and-CSM-References","page":"Wiki Pointers","title":"Tree and CSM References","text":"","category":"section"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"Major upgrades to how the tree and CSM works is tracked in IIF issue 889.","category":"page"},{"location":"dev/wiki/#Coding-Templates","page":"Wiki Pointers","title":"Coding Templates","text":"","category":"section"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"We've started to organize useful coding templates that are not available elsewhere (such as JuliaDocs) in a more local developers ","category":"page"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"Coding Templates Wiki I.\nCoding Templates Wiki II","category":"page"},{"location":"dev/wiki/#Shortcuts-for-vscode-IDE","page":"Wiki Pointers","title":"Shortcuts for vscode IDE","text":"","category":"section"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"See wiki","category":"page"},{"location":"dev/wiki/#Parametric-Solve-Whiteboard","page":"Wiki Pointers","title":"Parametric Solve Whiteboard","text":"","category":"section"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"https://github.com/JuliaRobotics/IncrementalInference.jl/wiki/Parametric-Solve-Whiteboard","category":"page"},{"location":"dev/wiki/#Early-PoC-work-on-Tree-based-Initialization","page":"Wiki Pointers","title":"Early PoC work on Tree based Initialization","text":"","category":"section"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"https://github.com/JuliaRobotics/IncrementalInference.jl/wiki/Tree-Based-Initialization","category":"page"},{"location":"dev/wiki/#Variable-Ordering-Links","page":"Wiki Pointers","title":"Variable Ordering Links","text":"","category":"section"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"Wiki for variable ordering links.","category":"page"},{"location":"dev/wiki/#Developer's-Poem","page":"Wiki Pointers","title":"Developer's Poem","text":"","category":"section"},{"location":"dev/wiki/","page":"Wiki Pointers","title":"Wiki Pointers","text":"Soft gitty, \nWarm gitty, \nMerging change, you sure?\nHappy travy, \nSleepy travy, \nPR PR PR ","category":"page"},{"location":"concepts/arena_visualizations/#Visualization-with-Arena.jl","page":"Visualization (3D)","title":"Visualization with Arena.jl","text":"","category":"section"},{"location":"concepts/arena_visualizations/","page":"Visualization (3D)","title":"Visualization (3D)","text":"The sections below discuss 3D visualization techniques available to the Caesar.jl robot navigation system. Caesar.jl uses the Arena.jl package for all the visualization requirements.  This part of the documentation discusses the robotic visualization aspects supported by Arena.jl. Arena.jl supports a wide variety of general visualization as well as developer visualization tools more focused on research and development. The visualizations are also intended to help with subgraph plotting for finding loop closures in data or compare two datasets.","category":"page"},{"location":"concepts/arena_visualizations/","page":"Visualization (3D)","title":"Visualization (3D)","text":"warning: Warning\nArena and Amphitheater are being upgraded as part of the broader migration to DistributedFactorGraphs (1Q20)","category":"page"},{"location":"concepts/arena_visualizations/#Introduction","page":"Visualization (3D)","title":"Introduction","text":"","category":"section"},{"location":"concepts/arena_visualizations/","page":"Visualization (3D)","title":"Visualization (3D)","text":"Over time, Caesar.jl/Arena.jl has used a least three different 3D visualization technologies, with the most recent based on WebGL and three.js by means of the MeshCat.jl package. The previous incarnation used a client side installation of VTK  by means of the DrakeVisualizer.jl and Director libraries. Different 2D plotting libraries have also been used, with evolutions to improve usability for a wider user base. Each epoch has been aimed at reducing dependencies and increasing multi-platform support.","category":"page"},{"location":"concepts/arena_visualizations/","page":"Visualization (3D)","title":"Visualization (3D)","text":"note: Note\nSee installation page for instructions.","category":"page"},{"location":"concepts/arena_visualizations/#D-Visualization","page":"Visualization (3D)","title":"3D Visualization","text":"","category":"section"},{"location":"concepts/arena_visualizations/","page":"Visualization (3D)","title":"Visualization (3D)","text":"warning: Warning\nThis section is out of date, see proof or concept examples in Amphitheater.jl (1Q20).","category":"page"},{"location":"concepts/arena_visualizations/","page":"Visualization (3D)","title":"Visualization (3D)","text":"Factor graphs of two or three dimensions can be visualized with the 3D visualizations provided by Arena.jl and it's dependencies. The 2D example above and also be visualized in a 3D space with the commands:","category":"page"},{"location":"concepts/arena_visualizations/","page":"Visualization (3D)","title":"Visualization (3D)","text":"vc = startdefaultvisualization() # to load a DrakeVisualizer/Director process instance\nvisualize(fg, vc, drawlandms=false)\n# visualizeallposes!(vc, fg, drawlandms=false)","category":"page"},{"location":"concepts/arena_visualizations/","page":"Visualization (3D)","title":"Visualization (3D)","text":"Here is a basic example of using visualization and multi-core factor graph solving:","category":"page"},{"location":"concepts/arena_visualizations/","page":"Visualization (3D)","title":"Visualization (3D)","text":"addprocs(2)\nusing Caesar, RoME, TransformUtils, Distributions\n\n# load scene and ROV model (might experience UDP packet loss LCM buffer not set)\nsc1 = loadmodel(:scene01); sc1(vc)\nrovt = loadmodel(:rov); rovt(vc)\n\ninitCov = 0.001*eye(6); [initCov[i,i] = 0.00001 for i in 4:6];\nodoCov = 0.0001*eye(6); [odoCov[i,i] = 0.00001 for i in 4:6];\nrangecov, bearingcov = 3e-4, 2e-3\n\n# start and add to a factor graph\nfg = identitypose6fg(initCov=initCov)\ntf = SE3([0.0;0.7;0.0], Euler(pi/4,0.0,0.0) )\naddOdoFG!(fg, Pose3Pose3(MvNormal(veeEuler(tf), odoCov) ) )\n\naddLinearArrayConstraint(fg, (4.0, 0.0), :x0, :l1, rangecov=rangecov,bearingcov=bearingcov)\naddLinearArrayConstraint(fg, (4.0, 0.0), :x1, :l1, rangecov=rangecov,bearingcov=bearingcov)\n\nsolveBatch!(fg)\n\nusing Arena\n\nvc = startdefaultvisualization()\nvisualize(fg, vc, drawlandms=true, densitymeshes=[:l1;:x2])\nvisualizeDensityMesh!(vc, fg, :l1)\n# visualizeallposes!(vc, fg, drawlandms=false)","category":"page"},{"location":"concepts/arena_visualizations/#Previous-3D-Viewer-(VTK-/-Director)-–-no-longer-required","page":"Visualization (3D)","title":"Previous 3D Viewer (VTK / Director) – no longer required","text":"","category":"section"},{"location":"concepts/arena_visualizations/","page":"Visualization (3D)","title":"Visualization (3D)","text":"Previous versions used the much larger VTK based Director available via DrakeVisualizer.jl package.  This requires the following preinstalled packages:","category":"page"},{"location":"concepts/arena_visualizations/","page":"Visualization (3D)","title":"Visualization (3D)","text":"    sudo apt-get install libvtk5-qt4-dev python-vtk","category":"page"},{"location":"concepts/interacting_fgs/#Factor-Graph-as-a-Whole","page":"Solving and Interacting","title":"Factor Graph as a Whole","text":"","category":"section"},{"location":"concepts/interacting_fgs/#Saving-and-Loading","page":"Solving and Interacting","title":"Saving and Loading","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"Assuming some factor graph object has been constructed by hand or automation, it is often very useful to be able to store that factor graph to file for later loading, solving, analysis etc.  Caesar.jl provides such functionality through easy saving and loading.  To save a factor graph, simply do:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"saveDFG(\"/somewhere/myfg\", fg)","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"saveDFG","category":"page"},{"location":"concepts/interacting_fgs/#DistributedFactorGraphs.saveDFG","page":"Solving and Interacting","title":"DistributedFactorGraphs.saveDFG","text":"saveDFG(folder, dfg)\n\n\nSave a DFG to a folder. Will create/overwrite folder if it exists.\n\nDevNotes:\n\nTODO remove compress kwarg.\n\nExample\n\nusing DistributedFactorGraphs, IncrementalInference\n# Create a DFG - can make one directly, e.g. LightDFG{NoSolverParams}() or use IIF:\ndfg = initfg()\n# ... Add stuff to graph using either IIF or DFG:\nv1 = addVariable!(dfg, :a, ContinuousScalar, tags = [:POSE], solvable=0)\n# Now save it:\nsaveDFG(dfg, \"/tmp/saveDFG.tar.gz\")\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"Similarly in the same or a new Julia context, you can load a factor graph object","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"# using Caesar\nfg_ = loadDFG(\"/somwhere/myfg\")","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"loadDFG\nloadDFG!","category":"page"},{"location":"concepts/interacting_fgs/#DistributedFactorGraphs.loadDFG","page":"Solving and Interacting","title":"DistributedFactorGraphs.loadDFG","text":"loadDFG(filename)\n\n\nConvenience wrapper to DFG.loadDFG! taking only one argument, the file name, to load a DFG object in standard format.\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/#DistributedFactorGraphs.loadDFG!","page":"Solving and Interacting","title":"DistributedFactorGraphs.loadDFG!","text":"loadDFG!(dfgLoadInto, dst)\n\n\nLoad a DFG from a saved folder. Always provide the IIF module as the second parameter.\n\nExample\n\nusing DistributedFactorGraphs, IncrementalInference\n# Create a DFG - can make one directly, e.g. LightDFG{NoSolverParams}() or use IIF:\ndfg = initfg()\n# Load the graph\nloadDFG!(dfg, \"/tmp/savedgraph.tar.gz\")\n# Use the DFG as you do normally.\nls(dfg)\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"note: Note\nJulia natively provides a direct in memory deepcopy function for making duplicate objects if you wish to keep a backup of the factor graph, e.g.fg2 = deepcopy(fg)","category":"page"},{"location":"concepts/interacting_fgs/#Adding-an-EntryData-Blob-store","page":"Solving and Interacting","title":"Adding an Entry=>Data Blob store","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"A later part of the documentation will show how to include a Entry=>Data blob store.","category":"page"},{"location":"concepts/interacting_fgs/#Querying-the-FactorGraph","page":"Solving and Interacting","title":"Querying the FactorGraph","text":"","category":"section"},{"location":"concepts/interacting_fgs/#List-Variables:","page":"Solving and Interacting","title":"List Variables:","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"A quick summary of the variables in the factor graph can be retrieved with:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"# List variables\nls(fg)\n# List factors attached to x0\nls(fg, :x0)\n# TODO: Provide an overview of getVal, getVert, getBW, getBelief, etc.","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"It is possible to filter the listing with Regex string:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"ls(fg, r\"x\\d\")","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"ls","category":"page"},{"location":"concepts/interacting_fgs/#DistributedFactorGraphs.ls","page":"Solving and Interacting","title":"DistributedFactorGraphs.ls","text":"List the DFGVariables in the DFG. Optionally specify a label regular expression to retrieves a subset of the variables. Tags is a list of any tags that a node must have (at least one match).\n\nNotes:\n\nReturns Vector{Symbol}\n\n\n\n\n\nls(dfg)\nls(dfg, node; solvable)\n\n\nRetrieve a list of labels of the immediate neighbors around a given variable or factor.\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"unsorted = intersect(ls(fg, r\"x\"), ls(fg, Pose2))  # by regex\n\n# sorting in most natural way (as defined by DFG)\nsorted = sortDFG(unsorted)","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"sortDFG","category":"page"},{"location":"concepts/interacting_fgs/#DistributedFactorGraphs.sortDFG","page":"Solving and Interacting","title":"DistributedFactorGraphs.sortDFG","text":"sortDFG(vars; by, kwargs...)\n\n\nConvenience wrapper for Base.sort. Sort variable (factor) lists in a meaningful way (by timestamp, label, etc), for example [:april;:x1_3;:x1_6;] Defaults to sorting by timestamp for variables and factors and using natural_lt for Symbols. See Base.sort for more detail.\n\nNotes\n\nNot fool proof, but does better than native sort.\n\nExample\n\nsortDFG(ls(dfg)) sortDFG(ls(dfg), by=getLabel, lt=natural_lt)\n\nRelated\n\nls, lsf\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/#List-Factors:","page":"Solving and Interacting","title":"List Factors:","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"unsorted = lsf(fg)\nunsorted = ls(fg, Pose2Point2BearingRange)","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"or using the tags (works for variables too):","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"lsf(fg, tags=[:APRILTAGS;])","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"lsf\nlsfPriors","category":"page"},{"location":"concepts/interacting_fgs/#DistributedFactorGraphs.lsf","page":"Solving and Interacting","title":"DistributedFactorGraphs.lsf","text":"lsf(dfg)\nlsf(dfg, regexFilter; tags, solvable)\n\n\nList the DFGFactors in the DFG. Optionally specify a label regular expression to retrieves a subset of the factors.\n\nNotes\n\nReturn Vector{Symbol}\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/#DistributedFactorGraphs.lsfPriors","page":"Solving and Interacting","title":"DistributedFactorGraphs.lsfPriors","text":"Return vector of prior factor symbol labels in factor graph dfg.\n\nNotes:\n\nReturns Vector{Symbol}\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"There are a variety of functions to query the factor graph, please refer to Function Reference for details and note that many functions still need to be added to this documentation.","category":"page"},{"location":"concepts/interacting_fgs/#Extracting-a-Subgraph","page":"Solving and Interacting","title":"Extracting a Subgraph","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"Sometimes it is useful to make a deepcopy of a segment of the factor graph for some purpose:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"sfg = buildSubgraph(fg, [:x1;:x2;:l7], 1)","category":"page"},{"location":"concepts/interacting_fgs/#Solving-Graphs","page":"Solving and Interacting","title":"Solving Graphs","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"When you have built the graph, you can call the solver to perform inference with the following:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"# Perform inference\ntree, smt, hist = solveTree!(fg)","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"The returned Bayes (Junction) tree object is described in more detail on a dedicated documentation page, while smt and hist return values most closely relate to development and debug outputs which can be ignored during general use.  Should an error occur during, the exception information is easily accessible in the smt object (as well as file logs which default to /tmp/caesar/).","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"solveTree!","category":"page"},{"location":"concepts/interacting_fgs/#IncrementalInference.solveTree!","page":"Solving and Interacting","title":"IncrementalInference.solveTree!","text":"solveTree!(dfgl)\nsolveTree!(dfgl, oldtree; timeout, storeOld, verbose, verbosefid, delaycliqs, recordcliqs, limititercliqs, injectDelayBefore, skipcliqids, eliminationOrder, variableOrder, eliminationConstraints, variableConstraints, smtasks, dotreedraw, runtaskmonitor, algorithm, multithread)\n\n\nPerform inference over the Bayes tree according to opt::SolverParams.\n\nNotes\n\nVariety of options, including fixed-lag solving – see getSolverParams(fg) for details.\nSee online Documentation for more details: https://juliarobotics.org/Caesar.jl/latest/\nLatest result always stored in solvekey=:default.\nExperimental storeOld::Bool=true will duplicate the current result as supersolve :default_k.\nBased on solvable==1 assumption.\nlimititercliqs allows user to limit the number of iterations a specific CSM does.\nkeywords verbose and verbosefid::IOStream can be used together to to send output to file or default stdout.\nkeyword recordcliqs=[:x0; :x7...] identifies by frontals which cliques to record CSM steps.\nSee repeatCSMStep!, printCSMHistoryLogical, printCSMHistorySequential\n\nExample\n\n# pass in old `tree` to enable compute recycling -- see online Documentation for more details\ntree, smt, hist = solveTree!(fg [,tree])\n\nRelated\n\nsolveCliq!, buildTreeReset!, repeatCSMStep, printCSMHistoryLogical\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/#Using-Incremental-Updates-(Clique-Recycling-I)","page":"Solving and Interacting","title":"Using Incremental Updates (Clique Recycling I)","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"One of the major features of the MM-iSAMv2 algorithm (implemented by IncrementalInference.jl) is reducing computational load by recycling and marginalizing different (usually older) parts of the factor graph.  In order to utilize the benefits of recycing, the previous Bayes (Junction) tree should also be provided as input (see fixed-lag examples for more details):","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"tree, smt, hist = solveTree!(fg, tree)","category":"page"},{"location":"concepts/interacting_fgs/#Using-Clique-out-marginalization-(Clique-Recycling-II)","page":"Solving and Interacting","title":"Using Clique out-marginalization (Clique Recycling II)","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"When building sysmtes with limited computation resources, the out-marginalization of cliques on the Bayes tree can be used.  This approach limits the amount of variables that are inferred on each solution of the graph.  This method is also a compliment to the above Incremental Recycling – these two methods can work in tandem.  There is a default setting for a FIFO out-marginalization strategy (with some additional tricks):","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"defaultFixedLagOnTree!(fg, 50, limitfixeddown=true)","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"This call will keep the latest 50 variables fluid for inference during Bayes tree inference.  The keyword limitfixeddown=true in this case will also prevent downward message passing on the Bayes tree from propagating into the out-marginalized branches on the tree.  A later page in this documentation will discuss how the inference algorithm and Bayes tree aspects are put together.","category":"page"},{"location":"concepts/interacting_fgs/#Extracting-Belief-Results-(and-PPE)","page":"Solving and Interacting","title":"Extracting Belief Results (and PPE)","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"Once you have solved the graph, you can review the full marginal with:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"X0 = getBelief(fg, :x0)\n# Evaluate the marginal density function just for fun at [0.0, 0, 0].\nX0(zeros(3,1))","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"This object is currently a Kernel Density which contains kernels at specific points on the associated manifold.  These kernel locations can be retrieved with:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"X0pts = getPoints(X0)","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"getBelief","category":"page"},{"location":"concepts/interacting_fgs/#IncrementalInference.getBelief","page":"Solving and Interacting","title":"IncrementalInference.getBelief","text":"getBelief(vnd)\n\n\nGet KernelDensityEstimate kde estimate stored in variable node.\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/#Parametric-Point-Estimates-(PPE)","page":"Solving and Interacting","title":"Parametric Point Estimates (PPE)","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"Since Caesar.jl is build around the each variable state being estimated as a total marginal posterior belief, it is often useful to get the equivalent parametric point estimate from the belief.  Many of these computations are already done by the inference library and avalable via the various getPPE methods, e.g.:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"getPPE(fg, :l3)\ngetPPESuggested(fg, :l5)","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"There are values for mean, max, or hybrid combinations.","category":"page"},{"location":"concepts/interacting_fgs/#Getting-Many-Marginal-Samples","page":"Solving and Interacting","title":"Getting Many Marginal Samples","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"It is also possible to sample the above belief objects for more samples:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"pts = rand(X0, 200)","category":"page"},{"location":"concepts/interacting_fgs/#Building-On-Manifold-KDEs","page":"Solving and Interacting","title":"Building On-Manifold KDEs","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"These kernel density belief objects can be constructed from points as follows:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"X0_ = manikde!(pts, Pose2)","category":"page"},{"location":"concepts/interacting_fgs/#Logging-Output-(Unique-Folder)","page":"Solving and Interacting","title":"Logging Output (Unique Folder)","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"Each new factor graph is designated a unique folder in /tmp/caesar.  This is usaully used for debugging or large scale test analysis.  Sometimes it may be useful for the user to also use this temporary location.  The location is stored in the SolverParams:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"getSolverParams(fg).logpath","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"The functions of interest are:","category":"page"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"getLogPath\njoinLogPath","category":"page"},{"location":"concepts/interacting_fgs/#IncrementalInference.getLogPath","page":"Solving and Interacting","title":"IncrementalInference.getLogPath","text":"getLogPath(opt)\n\n\nGet the folder location where debug and solver information is recorded for a particular factor graph.\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/#IncrementalInference.joinLogPath","page":"Solving and Interacting","title":"IncrementalInference.joinLogPath","text":"joinLogPath(opt, str)\n\n\nAppend str onto factor graph log path as convenience function.\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"note: Note\nA useful tip for doing large scale processing might be to reduce amount of write operations to a solid-state drive that will be written to default location /tmp/caesar by simplying adding a symbolic link to a USB drive or SDCard, perhaps similar to:cd /tmp\nmkdir -p /media/MYFLASHDRIVE/caesar\nln -s /media/MYFLASHDRIVE/caesar caesar","category":"page"},{"location":"concepts/interacting_fgs/#Other-Useful-Functions","page":"Solving and Interacting","title":"Other Useful Functions","text":"","category":"section"},{"location":"concepts/interacting_fgs/","page":"Solving and Interacting","title":"Solving and Interacting","text":"getFactorDim\ngetManifolds","category":"page"},{"location":"concepts/interacting_fgs/#IncrementalInference.getFactorDim","page":"Solving and Interacting","title":"IncrementalInference.getFactorDim","text":"getFactorDim(w::Vararg{Any,N} where N) -> Any\n\n\nReturn the number of dimensions this factor vertex fc influences.\n\n\n\n\n\n","category":"function"},{"location":"concepts/interacting_fgs/#DistributedFactorGraphs.getManifolds","page":"Solving and Interacting","title":"DistributedFactorGraphs.getManifolds","text":"Interface function to return the variableType manifolds of an InferenceVariable, extend this function for all Types<:InferenceVariable.\n\n\n\n\n\n","category":"function"},{"location":"examples/custom_variables/#Creating-New-Variables","page":"Creating Variables","title":"Creating New Variables","text":"","category":"section"},{"location":"examples/custom_variables/","page":"Creating Variables","title":"Creating Variables","text":"A handy macro can help define new variables which shows a Pose2 example with 3 degrees of freedom: X, Y, theta:","category":"page"},{"location":"examples/custom_variables/","page":"Creating Variables","title":"Creating Variables","text":"@defVariable","category":"page"},{"location":"examples/custom_variables/#DistributedFactorGraphs.@defVariable","page":"Creating Variables","title":"DistributedFactorGraphs.@defVariable","text":"@defVariable StructName dimension manifolds A macro to create a new variable with name StructName, dimension and manifolds. Example:\n\nDFG.@defVariable Pose2 3 (:Euclid, :Euclid, :Circular)\n\n\n\n\n\n","category":"macro"},{"location":"examples/custom_variables/","page":"Creating Variables","title":"Creating Variables","text":"The macro generates the necessary code for IncrementalInference to be able to use a new user defined variable – e.g.:","category":"page"},{"location":"examples/custom_variables/","page":"Creating Variables","title":"Creating Variables","text":"addVariable!(fg, :x0, MyVariable)","category":"page"},{"location":"examples/custom_variables/","page":"Creating Variables","title":"Creating Variables","text":"note: Note\nSee RoME.jl#244 regarding plans to fundamentally integrate with Manifolds.jl","category":"page"},{"location":"examples/custom_variables/","page":"Creating Variables","title":"Creating Variables","text":"The format for defining manifolds is likely to change in the near future (2021Q1), where manual descriptions like (:Euclid, :Euclid, :Circular) will be replaced with a more formal definition like SE2 or Manifolds.ProductRepr(Euclid{2}, Rotation).","category":"page"},{"location":"refs/literature/#Literature","page":"References","title":"Literature","text":"","category":"section"},{"location":"refs/literature/","page":"References","title":"References","text":"Newly created page to list related references and additional literature pertaining to this package.","category":"page"},{"location":"refs/literature/#Direct-References","page":"References","title":"Direct References","text":"","category":"section"},{"location":"refs/literature/","page":"References","title":"References","text":"[1.1]  Fourie, D., Leonard, J., Kaess, M.: \"A Nonparametric Belief Solution to the Bayes Tree\" IEEE/RSJ Intl. Conf. on Intelligent Robots and Systems (IROS), (2016).","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[1.2]  Fourie, D.: \"Multi-modal and Inertial Sensor Solutions for Navigation-type Factor   Graphs\", Ph.D. Thesis, Massachusetts Institute of Technology Electrical Engineering and Computer Science together with Woods Hole Oceanographic Institution Department for Applied Ocean Science and Engineering, September 2017.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[1.3]  Fourie, D., Claassens, S., Pillai, S., Mata, R., Leonard, J.: \"SLAMinDB: Centralized graph databases for mobile robotics\", IEEE Intl. Conf. on Robotics and Automation (ICRA), Singapore, 2017.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[1.4]  Cheung, M., Fourie, D., Rypkema, N., Vaz Teixeira, P., Schmidt, H., and Leonard, J.: \"Non-Gaussian SLAM utilizing Synthetic Aperture Sonar\", Intl. Conf. On Robotics and Automation (ICRA), IEEE, Montreal, 2019.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[1.5]  Doherty, K., Fourie, D., Leonard, J.: \"Multimodal Semantic SLAM with Probabilistic Data Association\", Intl. Conf. On Robotics and Automation (ICRA), IEEE, Montreal, 2019.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[1.6]  Fourie, D., Vaz Teixeira, P., Leonard, J.: \"Non-parametric Mixed-Manifold Products using Multiscale Kernel Densities\", IEEE Intl. Conf. on Intelligent Robots and Systems (IROS), (2019),.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[1.7]  Teixeira, P.N.V., Fourie, D., Kaess, M. and Leonard, J.J., 2019, September. \"Dense, sonar-based reconstruction of underwater scenes\". In 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 8060-8066). IEEE.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[1.8]  Fourie, D., Leonard, J.: \"Inertial Odometry with Retroactive Sensor Calibration\", 2015-2019.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[1.9] Koolen, T. and Deits, R., 2019. Julia for robotics: Simulation and real-time control in a high-level programming language. IEEE, Intl. Conference on Robotics and Automation, ICRA (2019).","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[1.10] Fourie, D., Teran E., A., Kaess, M., and Leonard, J. J., “Characterizing marginalization and incremental operations on the Bayes tree,” in International Workshop on Algorithmic Foundations of Robotics (WAFR), 2020, Oulu, Finland, Springer Publishing.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[1.11]  Fourie, D., Rypkema, N., Claassens, S., Vaz Teixeira, P., Fischell, E., and Leonard, J.J., \"Towards Real-Time Non-Gaussian SLAM for Underdetermined Navigation\", in IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), October 2020, Las Vegas, USA.","category":"page"},{"location":"refs/literature/#Important-References","page":"References","title":"Important References","text":"","category":"section"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.1]  Kaess, Michael, et al. \"iSAM2: Incremental smoothing and mapping using the Bayes tree\" The International Journal of Robotics Research (2011): 0278364911430419.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.2]  Kaess, Michael, et al. \"The Bayes tree: An algorithmic foundation for probabilistic robot mapping.\" Algorithmic Foundations of Robotics IX. Springer, Berlin, Heidelberg, 2010. 157-173.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.3]  Kschischang, Frank R., Brendan J. Frey, and Hans-Andrea Loeliger. \"Factor graphs and the sum-product algorithm.\" IEEE Transactions on information theory 47.2 (2001): 498-519.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.4]  Dellaert, Frank, and Michael Kaess. \"Factor graphs for robot perception.\" Foundations and Trends® in Robotics 6.1-2 (2017): 1-139.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.5]  Sudderth, E.B., Ihler, A.T., Isard, M., Freeman, W.T. and Willsky, A.S., 2010. \"Nonparametric belief propagation.\" Communications of the ACM, 53(10), pp.95-103","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.6] Paskin, Mark A. \"Thin junction tree filters for simultaneous localization and mapping.\" in Int. Joint Conf. on Artificial Intelligence. 2003.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.7]  Farrell, J., and Matthew B.: \"The global positioning system and inertial navigation.\" Vol. 61. New York: Mcgraw-hill, 1999.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.8]  Zarchan, Paul, and Howard Musoff, eds. Fundamentals of Kalman filtering: a practical approach. American Institute of Aeronautics and Astronautics, Inc., 2013.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.9]  Rypkema, N. R.,: \"Underwater & Out of Sight: Towards Ubiquity in UnderwaterRobotics\", Ph.D. Thesis, Massachusetts Institute of Technology Electrical Engineering and Computer Science together with Woods Hole Oceanographic Institution Department for Applied Ocean Science and Engineering, September 2019.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.10] Vaz Teixeira, P.: \"Dense, Sonar-based Reconstruction of Underwater Scenes\", Ph.D. Thesis, Massachusetts Institute of Technology Electrical Engineering and Computer Science together with Woods Hole Oceanographic Institution Department for Applied Ocean Science and Engineering, September 2019.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.11] Hanebeck, Uwe D. \"FLUX: Progressive State Estimation Based on Zakai-type Distributed Ordinary Differential Equations.\" arXiv preprint arXiv:1808.02825 (2018).","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.12] Muandet, Krikamol, et al. \"Kernel mean embedding of distributions: A review and beyond.\" Foundations and Trends® in Machine Learning 10.1-2 (2017): 1-141.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.13] Hsiao, M. and Kaess, M., 2019, May. MH-iSAM2: Multi-hypothesis iSAM using Bayes Tree and Hypo-tree. In 2019 International Conference on Robotics and Automation (ICRA) (pp. 1274-1280). IEEE.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[2.14] Arnborg, S., Corneil, D.G. and Proskurowski, A., 1987. Complexity of finding embeddings in a k-tree. SIAM Journal on Algebraic Discrete Methods, 8(2), pp.277-284.","category":"page"},{"location":"refs/literature/#Additional-References","page":"References","title":"Additional References","text":"","category":"section"},{"location":"refs/literature/","page":"References","title":"References","text":"[3.1]  Duits, Remco, Erik J. Bekkers, and Alexey Mashtakov. \"Fourier Transform on the Homogeneous Space of 3D Positions and Orientations for Exact Solutions to Linear Parabolic and (Hypo-) Elliptic PDEs.\" arXiv preprint arXiv:1811.00363 (2018).","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[3.2]  Mohamed, S., Rosca, M., Figurnov, M. and Mnih, A., 2019. Monte carlo gradient estimation in machine learning. arXiv preprint arXiv:1906.10652.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[3.3]  Rackauckas, C., Ma, Y., Martensen, J., Warner, C., Zubov, K., Supekar, R., Skinner, D., Ramadhan, A., Edelman, A., \"Universal Differential Equations for Scientific Machine Learning\", Archive online, DOI: 2001.04385.","category":"page"},{"location":"refs/literature/#Signal-Processing-(Beamforming-and-Channel-Deconvolution)","page":"References","title":"Signal Processing (Beamforming and Channel Deconvolution)","text":"","category":"section"},{"location":"refs/literature/","page":"References","title":"References","text":"[4.1]  Van Trees, H.L., 2004. Optimum array processing: Part IV of detection, estimation, and modulation theory. John Wiley & Sons.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[4.2a]  Dowling, D.R., 2013. Acoustic Blind Deconvolution and Unconventional Nonlinear Beamforming in Shallow Ocean Environments. MICHIGAN UNIV ANN ARBOR DEPT OF MECHANICAL ENGINEERING.","category":"page"},{"location":"refs/literature/","page":"References","title":"References","text":"[4.2b]  Hossein Abadi, S., 2013. Blind deconvolution in multipath environments and extensions to remote source localization, paper, thesis.","category":"page"},{"location":"principles/approxConvDensities/#Principle:-Approximate-Convolutions","page":"Generic Convolutions","title":"Principle: Approximate Convolutions","text":"","category":"section"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"This example illustrates a central concept of approximating the convolution of belief density functions.  Convolutions are required to compute (estimate) the probabilistic chain rule with conditional probability density functions.  One easy illustration is robotics where an odometry chain of poses has a continuous increase–-or spreading–-of the confidence/uncertainty of a next pose.  This tutorial will demonstrate that process.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"This page describes a Julia language interface, followed by a CaesarZMQ interface; a link to the mathematical description is provided thereafter.","category":"page"},{"location":"principles/approxConvDensities/#Convolutions-of-Infinite-Objects-(Functionals)","page":"Generic Convolutions","title":"Convolutions of Infinite Objects (Functionals)","text":"","category":"section"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"Consider the following vehicle odometry prediction (probabilistic) operation, where odometry measurement Z is an independent stochastic process from prior belief on pose X0","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"p(X_1  X_0 Z) propto p(Z  X_0 X_1) p(X_0)","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"and recognize this process as a convolution operation where the prior belief on X0 is spread to a less certain prediction of pose X1.  The figure below shows an example quasi-deterministic convolution of green densitty with the red density, which results in the black density below:","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"<a href=\"https://darchive.mblwhoilibrary.org/bitstream/handle/1912/9305/Fourie_thesis.pdf?sequence=1\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/6412556/61175404-3b4f9d80-a59e-11e9-85db-ca6bbdb73ffd.png\" alt=\"Bayes/Junction tree example\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"Note that this operation is precisely the same as a prediction step in filtering applications, where the state transition model–-usually annotated as d/dt x = f(x, z)–-is here presented by the conditional belief p(Z | X_0, X_1).","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"The convolution computation described above is a core operation required for solving the Chapman-Kolmogorov transit equations.","category":"page"},{"location":"principles/approxConvDensities/#Underlying-Mathematical-Operations","page":"Generic Convolutions","title":"Underlying Mathematical Operations","text":"","category":"section"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"In order to compute generic convolutions, the mmisam algorithm uses non-linear gradient descent to resolve estimates of the target variable based on the values of other dependent variables.  The conditional likelihood (multidimensional factor) is based on a residual function:","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"z_i = delta_i (theta_i)","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"where z_i is the innovation of any smooth twice differentiable residual function delta.  The residual function depends on specific variables collected as theta_i.  The IIF code supports both root finding or minimization trust-region operations, which are each provided by NLsolve.jl or Optim.jl packages respectively.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"The choice between root finding or minimization is a performance consideration only.  Minimization of the residual squared will always work but certain situations allow direct root finding to be used.  If the residual function is guaranteed to cross zero–-i.e. z*=0–-the root finding approach can be used.  Each measurement function has a certain number of dimensions – e.g. ranges or bearings are dimension one, and an inter Pose2 rigid transform (delta x, y, theta) is dimension 3.  If the variable being resolved has larger dimension than the measurement residual, then the minimization approach must be used.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"The method of solving the target variable is to fix all other variable values and resolve, sample by sample, the particle estimates of the target.  The Julia programming language has good support for functional programming and is used extensively in the IIF implementation to utilize user defined functions to resolve any variable, including the null-hypothesis and multi-hypothesis generalizations.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"The following section illustrates a single convolution operation by using a few high level and some low level function calls.  An additional tutorial exists where a related example in one dimension is performed as a complete factor graph solution/estimation problem.","category":"page"},{"location":"principles/approxConvDensities/#Previous-Text-(to-be-merged-here)","page":"Generic Convolutions","title":"Previous Text (to be merged here)","text":"","category":"section"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"Proposal distributions are computed by means of (analytical or numerical – i.e. \"algebraic\") factor which defines a residual function:","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"delta  S times Eta rightarrow mathcalR","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"where S times Eta is the domain such that theta_i in S  eta sim P(Eta), and P(cdot) is a probability.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"A trust-region, nonlinear gradient decent method is used to enforce the residual function delta (theta_S) in a leave-one-out-Gibbs strategy for all the factors and variables in each clique.  Each time a factor residual is enforced for another particle along with a sample from the stochastic noise term.  Solutions are found either through root finding on \"full dimension\" equations (source code here):","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"textsolve_theta_i  st  0 = delta(theta_S eta)","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"Or minimization of \"low dimension\" equations (source code here) that might not have any roots in theta_i:","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"textargmin_theta_i  delta(theta_S eta)^2","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"Gradient decent methods are obtained from the Julia Package community, namely NLsolve.jl and Optim.jl.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"The factor noise term can be any samplable belief (a.k.a. IIF.SamplableBelief), either through algebraic modeling, or (critically) directly from the sensor measurement that is driven by the underlying physics process.  Parametric factors (Distributions.jl) or direct physical measurement noise can be used via AliasingScalarSampler or KernelDensityEstimate.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"note: Note\nAlso see [1.2], Chap. 5, Approximate Convolutions for more details.","category":"page"},{"location":"principles/approxConvDensities/#Illustrated-Calculation-in-Julia","page":"Generic Convolutions","title":"Illustrated Calculation in Julia","text":"","category":"section"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"The IncrementalInference.jl package provides a generic interface for estimating the convolution of full functional objects given some user specified residual or cost function.  The residual/cost function is then used, with the help of non-linear gradient decent, to project/resolve a set of particles for any one variable associated with a any factor.  In the binary variable factor case, such as the odometry tutorial, either pose X2 will be resolved from X1 using the user supplied likelihood residual function, or visa versa for X1 from X2.  ","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"note: Note\nNote in a factor graph sense, the flow of time is captured in the structure of the graph and a requirement of the IncrementalInference system is that factors can be resolved towards any variable, given current estimates on all other variables connected to that factor.  Furthermore, this forwards or backwards resolving/convolution through a factor should adhere to the Kolmogorov Criterion of reversibility to ensure that detailed balance is maintained in the overall marginal posterior solutions.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"The IncrementalInference (IIF) package provides a few generic conditional likelihood functions such as LinearRelative or MixtureRelative which we will use in this illustration.  ","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"note: Note\nNote that the RoME.jl package provides many more factors that are useful to robotics applications.  For a listing of current factors see this docs page, details on developing your own factors on this page.  One of the clear design objectives of the IIF package was to allow easier user extension of arbitrary residual functions that allows for vast capacity to represent non-Gaussian stochastic processes.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"Consider a robot traveling in one dimension, progressing along the x-axis at varying speed.  Lets assume pose locations are determined by a constant delta-time rule of say one pose every second, named X0, X1, X2, and so on.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"note: Note\nNote the bread-crum discretization of the trajectory history by means of poses can later be used to allow estimation of previously unknown mapping parameters simultaneous to the ongoing localization problem.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"Lets a few basic factor graph operations to develop the desired convolutions:","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"using IncrementalInference\n\n# empty factor graph container\nfg = initfg()\n\n# add two variables of interest\naddVariable!(fg, :x0, ContinuousScalar)\naddVariable!(fg, :x1, ContinuousScalar)\n\n# gauge the solution by adding the first prior information that represents all history up to the current starting position for the robot\npr = Prior(Normal(0.0, 0.1))\naddFactor!(fg, [:x0], pr)\n\n# numerically initialize variable :x0 -- this avoids repeat computations later (specific to this tutorial)\ndoautoinit!(fg, :x0)\n\n# lastly add the odometry conditional likelihood function between the two variables of interest\nodo = LinearConditional(Rayleigh(...))\naddFactor!(fg, [:x0;:x1], odo)  # note the list is order sensitive","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"The code block above (not solved yet) describes a algebraic setup exactly equivalent to the convolution equation presented at the top of this page.  ","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"note: Note\nIIF does not require the distribution functions to only be parametric, such as Normal, Rayleigh, mixture models, but also allows intensity based values or kernel density estimates.  Parametric types are just used here for ease of illustration.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"To perform an stochastic approximate convolution with the odometry conditional, one can simply call a low level function used the mmisam solver:","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"pts = approxConv(fg, :x0x1f1, :x1)","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"The approxConv function call reads as a operation on fg which won't influence any values of parameter list (common Julia exclamation mark convention) and must use the first factor :x0x1f1 to resolve a convolution on target variable :x1.  Implicitly, this result is based on the current estimate contained in :x0.  The value of pts is a :;Array{Float64,2} where the rows represent the different dimensions (1-D in this case) and the columns are each of the different samples drawn from the intermediate posterior (i.e. convolution result).  ","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"approxConv","category":"page"},{"location":"principles/approxConvDensities/#IncrementalInference.approxConv","page":"Generic Convolutions","title":"IncrementalInference.approxConv","text":"approxConv(dfg, from, target)\napproxConv(dfg, from, target, measurement; N, solveKey, tfg, setPPEmethod, setPPE, path)\n\n\nCalculate the sequential series of convolutions in order as listed by fctLabels, and starting from the  value already contained in the first variable.  \n\nNotes\n\nThe ultimate target variable must be given to allow path discovery through n-ary factors.\nFresh starting point will be used if first element in fctLabels is a unary <:AbstractPrior.\nThis function will not change any values in dfg, and might have slightly less speed performance to meet this requirement.\npass in tfg to get a recoverable result of all convolutions in the chain.\nsetPPE and setPPEmethod can be used to store PPE information in temporary tfg\n\nDevNotes\n\nTODO strong requirement that this function is super efficient on single factor/variable case!\nFIXME must consolidate with accumulateFactorMeans\nTODO solveKey not fully wired up everywhere yet\ntfg gets all the solveKeys inside the source dfg variables\nTODO add a approxConv on PPE option\nConsolidate with accumulateFactorMeans, approxConvBinary\n\nRelated\n\napproxDeconv, LightDFG.findShortestPathDijkstra, evalFactor\n\n\n\n\n\n","category":"function"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"IIF currently uses kernel density estimation to convert discrete samples into a smooth function estimate – more details can be found on the function approximation principles page here.  The sample set can be converted into an on-manifold functional object as follows:","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"# create kde object by referencing back the existing memory location pts\nhatX1 = manikde!(pts, ContinuousScalar)","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"The functional object X1 is now ready for other operations such as function evaluation or product computations discussed on another principles page.  The ContinuousScalar manifold is just the real line in Euclidean space, internally denoted as single element tuple (:Euclid,).","category":"page"},{"location":"principles/approxConvDensities/#A-Handy-ZMQ-interface-to-Generic-Convolutions","page":"Generic Convolutions","title":"A Handy ZMQ interface to Generic Convolutions","text":"","category":"section"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"NOTE WIP on expanding ZMQ interface:","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"In addition, ZmqCaesar offers a ZMQ interface to the factor graph solution for multilanguage support.  This example is a small subset that shows how to use the ZMQ infrastructure, but avoids the larger factor graph related calls.","category":"page"},{"location":"principles/approxConvDensities/","page":"Generic Convolutions","title":"Generic Convolutions","text":"...","category":"page"},{"location":"concepts/available_varfacs/#Variables-in-Caesar.jl","page":"Internal Variables/Factors","title":"Variables in Caesar.jl","text":"","category":"section"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"You can check for the latest variable types by running the following in your terminal:","category":"page"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"using RoME, Caesar\nsubtypes(IncrementalInference.InferenceVariable)\nIncrementalInference.getCurrentWorkspaceVariables()","category":"page"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"note: Note\nMore variables and factors exists, but are not yet included in the standard library.  It is fairly straight forward to build your own out-of-library factors, see page Creating New Variables and Factors for more details.","category":"page"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"Default variables in IncrementalInference","category":"page"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"ContinuousScalar\nContinuousEuclid{N}","category":"page"},{"location":"concepts/available_varfacs/#IncrementalInference.ContinuousScalar","page":"Internal Variables/Factors","title":"IncrementalInference.ContinuousScalar","text":"struct ContinuousScalar <: InferenceVariable\n\nMost basic continuous scalar variable in a ::DFG.AbstractDFG object.\n\nDevNotes\n\nTODO Consolidate with ContinuousEuclid{1}\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#IncrementalInference.ContinuousEuclid","page":"Internal Variables/Factors","title":"IncrementalInference.ContinuousEuclid","text":"ContinuousEuclid{N}\n\nContinuous Euclidean variable of dimension N.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#D-Variables","page":"Internal Variables/Factors","title":"2D Variables","text":"","category":"section"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"The current variables types are:","category":"page"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"Point2\nPose2\nDynPoint2\nDynPose2","category":"page"},{"location":"concepts/available_varfacs/#RoME.Point2","page":"Internal Variables/Factors","title":"RoME.Point2","text":"struct Point2 <: InferenceVariable\n\nXY Euclidean manifold variable node softtype.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2","page":"Internal Variables/Factors","title":"RoME.Pose2","text":"struct Pose2 <: InferenceVariable\n\nPose2 is a SE(2) mechanization of two Euclidean translations and one Circular rotation, used for general 2D SLAM.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPoint2","page":"Internal Variables/Factors","title":"RoME.DynPoint2","text":"struct DynPoint2 <: InferenceVariable\n\nDynamic point in 2D space with velocity components: x, y, dx/dt, dy/dt\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPose2","page":"Internal Variables/Factors","title":"RoME.DynPose2","text":"struct DynPose2 <: InferenceVariable\n\nDynamic pose variable with velocity components: x, y, theta, dx/dt, dy/dt\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#D-Variables-2","page":"Internal Variables/Factors","title":"3D Variables","text":"","category":"section"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"Point3\nPose3\nInertialPose3","category":"page"},{"location":"concepts/available_varfacs/#RoME.Point3","page":"Internal Variables/Factors","title":"RoME.Point3","text":"struct Point3 <: InferenceVariable\n\nXYZ Euclidean manifold variable node softtype.\n\nExample\n\np3 = Point3()\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose3","page":"Internal Variables/Factors","title":"RoME.Pose3","text":"struct Pose3 <: InferenceVariable\n\nPose3 is currently a Euler angle mechanization of three Euclidean translations and three Circular rotation.\n\nFuture:\n\nWork in progress on AMP3D for proper non-Euler angle on-manifold operations.\nTODO the AMP upgrade is aimed at resolving 3D to Quat/SE3/SP3 – current Euler angles will be replaced\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.InertialPose3","page":"Internal Variables/Factors","title":"RoME.InertialPose3","text":"mutable struct InertialPose3 <: AbstractRelativeRoots\n\nInertial Odometry version of preintegration procedure and used as a factor between InertialPose3 types for inertial navigation in factor graphs.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"note: Note\nPlease open an issue with JuliaRobotics/RoME.jl for specific requests, problems, or suggestions.  Contributions are also welcome.  There might be more variable types in Caesar/RoME/IIF not yet documented here.","category":"page"},{"location":"concepts/available_varfacs/#Factors-in-Caesar.jl","page":"Internal Variables/Factors","title":"Factors in Caesar.jl","text":"","category":"section"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"You can check for the latest factor types by running the following in your terminal:","category":"page"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"using RoME, Caesar\nprintln(\"- Singletons (priors): \")\nprintln.(sort(string.(subtypes(IIF.AbstractPrior))));\nprintln(\"- Pairwise (variable constraints): \")\nprintln.(sort(string.(subtypes(IIF.AbstractRelativeRoots))));\nprintln(\"- Pairwise (variable minimization constraints): \")\nprintln.(sort(string.(subtypes(IIF.AbstractRelativeMinimize))));","category":"page"},{"location":"concepts/available_varfacs/#Priors-(Absolute-Data)","page":"Internal Variables/Factors","title":"Priors (Absolute Data)","text":"","category":"section"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"Defaults in IncrementalInference.jl:","category":"page"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"Prior\nPartialPrior","category":"page"},{"location":"concepts/available_varfacs/#IncrementalInference.Prior","page":"Internal Variables/Factors","title":"IncrementalInference.Prior","text":"struct Prior{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractPrior\n\nDefault prior on all dimensions of a variable node in the factor graph.  Prior is not recommended when non-Euclidean dimensions are used in variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#IncrementalInference.PartialPrior","page":"Internal Variables/Factors","title":"IncrementalInference.PartialPrior","text":"struct PartialPrior{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}, P<:Tuple} <: AbstractPrior\n\nPartial prior belief (absolute data) on any variable, given <:SamplableBelief and which dimensions of the intended variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"Some of the most common priors (unary factors) in Caesar.jl/RoME.jl include:","category":"page"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"PriorPolar\nPriorPoint2\nPriorPose2\nPriorPoint3\nPriorPose3","category":"page"},{"location":"concepts/available_varfacs/#RoME.PriorPolar","page":"Internal Variables/Factors","title":"RoME.PriorPolar","text":"mutable struct PriorPolar{T1<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}, T2<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractPrior\n\nPrior belief on any Polar related variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPoint2","page":"Internal Variables/Factors","title":"RoME.PriorPoint2","text":"mutable struct PriorPoint2{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractPrior\n\nDirection observation information of a Point2 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPose2","page":"Internal Variables/Factors","title":"RoME.PriorPose2","text":"mutable struct PriorPose2{T} <: AbstractPrior\n\nIntroduce direct observations on all dimensions of a Pose2 variable:\n\nExample:\n\nPriorPose2( MvNormal([10; 10; pi/6.0], Matrix(Diagonal([0.1;0.1;0.05].^2))) )\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPoint3","page":"Internal Variables/Factors","title":"RoME.PriorPoint3","text":"mutable struct PriorPoint3{T} <: AbstractPrior\n\nDirection observation information of a Point3 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPose3","page":"Internal Variables/Factors","title":"RoME.PriorPose3","text":"mutable struct PriorPose3{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractPrior\n\nDirect observation information of Pose3 variable type.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#Relative-Likelihoods-(Relative-Data)","page":"Internal Variables/Factors","title":"Relative Likelihoods (Relative Data)","text":"","category":"section"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"Defaults in IncrementalInference.jl:","category":"page"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"LinearRelative","category":"page"},{"location":"concepts/available_varfacs/#IncrementalInference.LinearRelative","page":"Internal Variables/Factors","title":"IncrementalInference.LinearRelative","text":"struct LinearRelative{N, T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeRoots\n\nDefault linear offset between two scalar variables.\n\nX_2 = X_1 + η_Z\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"Existing n-ary factors in Caesar.jl/RoME.jl/IIF.jl include:","category":"page"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"PolarPolar\nPoint2Point2\nPose2Point2\nPose2Point2Bearing\nPose2Point2BearingRange\nPose2Point2Range\nPose2Pose2\nDynPoint2VelocityPrior\nDynPoint2DynPoint2\nVelPoint2VelPoint2\nPoint2Point2Velocity\nDynPose2VelocityPrior\nVelPose2VelPose2\nDynPose2Pose2\nPose3Pose3\nPriorPose3ZRP\nPartialPriorRollPitchZ\nPartialPose3XYYaw\nPose3Pose3XYYaw","category":"page"},{"location":"concepts/available_varfacs/#RoME.PolarPolar","page":"Internal Variables/Factors","title":"RoME.PolarPolar","text":"mutable struct PolarPolar{T1<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}, T2<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeRoots\n\nLinear offset factor of IIF.SamplableBelief between two Polar variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Point2Point2","page":"Internal Variables/Factors","title":"RoME.Point2Point2","text":"mutable struct Point2Point2{D<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeRoots\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2Point2","page":"Internal Variables/Factors","title":"RoME.Pose2Point2","text":"struct Pose2Point2{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeMinimize\n\nBearing and Range constraint from a Pose2 to Point2 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2Point2Bearing","page":"Internal Variables/Factors","title":"RoME.Pose2Point2Bearing","text":"struct Pose2Point2Bearing{B<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeMinimize\n\nSingle dimension bearing constraint from Pose2 to Point2 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2Point2BearingRange","page":"Internal Variables/Factors","title":"RoME.Pose2Point2BearingRange","text":"mutable struct Pose2Point2BearingRange{B<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}, R<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeMinimize\n\nBearing and Range constraint from a Pose2 to Point2 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2Point2Range","page":"Internal Variables/Factors","title":"RoME.Pose2Point2Range","text":"mutable struct Pose2Point2Range{T} <: AbstractRelativeMinimize\n\nRange only measurement from Pose2 to Point2 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2Pose2","page":"Internal Variables/Factors","title":"RoME.Pose2Pose2","text":"struct Pose2Pose2{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeRoots\n\nRigid transform between two Pose2's, assuming (x,y,theta).\n\nRelated\n\nPose3Pose3, Point2Point2, MutablePose2Pose2Gaussian, DynPose2, InertialPose3\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPoint2VelocityPrior","page":"Internal Variables/Factors","title":"RoME.DynPoint2VelocityPrior","text":"mutable struct DynPoint2VelocityPrior{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractPrior\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPoint2DynPoint2","page":"Internal Variables/Factors","title":"RoME.DynPoint2DynPoint2","text":"mutable struct DynPoint2DynPoint2{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeRoots\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.VelPoint2VelPoint2","page":"Internal Variables/Factors","title":"RoME.VelPoint2VelPoint2","text":"mutable struct VelPoint2VelPoint2{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeMinimize\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Point2Point2Velocity","page":"Internal Variables/Factors","title":"RoME.Point2Point2Velocity","text":"mutable struct Point2Point2Velocity{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeMinimize\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPose2VelocityPrior","page":"Internal Variables/Factors","title":"RoME.DynPose2VelocityPrior","text":"mutable struct DynPose2VelocityPrior{T1, T2} <: AbstractPrior\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.VelPose2VelPose2","page":"Internal Variables/Factors","title":"RoME.VelPose2VelPose2","text":"mutable struct VelPose2VelPose2{T1<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}, T2<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeMinimize\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPose2Pose2","page":"Internal Variables/Factors","title":"RoME.DynPose2Pose2","text":"mutable struct DynPose2Pose2{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeRoots\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose3Pose3","page":"Internal Variables/Factors","title":"RoME.Pose3Pose3","text":"mutable struct Pose3Pose3{T<:Union{AliasingScalarSampler, BallTreeDensity, Distribution, IncrementalInference.FluxModelsDistribution}} <: AbstractRelativeRoots\n\nRigid transform factor between two Pose3 compliant variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPose3ZRP","page":"Internal Variables/Factors","title":"RoME.PriorPose3ZRP","text":"mutable struct PriorPose3ZRP{T1, T2} <: AbstractPrior\n\nPartial prior belief on Z, Roll, and Pitch of a Pose3.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PartialPriorRollPitchZ","page":"Internal Variables/Factors","title":"RoME.PartialPriorRollPitchZ","text":"mutable struct PartialPriorRollPitchZ{T1, T2} <: AbstractPrior\n\nPartial prior belief on Roll Pitch and Z of a Pose3 variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PartialPose3XYYaw","page":"Internal Variables/Factors","title":"RoME.PartialPose3XYYaw","text":"mutable struct PartialPose3XYYaw{T1, T2} <: AbstractRelativeMinimize\n\nPartial factor between XY and Yaw of two Pose3 variables.\n\nTo be deprecated: use Pose3Pose3XYYaw instead.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose3Pose3XYYaw","page":"Internal Variables/Factors","title":"RoME.Pose3Pose3XYYaw","text":"mutable struct Pose3Pose3XYYaw{T1, T2} <: AbstractRelativeMinimize\n\nPartial factor between XY and Yaw of two Pose3 variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#Extending-Caesar-with-New-Variables-and-Factors","page":"Internal Variables/Factors","title":"Extending Caesar with New Variables and Factors","text":"","category":"section"},{"location":"concepts/available_varfacs/","page":"Internal Variables/Factors","title":"Internal Variables/Factors","text":"A question that frequently arises is how to design custom variables and factors to solve a specific type of graph. One strength of Caesar is the ability to incorporate new variables and factors at will. Please refer to Adding Factors for more information on creating your own factors.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/47298402-ace95500-d5e5-11e8-8607-593525445d14.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Click here to go to the Caesar.jl Github repo:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: source)","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Caesar is an open-source robotic software stack for combining heterogeneous and ambiguous data streams.  The focus is predominantly on geometric/spatial estimation tasks related to simultaneous localization and mapping (SLAM), but this software is also highly extensible and well suited to a variety of estimation/filtering-type tasks — especially in non-Gaussian/multimodal settings.  Caesar.jl addresses numerous issues that arise in prior SLAM solutions: solving under-defined systems, inference with non-Gaussian measurements, standard features for natively handling ambiguous data association and multi-hypotheses, simplifying bespoke factor development, centralized (or peer-to-peer distributed) factor-graph persistence with databases and cloud infrastructure, federated multi-session/agent reduction.  Caesar.jl originates from research work in navigation systems, see the literature reference page for more information.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"NavAbility administers the Caesar/RoME/IncrementalInference packages, please contact info@navability.io for more details.","category":"page"},{"location":"#Focus-Area","page":"Introduction","title":"Focus Area","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This project focuses on the open development of a stable, reliable, verified, user-friendly, and growing library that is well suited to various data-fusion / state-estimation aspects of robotics and autonomy in non-Gaussian/multi-modal data processing.","category":"page"},{"location":"#A-Few-Highlights","page":"Introduction","title":"A Few Highlights","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Caesar framework offers these and other features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Distributed Factor Graph representation deeply-coupled with an on-Manifold probabilistic algebra language;\nLocalization using MM-iSAMv2\nMulti-core inference supporting Pose2, Pose3, Point2, Point3, Multi-modal (multi-hypothesis), IMU preintegration, KDE density, intensity map, partial constraints, null hypothesis, etc.\nNative multi-modal (hypothesis) representation in the factor-graph, see Data Association and Hypotheses:\nMulti-modal and non-parametric representation of constraints;\nGaussian distributions are but one of the many representations of measurement error;\nOut-of-library extendable for Creating New Variables and Factors;\nNatively supports legacy Gaussian parametric and max-mixtures solutions;\nLocal in-memory solving on the device as well as database-driven centralized solving (micro-service architecture);\nNatively support Clique Recycling (i.e. fixed-lag out-marginalization) for continuous operation as well as off-line batch solving, see more at Using Incremental Updates (Clique Recycling I);\nNatively supports Dead Reckon Tethering;\nNatively supports Federated multi-session/agent solving;\nNative support for Entry=>Data blobs for storing large format data.\nMiddleware support, e.g. see the ROS Integration Page.","category":"page"},{"location":"#The-Caesar-Framework","page":"Introduction","title":"The Caesar Framework","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Caesar.jl package is an \"umbrella\" framework around other dedicated algorithmic packages.  While most of the packages are implemented in native Julia (JuliaPro), a few dependencies are wrapped C libraries.  Note that C/C++ can be incorporated with zero overhead, such as was done with AprilTags.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FAQ: Why use Julia?","category":"page"},{"location":"#RoME.jl/IncrementalInference.jl/ApproxManifoldProducts.jl","page":"Introduction","title":"RoME.jl/IncrementalInference.jl/ApproxManifoldProducts.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Robot motion estimate (RoME.jl) can operate in the conventional SLAM manner, using local memory (dictionaries), or alternatively distribute over a persisted DistributedFactorGraph.jl through common serialization and graph storage/database technologies, see this article as example [1.3].   A variety of 2D plotting, 3D visualization, serialization, middleware, and analysis tools come standard as provided by the associated packages.  RoME.jl combines reference frame transformations and robotics SLAM tool around the back-end solver provides by IncrementalInference.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Details about the accompanying packages:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"IncrementalInference.jl supplies the algebraic logic for factor graph inference with Bayes tree and depends on several packages itself.\nRoME.jl introduces nodes and factors that are useful to robotic navigation.\nApproxManifoldProducts.jl provides on-manifold belief product operations.","category":"page"},{"location":"#Visualization-(Arena.jl/RoMEPlotting.jl)","page":"Introduction","title":"Visualization (Arena.jl/RoMEPlotting.jl)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Caesar visualization (plotting of results, graphs, and data) is provided by 2D and 3D packages respectively:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"RoMEPlotting.jl are a set of scripts that provide MATLAB style plotting of factor graph beliefs, mostly supporting 2D visualization with some support for projections of 3D;\nArena.jl package, which is a collection of 3D visualization tools.","category":"page"},{"location":"#Multilanguage-Interops:-Caesar-SDKs-and-APIs","page":"Introduction","title":"Multilanguage Interops: Caesar SDKs and APIs","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Caesar framework is not limited to direct Julia use.  See the multi-language page for details.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FAQ: Interop with other languages (not limited to Julia only)","category":"page"},{"location":"#Origins-in-Fundamental-Research","page":"Introduction","title":"Origins in Fundamental Research","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"See related works on the literature page.  Many future directions are in the works – including fundamental research, implementation quality/performance, and system integration.  Please see/open issues for specific requests or adding comments to an ongoing discussion – also consult the Caesar.jl Slack channel to follow/engage with community discussions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nPlease help improve this documentation–if something confuses you, chances are you're not alone. It's easy to do as you read along: just click on the \"Edit on GitHub\" link above, and then edit the files directly in your browser. Your changes will be vetted by developers before becoming permanent, so don't worry about whether you might say something wrong.","category":"page"},{"location":"#Contributors","page":"Introduction","title":"Contributors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We are grateful for many, many contributions within the Julia package ecosystem – see the Project.toml files of Caesar, Arena, RoME, RoMEPlotting, KernelDensityEstimate, IncrementalInference, NLsolve, LightGraphs, Gadfly, MeshCat and others for a far reaching list of contributions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Consider citing our work:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@misc{caesarjl,\n  author = \"Contributors and Packages\",\n  title =  \"Caesar.jl\",\n  year =   2020,\n  url =    \"https://github.com/JuliaRobotics/Caesar.jl\"\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please file issues via Github for help to resolve problems for everyone. Issues can be transfered moved upstream to the best suited package location. Changes and ongoing work can be tracked via the Milestone pages (click through badges here). ","category":"page"},{"location":"#JuliaRobotics-Code-of-Conduct","page":"Introduction","title":"JuliaRobotics Code of Conduct","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Caesar.jl project is part of the JuliaRobotics organization and adheres to the JuliaRobotics code-of-conduct.","category":"page"},{"location":"#Next-Steps","page":"Introduction","title":"Next Steps","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For installation steps, examples/tutorials, and concepts please refer to the following pages:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"installation_environment.md\"\n    \"concepts/concepts.md\"\n    \"examples/examples.md\"\n    \"func_ref.md\"\n]\nDepth = 3","category":"page"},{"location":"examples/using_ros/#Using-Caesar.jl-with-ROS","page":"ROS Middleware","title":"Using Caesar.jl with ROS","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"Since 2020, Caesar.jl has native support for ROS via the RobotOS.jl package.  ","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"warning: Warning\nNote that ROS neotic has switched to Python3 exclusively, and at the time of writing this page we were usinng Python2.7.  See the ROS Wiki here: https://wiki.ros.org/UsingPython3","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"note: Note\nSee ongoing RobotOS.jl discussion on building a direct C++ interface and skipping PyCall.jl entirely: https://github.com/jdlangs/RobotOS.jl/issues/59","category":"page"},{"location":"examples/using_ros/#Load-the-ROS-Environment-Variables","page":"ROS Middleware","title":"Load the ROS Environment Variables","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"The first thing to ensure is that the ROS environment is loaded in the bash environment before launching Julia, see \"1.5 Environment setup at ros.org\", something similar to:","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"source /opt/ros/noetic/setup.bash","category":"page"},{"location":"examples/using_ros/#RobotOS.jl-with-Correct-Python","page":"ROS Middleware","title":"RobotOS.jl with Correct Python","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"RobotOS.jl currently using PyCall.jl to interface through the rospy system.  After launching Julia, make sure that PyCall is using the correct Python binary on your local system.  In our local setup, we use (assuming using Distributed):","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"## Prepare python version\nusing Pkg\nDistributed.@everywhere using Pkg\n\n# ENV[\"PYTHON\"] = \"/usr/bin/python3.6\"\nDistributed.@everywhere begin\n  ENV[\"PYTHON\"] = \"/usr/bin/python\"\n  Pkg.build(\"PyCall\")\nend\n\nusing PyCall\nDistributed.@everywhere using PyCall","category":"page"},{"location":"examples/using_ros/#Load-RobotOS.jl-along-with-Caesar.jl","page":"ROS Middleware","title":"Load RobotOS.jl along with Caesar.jl","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"Caesar.jl has native by optional package tools relating to RobotOS.jl (leveraging Requires.jl):","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"using RobotOS, Caesar\nDistributed.@everywhere using Caesar","category":"page"},{"location":"examples/using_ros/#Prepare-Any-Outer-Objects","page":"ROS Middleware","title":"Prepare Any Outer Objects","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"Usually a factor graph or detectors, or some more common objects are required.  For the example lets just say a basic SLAMWrapper containing a regular fg=initfg():","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"robotslam = SLAMWrapperLocal()","category":"page"},{"location":"examples/using_ros/#Example-Caesar.jl-ROS-Handler","page":"ROS Middleware","title":"Example Caesar.jl ROS Handler","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"Some function will also be required to consume the ROS traffic on any particular topic, where for the example we assume extraneous data will only be fg_:","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"function myHandler(msgdata, slam_::SLAMWrapperLocal)\n  # show some header information\n  @show \"myHandler\", msgdata[2].header.seq\n\n  # do stuff\n  # addVariable!(slam.dfg, ...)\n  # addFactor!(slam.dfg, ...)\n  #, etc.\n\n  nothing\nend","category":"page"},{"location":"examples/using_ros/#Setup-the-Bagfile-to-Consume","page":"ROS Middleware","title":"Setup the Bagfile to Consume","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"Assuming that you are working from a bagfile, the following code makes it easy to consume the bagfile directly.  Alternatively, see RobotOS.jl for wiring up publishers and subscribers for live data.  Caesar.jl methods to consuming a bagfile are:","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"# find the bagfile\nbagfile = joinpath(ENV[\"HOME\"],\"data/somedata.bag\")\n\n# open the file\nbagSubscriber = RosbagSubscriber(bagfile)\n\n# subscriber callbacks\nbagSubscriber(\"/zed/left/image_rect_color\", myHandler, robotslam)","category":"page"},{"location":"examples/using_ros/#Synchronizing-Over-a-Factor-Graph","page":"ROS Middleware","title":"Synchronizing Over a Factor Graph","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"When adding Variables and Factors, use solvable=0 to disable the new fragments until ready for inference, for example","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"addVariable!(fg, :x45, Pose2, solvable=0)\nnewfct = addFactor!(fg, [:x11,:x12], Pose2Pose2, solvable=0)","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"These parts of the factor graph can simply be activated for solving:","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"setSolvable!(fg, :x45, 1)\nsetSolvable!(fg, newfct.label, 1)","category":"page"},{"location":"examples/using_ros/#More-Tools-for-Real-Time","page":"ROS Middleware","title":"More Tools for Real-Time","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"See tools such as ","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"ST = manageSolveTree!(robotslam.dfg, robotslam.solveSettings, dbg=false)","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"manageSolveTree!","category":"page"},{"location":"examples/using_ros/#RoME.manageSolveTree!","page":"ROS Middleware","title":"RoME.manageSolveTree!","text":"manageSolveTree!(dfg, mss; dbg, timinglog, limitfixeddown)\n\n\nAsynchronous solver manager that can run concurrently while other Tasks are modifying a common distributed factor graph object.\n\nNotes\n\nWhen adding Variables and Factors, use solvable=0 to disable the new fragments until ready for inference.\ne.g. addVariable!(fg, :x45, Pose2, solvable=0)\nThese parts of the factor graph can simply be activated for solving setSolvable!(fg, :x45, 1)\n\n\n\n\n\n","category":"function"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"for solving a factor graph while the middleware processes are modifying the graph, while documentation is being completed see the code here: https://github.com/JuliaRobotics/RoME.jl/blob/a662d45e22ae4db2b6ee20410b00b75361294545/src/Slam.jl#L175-L288","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"To stop or trigger a new solve in the SLAM manager you can just use either of these","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"stopManageSolveTree!\ntriggerSolve!","category":"page"},{"location":"examples/using_ros/#RoME.stopManageSolveTree!","page":"ROS Middleware","title":"RoME.stopManageSolveTree!","text":"stopManageSolveTree!(slam)\n\n\nStops a manageSolveTree! session.  Usually up to the user to do so as a SLAM process comes to completion.\n\nRelated\n\nmanageSolveTree!\n\n\n\n\n\n","category":"function"},{"location":"examples/using_ros/#RoME.triggerSolve!","page":"ROS Middleware","title":"RoME.triggerSolve!","text":"triggerSolve!(slam)\n\n\nTrigger a factor graph solveTree!(slam.dfg,...) after clearing the solvable buffer slam.?? (assuming the manageSolveTree! task is already running).\n\nNotes\n\nUsed in combination with manageSolveTree!\n\n\n\n\n\n","category":"function"},{"location":"examples/using_ros/#Run-the-ROS-Loop","page":"ROS Middleware","title":"Run the ROS Loop","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"Once everything is set up as you need, it's easy to loop over all the traffic in the bagfile (one message at a time):","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"maxloops = 1000\nrosloops = 0\nwhile loop!(bagSubscriber)\n  # plumbing to limit the number of messages\n  rosloops += 1\n  if maxloops < rosloops\n    @warn \"reached --msgloops limit of $rosloops\"\n    break\n  end\n  # delay progress for whatever reason\n  blockProgress(robotslam) # required to prevent duplicate solves occuring at the same time\nend","category":"page"},{"location":"examples/using_ros/#Using-AprilTags.jl-and-Images.jl","page":"ROS Middleware","title":"Using AprilTags.jl and Images.jl","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"One common use in SLAM is AprilTags.jl.  Please see that repo for documentation on detecting tags in images.  Note that Caesar.jl has a few built in tools for working with Images.jl too.","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"using AprilTags\nusing Images, Caesar","category":"page"},{"location":"examples/using_ros/#Additional-Notes","page":"ROS Middleware","title":"Additional Notes","text":"","category":"section"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"note: Note\nNative code for consuming rosbags also includes methods:RosbagSubscriber, loop!, getROSPyMsgTimestamp, nanosecond2datetime","category":"page"},{"location":"examples/using_ros/","page":"ROS Middleware","title":"ROS Middleware","text":"note: Note\nAdditional notes about tricks that came up during development is kept in this wiki.","category":"page"},{"location":"principles/interm_dynpose/#Adding-Velocity-(Preintegration)","page":"Creating DynPose Factor","title":"Adding Velocity (Preintegration)","text":"","category":"section"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"This tutorial describes how a new factor can be developed, beyond the pre-existing implementation in RoME.jl.  Factors can accept any number of variable dependencies and allow for a wide class of allowable function calls can be used.  Our intention is to make it as easy as possible for users to create their own factor types.","category":"page"},{"location":"principles/interm_dynpose/#Example:-Adding-Velocity-to-RoME.Point2","page":"Creating DynPose Factor","title":"Example: Adding Velocity to RoME.Point2","text":"","category":"section"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A smaller example in two dimensions where we wish to estimate the velocity of some target:  Consider two variables :x0 with a prior as well as a conditional–-likelihood for short–-to variable :x1.  Priors are in the \"global\" reference frame (how ever you choose to define it), while likelihoods are in the \"local\" / \"relative\" frame that only exist between variables.","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"(Image: dynpoint2fg)","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"warning: Warning\nText below is outdated (2021Q1) and needs to be updated for changes softtype-->variableType and CalcFactor.","category":"page"},{"location":"principles/interm_dynpose/#Brief-on-Variable-Node-softtypes","page":"Creating DynPose Factor","title":"Brief on Variable Node softtypes","text":"","category":"section"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Variable nodes retain meta data (so called \"soft types\") describing the type of variable.  Common VariableNode types are RoME.Point2D, RoME.Pose3D.  VariableNode soft types are passed during construction of the factor graph, for example:","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"v1 = addVariable!(fg, :x1, Pose2)","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Certain cases require that more information be retained for each VariableNode, and velocity calculations are a clear example where time stamp data across positions is required.  ","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Note Larger data can also be stored under the bigdata framework which is discussed here (TBD).","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"If the required VariableNode does not exist, then one can be created, such as adding velocity states with DynPoint2:","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct DynPoint2 <: IncrementalInference.InferenceVariable\n  ut::Int64 # microsecond time\n  dims::Int\n  DynPoint2(;ut::Int64=0) = new(ut, 4)\nend","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"The dims field is permanently set to 4, i.e. [x, y, dx/dt, dy/dt].  The utparameter is for storing the microsecond time stamp for that variable node.","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"In order to implement your own factor type outside IncrementalInference you should import the required identifiers, as follows:","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"using IncrementalInference\nimport IncrementalInference: getSample","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Note that new factor types can be defined at any time, even after you have started to construct the FactorGraph object.","category":"page"},{"location":"principles/interm_dynpose/#DynPoint2VelocityPrior","page":"Creating DynPose Factor","title":"DynPoint2VelocityPrior","text":"","category":"section"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Work in progress.","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct DynPoint2VelocityPrior{T} <: IncrementalInference.AbstractPrior where {T <: Distribution}\n  z::T\n  DynPoint2VelocityPrior{T}() where {T <: Distribution} = new{T}()\n  DynPoint2VelocityPrior(z1::T) where {T <: Distribution} = new{T}(z1)\nend\ngetSample(dp2v::DynPoint2VelocityPrior, N::Int=1) = (rand(dp2v.z,N), )","category":"page"},{"location":"principles/interm_dynpose/#DynPoint2DynPoint2-(preintegration)","page":"Creating DynPose Factor","title":"DynPoint2DynPoint2 (preintegration)","text":"","category":"section"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"warning: Warning\n::IIF.FactorMetadata is being refactored and improved.  Some of the content below is out of date.  See IIF #1025 for details. (1Q2021)","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"The basic idea is that change in position is composed of three components (originating from double integration of Newton's second law):","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"(Image: deltapositionplus) ( eq. 1)","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"DynPoint2DynPoint2 factor is using the above equation to define the difference in position between the two DynPoint2s.  The position part stored in DynPoint2DynPoint2 factor corresponds to (Image: deltaposplusonly).  A new multi-variable (so called \"pairwise\") factor between any number of variables is defined with three elements:","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Factor type definition that inherits either IncrementalInference.FunctorPairwise or IncrementalInference.FunctorPairwiseMinimize;","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct DynPoint2DynPoint2{T} <: IncrementalInference.FunctorPairwise where {T <: Distribution}\n  z::T\n  DynPoint2DynPoint2{T}() where {T <: Distribution} = new{T}()\n  DynPoint2DynPoint2(z1::T) where {T <: Distribution} = new{T}(z1)\nend","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A sampling function with exactly the signature: getSample(dp2dp2::DynPoint2DynPoint2, N::Int=1) and returning a Tuple (legacy reasons);","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"getSample(dp2dp2::DynPoint2DynPoint2, N::Int=1) = (rand(dp2dp2.z,N), )","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A residual or minimization function with exactly the signature described below.","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Residual (related to FunctorPairwise) or factor minimization function (related to FunctorPairwiseMinimize) signatures should match this dp2dp2::DynPoint2DynPoint2 example:","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"function (dp2dp2::DynPoint2DynPoint2)(\n            res::Array{Float64},\n            userdata,\n            idx::Int,\n            meas::Tuple,\n            Xs...  )::Nothing","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"where Xs can be expanded to the particular number of variable nodes this factor will be associated, and note they are order sensitive at addFactor!(fg, ...) time.  The res parameter is a vector of the same dimension defined by the largest of the Xs terms.  The userdata value contains the small metadata / userdata portions of information that was introduced to the factor graph at construction time – please consult error(string(fieldnames(userdata))) for details at this time.  This is a relatively new feature in the code and likely to be improved.  The idx parameter represents a legacy index into the measurement meas[1] and variables Xs to select the desired marginal sample value.  Future versions of the code plan to remove the idx parameter entirely.  The Xs array of parameter are each of type ::Array{Float64,2} and contain the estimated samples from each of the current best marginal belief estimates of the factor graph variable node.  ","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"function (dp2dp2::DynPoint2DynPoint2)(\n            res::Array{Float64},\n            userdata,\n            idx::Int,\n            meas::Tuple,\n            Xi::Array{Float64,2},\n            Xj::Array{Float64,2}  )\n  #\n  z = meas[1][:,idx]\n  xi, xj = Xi[:,idx], Xj[:,idx]\n  dt = (userdata.variableuserdata[2].ut - userdata.variableuserdata[1].ut)*1e-6   # roughly the intended use of userdata\n  res[1:2] = z[1:2] - (xj[1:2] - (xi[1:2]+dt*xi[3:4]))\n  res[3:4] = z[3:4] - (xj[3:4] - xi[3:4])\n  nothing\nend","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A brief usage example looks as follows, and further questions about how the preintegration strategy was implemented can be traced through the original issue JuliaRobotics/RoME.jl#60 or the literature associated with this project, or contact for more information.","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"using RoME, Distributions\nfg = initfg()\nv0 = addVariable!(fg, :x0, DynPoint2(ut=0))\n\n# Prior factor as boundary condition\npp0 = DynPoint2VelocityPrior(MvNormal([zeros(2);10*ones(2)], 0.1*eye(4)))\nf0 = addFactor!(fg, [:x0;], pp0)\n\n# conditional likelihood between Dynamic Point2\nv1 = addVariable!(fg, :x1, DynPoint2(ut=1000_000)) # time in microseconds\ndp2dp2 = DynPoint2DynPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))\nf1 = addFactor!(fg, [:x0;:x1], dp2dp2)\n\nensureAllInitialized!(fg)\ntree = wipeBuildNewTree!(fg)\ninferOverTree!(fg, tree)\n\nusing KernelDensityEstimate\n@show x0 = getKDEMax(getBelief(fg, :x0))\n# julia> ... = [-0.19441, 0.0187019, 10.0082, 10.0901]\n@show x1 = getKDEMax(getBelief(fg, :x1))\n # julia> ... = [19.9072, 19.9765, 10.0418, 10.0797]","category":"page"},{"location":"principles/interm_dynpose/#VelPoint2VelPoint2-(back-differentiation)","page":"Creating DynPose Factor","title":"VelPoint2VelPoint2 (back-differentiation)","text":"","category":"section"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"In case the preintegrated approach is not the first choice, we include VelPoint2VelPoint2 <: IncrementalInference.FunctorPairwiseMinimize as a second likelihood factor example which may seem more intuitive:","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct VelPoint2VelPoint2{T} <: IncrementalInference.FunctorPairwiseMinimize where {T <: Distribution}\n  z::T\n  VelPoint2VelPoint2{T}() where {T <: Distribution} = new{T}()\n  VelPoint2VelPoint2(z1::T) where {T <: Distribution} = new{T}(z1)\nend\ngetSample(vp2vp2::VelPoint2VelPoint2, N::Int=1) = (rand(vp2vp2.z,N), )\nfunction (vp2vp2::VelPoint2VelPoint2)(\n                res::Array{Float64},\n                userdata,\n                idx::Int,\n                meas::Tuple,\n                Xi::Array{Float64,2},\n                Xj::Array{Float64,2}  )\n  #\n  z = meas[1][:,idx]\n  xi, xj = Xi[:,idx], Xj[:,idx]\n  dt = (userdata.variableuserdata[2].ut - userdata.variableuserdata[1].ut)*1e-6   # roughly the intended use of userdata\n  dp = (xj[1:2]-xi[1:2])\n  dv = (xj[3:4]-xi[3:4])\n  res[1] = 0.0\n  res[1] += sum((z[1:2] - dp).^2)\n  res[1] += sum((z[3:4] - dv).^2)\n  res[1] += sum((dp/dt - xi[3:4]).^2)  # (dp/dt - 0.5*(xj[3:4]+xi[3:4])) # midpoint integration\n  res[1]\nend","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A similar usage example here shows:","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"fg = initfg()\n\n# add three point locations\nv0 = addVariable!(fg, :x0, DynPoint2(ut=0))\nv1 = addVariable!(fg, :x1, DynPoint2(ut=1000_000))\nv2 = addVariable!(fg, :x2, DynPoint2(ut=2000_000))\n\n# Prior factor as boundary condition\npp0 = DynPoint2VelocityPrior(MvNormal([zeros(2);10*ones(2)], 0.1*eye(4)))\nf0 = addFactor!(fg, [:x0;], pp0)\n\n# conditional likelihood between Dynamic Point2\ndp2dp2 = VelPoint2VelPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))\nf1 = addFactor!(fg, [:x0;:x1], dp2dp2)\n\n# conditional likelihood between Dynamic Point2\ndp2dp2 = VelPoint2VelPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))\nf2 = addFactor!(fg, [:x1;:x2], dp2dp2)\n\n# Graphs.plot(fg.g)\nensureAllInitialized!(fg)\ntree = wipeBuildNewTree!(fg)\ninferOverTree!(fg, tree)\n\n# see the output\n@show x0 = getKDEMax(getBelief(getVariable(fg, :x0)))\n@show x1 = getKDEMax(getBelief(getVariable(fg, :x1)))\n@show x2 = getKDEMax(getBelief(getVariable(fg, :x2)))","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Producing output:","category":"page"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"x0 = getKDEMax(getBelief(getVariable(fg, :x0))) = [0.101503, -0.0273216, 9.86718, 9.91146]\nx1 = getKDEMax(getBelief(getVariable(fg, :x1))) = [10.0087, 9.95139, 10.0622, 10.0195]\nx2 = getKDEMax(getBelief(getVariable(fg, :x2))) = [19.9381, 19.9791, 10.0056, 9.92442]","category":"page"},{"location":"principles/interm_dynpose/#IncrementalInference.jl-Defining-Factors-(Future-API)","page":"Creating DynPose Factor","title":"IncrementalInference.jl Defining Factors (Future API)","text":"","category":"section"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"We would like to remove the idx indexing from the residual function calls, since that is an unnecessary burden on the user.  Instead, the package will use views and SubArray types to simplify the interface.  Please contact author for more details (8 June 2018).","category":"page"},{"location":"principles/interm_dynpose/#Contributions","page":"Creating DynPose Factor","title":"Contributions","text":"","category":"section"},{"location":"principles/interm_dynpose/","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Thanks to mc2922 for raising the catalyst issue and conversations that followed from JuliaRobotics/RoME.jl#60.","category":"page"}]
}
