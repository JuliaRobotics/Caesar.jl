var documenterSearchIndex = {"docs":
[{"location":"#","page":"Home","title":"Home","text":"<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/6412556/47298402-ace95500-d5e5-11e8-8607-593525445d14.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Caesar is a modern robotic framework for localization and mapping, reducing the barrier of entry for Simultaneous Localization and Mapping (SLAM). Caesar attempts to address a number of issues that arise in normal SLAM solutions - solving under-defined systems, inference with non-Gaussian measurement distributions, simplifying factor creation, and centralizing factor-graph persistence with databases. Caesar started as part of the thesis \"Multi-modal and Inertial Sensor Solutions for Navigation-type Factor Graphs\" [1.2].","category":"page"},{"location":"#Focus-Area-1","page":"Home","title":"Focus Area","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This project focuses on the open development and progression to a public, stable, growing and usable inference library suited to data-fusion aspects of device navigation.","category":"page"},{"location":"#The-Caesar-Framework-1","page":"Home","title":"The Caesar Framework","text":"","category":"section"},{"location":"#Caesar-1","page":"Home","title":"Caesar","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Caesar.jl is the \"umbrella\" framework for other dedicated algorithmic/supporting packages that are implemented in Julia (and JuliaPro).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"FAQ: Why use Julia?","category":"page"},{"location":"#","page":"Home","title":"Home","text":"FAQ: Interop with other languages","category":"page"},{"location":"#RoME.jl/IncrementalInference.jl/ApproxManifoldProducts.jl-1","page":"Home","title":"RoME.jl/IncrementalInference.jl/ApproxManifoldProducts.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Critically, this package can operate in the conventional SLAM manner, using local memory (dictionaries), or alternatively distribute around a persisted FactorGraph through a graph database using CloudGraphs.jl, as discussed in literature here [1.3]. A variety of plotting, 3D visualization, serialization, LCM middleware, and analysis tools come standard. Please see internal packages, Robot Motion Estimate RoME.jl and back-end solver IncrementalInference.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Details about the accompanying packages:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"IncrementalInference.jl supplies the algebraic logic for factor graph inference with Bayes tree and depends on several packages itself.\nRoME.jl introduces nodes and factors that are useful to robotic navigation.","category":"page"},{"location":"#Visualization-(Arena.jl/RoMEPlotting.jl)-1","page":"Home","title":"Visualization (Arena.jl/RoMEPlotting.jl)","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Caesar visualization (plotting of results, graphs, and data) is provided by 2D and 3D packages respectively:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"RoMEPlotting.jl are a set of scripts that provide MATLAB style plotting of factor graph beliefs, mostly supporting 2D visualization with some support for projections of 3D;\nArena.jl package, which is a collection of 3D visualization tools.","category":"page"},{"location":"#Multilanguage-Interops:-Caesar-SDKs-and-APIs-1","page":"Home","title":"Multilanguage Interops: Caesar SDKs and APIs","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The Caesar framework is not limited to direct Julia use.  See the multi-language page for details.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Also see Frequently Asked Questions for more.","category":"page"},{"location":"#A-Few-Highlights-1","page":"Home","title":"A Few Highlights","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Work In Progress: (must be updated, 2019Q1)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The Caesar framework has the following features:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Factor-graph representation of pose and sensor data\nLocalization using Multi-modal iSAM\nMulti-core inference supporting Pose2, Pose3, Point2, Point3, Multi-modal (multi-hypothesis), IMU preintegration, KDE density, intensity map, partial constraints, null hypothesis, etc\nMulti-modal and non-parametric representation of constraints\nGaussian distributions are but one of the many representations of measurement error\nSimple, extensible framework for creation of new factor types\nMulti-hypothesis representation in the factor-graph\nLocal in-memory solving on the device as well as database-driven centralized solving\nFixed-lag, continuous operation as well as off-line batch solving","category":"page"},{"location":"#Origins-in-Fundamental-Research-1","page":"Home","title":"Origins in Fundamental Research","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"See related works on the literature page.","category":"page"},{"location":"#Future-Directions-1","page":"Home","title":"Future Directions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Many future directions are in the works – including fundamental research, implementation quality/performance, and system integration.  Please see/open issues for specific requests or adding comments to an ongoing discussion.","category":"page"},{"location":"#Next-Steps-1","page":"Home","title":"Next Steps","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"For installation steps, examples/tutorials, and concepts please refer to the following pages:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"installation_environment.md\"\n    \"concepts/concepts.md\"\n    \"examples/examples.md\"\n    \"func_ref.md\"\n]\nDepth = 3","category":"page"},{"location":"#Future-1","page":"Home","title":"Future","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package is a work in progress. Please file issues here as needed to help resolve problems for everyone! We are tracking improvements and new endeavors in the Issues section of this repository.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In the future, Caesar will likely interact more closely with repos such as:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"SensorFeatureTracking.jl\nAprilTags.jl\nRecursiveFiltering.jl","category":"page"},{"location":"#JuliaRobotics-Code-of-Conduct-1","page":"Home","title":"JuliaRobotics Code of Conduct","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The Caesar repository is part of the JuliaRobotics organization and adheres to the JuliaRobotics code-of-conduct.","category":"page"},{"location":"#Contributors-1","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We are grateful for many, many contributions within the Julia package ecosystem – see the REQUIRE files of Caesar, Arena, RoME, RoMEPlotting, KernelDensityEstimate, IncrementalInference, NLsolve, DrakeVisualizer, Graphs, CloudGraphs and others for a far reaching list of contributions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Consider citing our work:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@misc{caesarjl,\n  author = \"Contributors\",\n  title =  \"Caesar.jl\",\n  year =   2019,\n  url =    \"https://github.com/JuliaRobotics/Caesar.jl\"\n}","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Administration of the Caesar/RoME/IncrementalInference/Arena packages is currently conducted by Dehann Fourie who can be contacted for more details.","category":"page"},{"location":"installation_environment/#Getting-Started-1","page":"Installation","title":"Getting Started","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Caesar.jl is one of the packages within the JuliaRobotics community, and adheres to the code-of-conduct.","category":"page"},{"location":"installation_environment/#Local-Dependencies-1","page":"Installation","title":"Local Dependencies","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"The following system packages are used by Caesar.jl:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"# required packages\nsudo apt-get install hdf5-tools\n\n# optional packages\nsudo apt-get install graphviz imagemagick","category":"page"},{"location":"installation_environment/#TEMPORARY-NOTICE-1","page":"Installation","title":"TEMPORARY NOTICE","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Small issues with Julia package registration and management require temporary install of latest master bracnh of IncrementalInference.jl:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"julia> ]dev IncrementalInference","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Can follow progress here, and here.","category":"page"},{"location":"installation_environment/#Install-\"Just-the-ZMQ/ROS-Runtime-Solver\"-(Linux)-1","page":"Installation","title":"Install \"Just the ZMQ/ROS Runtime Solver\" (Linux)","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Work in progress (see issue #278).","category":"page"},{"location":"installation_environment/#The-\"I-Know-Julia\"-Installation-(TL;DR)-1","page":"Installation","title":"The \"I Know Julia\" Installation (TL;DR)","text":"","category":"section"},{"location":"installation_environment/#Install-Inference-Tools-1","page":"Installation","title":"Install Inference Tools","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Add Caesar to your Julia packages, you can install the metadata registered package 'Caesar' in Julia 1.0 with:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"julia> ] # to enable package manager\n(v1.0) pkg> add Caesar","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Unit tests can further be performed for the upstream packages as follows – NOTE first time runs are slow since each new function call or package must first be precompiled.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"# the multimodal incremental smoothing and mapping solver\n(v1.0) pkg> test IncrementalInference\n...\n# robotics related variables and factors to work with IncrementalInference -- can be used standalone SLAM system\n(v1.0) pkg> test RoME\n...\n# umbrella framework with interaction tools and more -- allows stand alone and server based solving\n(v1.0) pkg> test Caesar\n...","category":"page"},{"location":"installation_environment/#Install-Visualization-Tools-1","page":"Installation","title":"Install Visualization Tools","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"(Q4 2018), Temporarily require development (master branch) version of RoMEPlotting.jl (2D) and Arena.jl (3D) as optional visualization packages:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"(v1.0) pkg> add RoMEPlotting#master\n\n# separately\n(v1.0) pkg> add Arena#master","category":"page"},{"location":"installation_environment/#The-\"I-want-a-Development-Environment-from-Scratch\"-Install-1","page":"Installation","title":"The \"I want a Development Environment from Scratch\" Install","text":"","category":"section"},{"location":"installation_environment/#Local-Installation-of-Julia-1","page":"Installation","title":"Local Installation of Julia","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Although Julia (or JuliaPro) can be installed on a Linux computer using the apt package manager, we are striving for a fully local installation environment which is highly reproducible on a variety of platforms.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"The easiest method is–-via the terminal–-to download the desired version of Julia as a binary, extract, setup a symbolic link, and run:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"cd ~\nmkdir -p julia-software\ncd julia-software\nwget https://julialang-s3.julialang.org/bin/linux/x64/1.0/julia-1.0.3-linux-x86_64.tar.gz\ntar -xvf julia-1.0.3-linux-x86_64.tar.gz\ncd /usr/bin\nsudo ln -s ~/julia-software/julia-1.0.3/bin/julia julia","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Note Feel free to modify this setup as you see fit.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"This should allow any terminal or process on the computer to run the Julia REPL by type julia and testing with:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"println(\"hello world\")\n# Should print \"hello world\"","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Maybe a script, or command:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"user@...$ echo \"println(\\\"hello again\\\")\" > myscript.jl\nuser@...$ julia myscript.jl\nhello again\nuser@...$ rm myscript.jl\n\nuser@...$ julia -e \"println(\\\"one more time.\\\")\"\none more time.\nuser@...$ julia -e \"println(\\\"...testing...\\\")\"\n...testing...\n","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Note: When searching for Julia related help online, use the phrase 'julialang' instead of just 'julia'.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"For example, search for 'julialang workflow tips' or 'julialang performance tips'.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Note see FAQ - Why are first runs slow?, because of just of Just-In-Time/Pre compiling and caching.","category":"page"},{"location":"installation_environment/#Setup-Juno-IDE-Environment-1","page":"Installation","title":"Setup Juno IDE Environment","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Juno IDE allows for interactive development of Julia code by extending the Atom text editor with a few packages. Download and install Atom as instructed on the website, or via command line:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"cd ~/Downloads\nwget https://atom.io/download/deb\ndpkg -i atom-amd64.deb","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"After installing and running Atom, you can choose to either install uber-juno package in one go or install the three associated packages individually. In Atom, open the command pallette by pressing Ctrl + Shft + p and typing settings. Go to the install tab, search for and install either","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"uber-juno","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"or the individual packages directly:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"ink\njulia-client\njulia-language\nlatex-completions","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Note Some situations have required the user separately installing the Atom.jl Julia package via command line (if Juno does not automatically install Atom.jl for you).  Atom.jl can then be installed with Julia's package manager and add Atom:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"] # activate Pkg manager\n(v1.0) pkg> add Atom","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"There are a variety of useful packages in Atom, such as minimap and minimap-git.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"To install the Julia packages related to Caesar.jl–-which are independent of the Atom packages installed above–-please follow instructions below.","category":"page"},{"location":"installation_environment/#Julia-Packages-1","page":"Installation","title":"Julia Packages","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"The philosophy around Julia packages are discussed at length in the Julia core documentation, where each Julia package relates to a git repository likely found on Github.com. To install a Julia package, simply open a julia REPL (equally the julia REPL in Atom/Juno) and type:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"] # activate Pkg manager\n(v1.0) pkg> add Caesar","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"These are registered packages maintained by JuliaLang/METADATA.jl. Unregistered latest packages can also be installed with using only the Pkg.develop function:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"# Just using Caesar URL as an example --  Caesar is already registered with METADATA\nusing Pkg\nPkg.develop(PackageSpec(url=\"https://github.com/JuliaRobotics/Caesar.jl.git\"))","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Unless you change the default environment variable JULIA_PKG_DIR, all packages (git repos) are cloned/installed to ~/.julia. You can work with the packages as regular git repositories there.","category":"page"},{"location":"installation_environment/#Install-Visualization-Utils-(e.g.-Arena.jl)-1","page":"Installation","title":"Install Visualization Utils (e.g. Arena.jl)","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Visualizations were removed from Caesar and moved to a new package Arena.jl instead. Please follow instructions on the Visualizations page for a variety of 3D utilities.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Arena.jl can be installed with the following steps:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"]\nadd Arena","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"of the latest development version:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"(v1.0) pkg> add Arena#master","category":"page"},{"location":"installation_environment/#RoMEPlotting.jl-for-2D-plots-1","page":"Installation","title":"RoMEPlotting.jl for 2D plots","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Previous versions of libraries required the following Linux system packages be installed:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"sudo apt-get install libfontconfig1\nsudo apt-get install gettext\nsudo apt-get install libcairo2\nsudo apt-get install libpango1.0-0  # or libpango1.0-1","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"The RoMEPlotting.jl package must be installed up to latest master branch (development branch) owing to an upstream issue with Pango fonts on Julia 1.0 with Gadfly.jl plotting.  Once this issue is resolved, the next RoMEPlotting stable version can be tagged and be available as a standard stable release.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Please install the latest RoMEPlotting using Package manager as follows:","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"$ julia # latest v1.0.x\njulia> ] # to get package manager\n(v1.0) pkg> add RoMEPlotting#master","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Alternatively, the dev command –- i.e. (v1.0) pkg> dev RoMEPlotting –- will clone the RoMEPlotting.jl git repository to your local .julia/dev/RoMEPlotting folder.","category":"page"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Last updated February 2019","category":"page"},{"location":"installation_environment/#Contributing,-Issues,-or-Comments-1","page":"Installation","title":"Contributing, Issues, or Comments","text":"","category":"section"},{"location":"installation_environment/#","page":"Installation","title":"Installation","text":"Please feel free to open issues with Caesar.jl or even Fork and Pull Request as required. General conversations or comments can be made in the Caesar Gist.","category":"page"},{"location":"faq/#Frequently-Asked-Questions-1","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#Why-Julia-1","page":"FAQ","title":"Why Julia","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The JuliaLang and (JuliaPro) is an open-source Just-In-Time (JIT) & optionally precompiled, strongly-typed, and high-performance programming language. The algorithmic code is implemented in Julia for many reasons, such as agile development, high level syntax, performance, type safety, parallel computing, dynamic development, cross compilable (with gcc and clang) and foundational cross-platform (LLVM) technologies.   See JuliaCon2018 highlights video.  Julia can be thought of as either {C+, Mex (done right), or as a modern Fortran replacement}.  ","category":"page"},{"location":"faq/#Is-Caesar.jl-limited-to-Julia?-No.-1","page":"FAQ","title":"Is Caesar.jl limited to Julia? No.","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The Caesar.jl project is expressly focused on making this algorithmic code available to C/Fortran/C++/C#/Python/Java/JS.  Julia itself offers many additional interops.  ZMQ and HTTP/WebSockets are the standardized interfaces of choice, please see details at the multi-language section).  Consider opening issues or getting in touch for more information.","category":"page"},{"location":"faq/#Can-Julia-be-Embedded-into-C/C-1","page":"FAQ","title":"Can Julia be Embedded into C/C++","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Yes, see the Julia embedding documentation page.","category":"page"},{"location":"faq/#Current-Julia-version,-v1.0.x-1","page":"FAQ","title":"Current Julia version, v1.0.x","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Caesar.jl and packages are currently targeting Julia v1.0.x (2019Q1).  See progress for Julia v1.1.x here.","category":"page"},{"location":"faq/#Just-In-Time-Compiling-(i.e.-why-are-first-runs-slow?)-1","page":"FAQ","title":"Just-In-Time Compiling (i.e. why are first runs slow?)","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Julia uses just-in-time compilation (unless already pre-compiled)  which takes additional time the first time a new function is called. Additional calls to a function is fast from the second call onwards since the static function is now cached and ready for use.","category":"page"},{"location":"faq/#Static,-Shared-Object-.so-Compilation-1","page":"FAQ","title":"Static, Shared Object .so Compilation","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Packages are already compiled to static objects (.ji files), but can also be compiled to more common .so files.  See this AOT vs JIT compiling blog post for a deeper discussion.  Also see this Julia Binaries Blog.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Note recent developments announced on discourse..  Also see new brute force sysimg work at Fezzik.jl.","category":"page"},{"location":"faq/#ROS-Integration-1","page":"FAQ","title":"ROS Integration","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"ROS integration is a priority for this project and will accompany the so-called 'prime time' release of the code.  ROS and ZMQ interfaces are closely related.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Note the present focus (2018Q3-2019Q2) is to stabilize the ZMQ interface.","category":"page"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Voice Please add your voice of support or suggestions on ROS integration here.","category":"page"},{"location":"faq/#How-does-JSON-Schema-work?-1","page":"FAQ","title":"How does JSON-Schema work?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"Caesar.jl intends to follow json-schema.org, see step-by-step guide here.","category":"page"},{"location":"concepts/concepts/#Caesar-Concepts-1","page":"Caesar Concepts","title":"Caesar Concepts","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"A factor graph is a bipartite representation where variables (denoted by larger nodes) are interconnected by a set of factors (smaller nodes) that represent some algebraic interaction between the variables.  Factors must adhere to the limits of probabilistic models – for example conditional likelihoods (between multiple variables) or priors (unary to one variable).  A more heterogeneous factor graph example is shown below, and a broader discussion here (author disclosure):","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"(Image: factorgraphexample).","category":"page"},{"location":"concepts/concepts/#What-are-Variables-and-Factors-1","page":"Caesar Concepts","title":"What are Variables and Factors","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"Factor graphs are bipartite, i.e. variables and factors.  In practice we use \"nodes\" to represent both variables and factors with edges between.  In future, we will remove the wording \"node\" from anything Factor Graph usage/abstraction related (only vars and factors).  Nodes and edges will be used as terminology for actually storing the data on some graph storage/process foundation technology.","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"Even more meta – factors are \"variables\" that have already been observed and are now stochastically \"fixed\".  Waving hands over the fact that a factors encode both the algebraic model AND the observed measurement values.","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"Variables in the factor graph have not been observed, but we want to back them out from the observed values and algebra relating them all.  If factors are constructed from statistically independent measurements (i.e. no direct correlations between measurements other than the algebra already connecting them), then we can use Probabilistic Chain rule to write inference operation down (unnormalized):","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"P(VAR  MEAS)  =  P(MEAS  VAR) P(VAR)","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"where","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"P(VAR  MEAS) = P(MEAS  VAR) P(VAR),","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"or","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"P(VAR MEAS) = P(VAR  MEAS) P(MEAS)","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"You'll notice the first looks like \"Bayes rule\" and we take P(MEAS) as a constant (the uncorrelated assumption).","category":"page"},{"location":"concepts/concepts/#Getting-Started-with-Caesar-1","page":"Caesar Concepts","title":"Getting Started with Caesar","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"This section discusses the various concepts in the Caesar framework.","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"The initial steps in constructing and solving graphs can be found in Building and Solving Graphs.","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"We also recommend reviewing the various examples available in the Examples section.","category":"page"},{"location":"concepts/concepts/#Visualization-1","page":"Caesar Concepts","title":"Visualization","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"Caesar supports various visualizations and plots by using Arena, RoMEPlotting, and Director. This is discussed in Visualization with Arena.jl and RoMEPlotting.jl","category":"page"},{"location":"concepts/concepts/#Extending-Caesar-1","page":"Caesar Concepts","title":"Extending Caesar","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"The variables and factors in Caesar should be sufficient for the majority of robotic applications, however Caesar allows users to extend the framework without changing the core code. This is discussed in Creating New Variables and Factors.","category":"page"},{"location":"concepts/concepts/#Connectivity-and-Extensibility-1","page":"Caesar Concepts","title":"Connectivity and Extensibility","text":"","category":"section"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"Caesar supports both in-memory solving (really fast, but for moderately-sized graphs) as well as database-driven solving (think massive graphs and multiple sessions). This is still under development/being refactored, and is discussed in Common Data Persistence and Inference.","category":"page"},{"location":"concepts/concepts/#","page":"Caesar Concepts","title":"Caesar Concepts","text":"Although Caesar is Julia-based, it provides multi-language support with a ZMQ interface. This is discussed in Caesar Multi-Language Support.","category":"page"},{"location":"concepts/building_graphs/#Building-and-Solving-Graphs-1","page":"Building Factor Graphs","title":"Building and Solving Graphs","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Irrespective of your application - real-time robotics, batch processing of survey data, or really complex multi-hypothesis modeling - you're going to need to add factors and variables to a graph. This section discusses how to do that in Caesar.","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"The following sections discuss the steps required to construct a graph and solve it:","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Initialing the Factor Graph\nAdding Variables and Factors to the Graph\nSolving the Graph\nInforming the Solver About Ready Data","category":"page"},{"location":"concepts/building_graphs/#Initializing-a-Factor-Graph-1","page":"Building Factor Graphs","title":"Initializing a Factor Graph","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"using Caesar, RoME, Distributions\n\n# start with an empty factor graph object\nfg = initfg()","category":"page"},{"location":"concepts/building_graphs/#Adding-to-the-Graph-1","page":"Building Factor Graphs","title":"Adding to the Graph","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Factor graphs are made of two constituent parts:","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Variables\nFactors","category":"page"},{"location":"concepts/building_graphs/#Variables-1","page":"Building Factor Graphs","title":"Variables","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Variables (a.k.a. poses in localization terminology) are created in the same way  shown above for the landmark. Variables contain a label, a data type (e.g. in 2D RoME.Point2 or RoME.Pose2). Note that variables are solved - i.e. they are the product, what you wish to calculate when the solver runs - so you don't provide any measurements when creating them.","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"# Add the first pose :x0\naddVariable!(fg, :x0, Pose2)\n# Add a few more poses\nfor i in 1:10\n  addVariable!(fg, Symbol(\"x$(i)\"), Pose2)\nend","category":"page"},{"location":"concepts/building_graphs/#Factors-1","page":"Building Factor Graphs","title":"Factors","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Factors are algebraic relationships between variables based on data cues such as sensor measurements. Examples of factors are absolute GPS readings (unary factors/priors) and odometry changes between pose variables. All factors encode a stochastic measurement (measurement + error), such as below, where a IIF.Prior belief is add to x0 (using the addFactor call) as a normal distribution centered around [0,0,0].","category":"page"},{"location":"concepts/building_graphs/#Priors-1","page":"Building Factor Graphs","title":"Priors","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"# Add at a fixed location Prior to pin :x0 to a starting location (0,0,pi/6.0)\naddFactor!(fg, [:x0], IIF.Prior( MvNormal([0; 0; pi/6.0], Matrix(Diagonal([0.1;0.1;0.05].^2)) )))","category":"page"},{"location":"concepts/building_graphs/#Factors-Between-Variables-1","page":"Building Factor Graphs","title":"Factors Between Variables","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"# Add odometry indicating a zigzag movement\nfor i in 1:10\n  pp = Pose2Pose2(MvNormal([10.0;0; (i % 2 == 0 ? -pi/3 : pi/3)], Matrix(Diagonal([0.1;0.1;0.1].^2))))\n  addFactor!(fg, [Symbol(\"x$(i-1)\"); Symbol(\"x$(i)\")], pp )\nend","category":"page"},{"location":"concepts/building_graphs/#When-to-Instantiate-Poses-(i.e.-new-Variables-in-Factor-Graph)-1","page":"Building Factor Graphs","title":"When to Instantiate Poses (i.e. new Variables in Factor Graph)","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Consider a robot traversing some area while exploring, localizing, and wanting to find strong loop-closure features for consistent mapping.  The creation of new poses and landmark variables is a trade-off in computational complexity and marginalization errors made during factor graph construction.  Common triggers for new poses are:","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Time-based trigger (eg. new pose a second or 5 minutes if stationary)\nDistance traveled (eg. new pose every 0.5 meters)\nRotation angle (eg. new pose every 15 degrees)","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"Computation will progress faster if poses and landmarks are very sparse.  To extract the benefit of dense reconstructions, one approach is to use the factor graph as sparse index in history about the general progression of the trajectory and use additional processing from dense sensor data for high-fidelity map reconstructions.  Either interpolations, or better direct reconstructions from inertial data can be used for dense reconstruction.","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"For completeness, one could also re-project the most meaningful measurements from sensor measurements between pose epochs as though measured from the pose epoch.  This approach essentially marginalizes the local dead reckoning drift errors into the local interpose re-projections, but helps keep the pose count low.","category":"page"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"In addition, see fixed-lag discussion for limiting during inference the number of fluid variables manually to a user desired count.","category":"page"},{"location":"concepts/building_graphs/#Which-Variables-and-Factors-to-use-1","page":"Building Factor Graphs","title":"Which Variables and Factors to use","text":"","category":"section"},{"location":"concepts/building_graphs/#","page":"Building Factor Graphs","title":"Building Factor Graphs","text":"See the next page on available variables and factors","category":"page"},{"location":"concepts/available_varfacs/#Variables-in-Caesar.jl-1","page":"Available Variables/Factors","title":"Variables in Caesar.jl","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"You can check for the latest variable types by running the following in your terminal:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"using RoME, Caesar\nsubtypes(IncrementalInference.InferenceVariable)\nIncrementalInference.getCurrentWorkspaceVariables()","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Default variables in IncrementalInference","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"ContinuousScalar\nContinuousMultivariate","category":"page"},{"location":"concepts/available_varfacs/#IncrementalInference.ContinuousScalar","page":"Available Variables/Factors","title":"IncrementalInference.ContinuousScalar","text":"struct ContinuousScalar <: InferenceVariable\n\nMost basic continuous scalar variable a ::FactorGraph object.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#IncrementalInference.ContinuousMultivariate","page":"Available Variables/Factors","title":"IncrementalInference.ContinuousMultivariate","text":"struct ContinuousMultivariate{T1<:Tuple} <: InferenceVariable\n\nContinuous variable of dimension .dims on manifold .manifolds.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#D-Variables-1","page":"Available Variables/Factors","title":"2D Variables","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"The current variables types are:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Point2\nPose2\nDynPoint2\nDynPose2","category":"page"},{"location":"concepts/available_varfacs/#RoME.Point2","page":"Available Variables/Factors","title":"RoME.Point2","text":"struct Point2 <: InferenceVariable\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2","page":"Available Variables/Factors","title":"RoME.Pose2","text":"struct Pose2 <: InferenceVariable\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPoint2","page":"Available Variables/Factors","title":"RoME.DynPoint2","text":"mutable struct DynPoint2 <: InferenceVariable\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPose2","page":"Available Variables/Factors","title":"RoME.DynPose2","text":"mutable struct DynPose2 <: InferenceVariable\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#D-Variables-2","page":"Available Variables/Factors","title":"3D Variables","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Point3\nPose3\nInertialPose3","category":"page"},{"location":"concepts/available_varfacs/#RoME.Point3","page":"Available Variables/Factors","title":"RoME.Point3","text":"struct Point3 <: InferenceVariable\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose3","page":"Available Variables/Factors","title":"RoME.Pose3","text":"struct Pose3 <: InferenceVariable\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.InertialPose3","page":"Available Variables/Factors","title":"RoME.InertialPose3","text":"mutable struct InertialPose3 <: FunctorPairwise\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Note Please open an issue with JuliaRobotics/RoME.jl for specific requests, problems, or suggestions.  Contributions are also welcome.","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Note There might be more variable types in Caesar/RoME/IIF not yet documented here.","category":"page"},{"location":"concepts/available_varfacs/#Factors-in-Caesar.jl-1","page":"Available Variables/Factors","title":"Factors in Caesar.jl","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"You can check for the latest factor types by running the following in your terminal:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"using RoME, Caesar\nprintln(\"- Singletons (priors): \")\nprintln.(sort(string.(subtypes(IncrementalInference.FunctorSingleton))));\nprintln(\"- Pairwise (variable constraints): \")\nprintln.(sort(string.(subtypes(IncrementalInference.FunctorPairwise))));\nprintln(\"- Pairwise (variable minimization constraints): \")\nprintln.(sort(string.(subtypes(IncrementalInference.FunctorPairwiseMinimize))));","category":"page"},{"location":"concepts/available_varfacs/#Priors-(Absolute-Data)-1","page":"Available Variables/Factors","title":"Priors (Absolute Data)","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Existing prior (unary) factors in Caesar.jl/RoME.jl/IIF.jl include:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"PriorPoint2\nPriorPose2\nPriorPolar\nPriorPoint3\nPriorPose3","category":"page"},{"location":"concepts/available_varfacs/#RoME.PriorPoint2","page":"Available Variables/Factors","title":"RoME.PriorPoint2","text":"mutable struct PriorPoint2{T} <: FunctorSingleton\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPose2","page":"Available Variables/Factors","title":"RoME.PriorPose2","text":"mutable struct PriorPose2{T} <: FunctorSingleton\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.PriorPose3","page":"Available Variables/Factors","title":"RoME.PriorPose3","text":"mutable struct PriorPose3 <: FunctorSingleton\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Defaults in IncrementalInference.jl:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Prior\nPartialPrior\nMixturePrior","category":"page"},{"location":"concepts/available_varfacs/#IncrementalInference.Prior","page":"Available Variables/Factors","title":"IncrementalInference.Prior","text":"struct Prior{T} <: FunctorSingleton\n\nDefault prior on all dimensions of a variable node in the factor graph.  Prior is not recommended when non-Euclidean dimensions are used in variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#IncrementalInference.PartialPrior","page":"Available Variables/Factors","title":"IncrementalInference.PartialPrior","text":"struct PartialPrior{T, P} <: FunctorSingleton\n\nPartial prior belief (absolute data) on any variable, given <:SamplableBelief and which dimensions of the intended variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#IncrementalInference.MixturePrior","page":"Available Variables/Factors","title":"IncrementalInference.MixturePrior","text":"struct MixturePrior{T} <: FunctorSingleton\n\nDefine a categorical mixture of prior beliefs on a variable.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#Conditional-Likelihoods-(Relative-Data)-1","page":"Available Variables/Factors","title":"Conditional Likelihoods (Relative Data)","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Existing n-ary factors in Caesar.jl/RoME.jl/IIF.jl include:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Point2Point2\nPoint2Point2WorldBearing\nPose2Point2Bearing\nPose2Point2BearingRange\nPose2Point2Range\nPose2Pose2\nDynPoint2VelocityPrior\nDynPoint2DynPoint2\nVelPoint2VelPoint2\nPoint2Point2Velocity\nDynPose2VelocityPrior\nVelPose2VelPose2\nDynPose2Pose2\nPose3Pose3\nInertialPose3","category":"page"},{"location":"concepts/available_varfacs/#RoME.Point2Point2","page":"Available Variables/Factors","title":"RoME.Point2Point2","text":"mutable struct Point2Point2{D<:Union{AliasingScalarSampler, BallTreeDensity, Distribution}} <: FunctorPairwise\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Point2Point2WorldBearing","page":"Available Variables/Factors","title":"RoME.Point2Point2WorldBearing","text":"mutable struct Point2Point2WorldBearing{T} <: FunctorPairwise\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose2Pose2","page":"Available Variables/Factors","title":"RoME.Pose2Pose2","text":"mutable struct Pose2Pose2{T} <: FunctorPairwise\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPoint2VelocityPrior","page":"Available Variables/Factors","title":"RoME.DynPoint2VelocityPrior","text":"mutable struct DynPoint2VelocityPrior{T} <: FunctorSingleton\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPoint2DynPoint2","page":"Available Variables/Factors","title":"RoME.DynPoint2DynPoint2","text":"mutable struct DynPoint2DynPoint2{T} <: FunctorPairwise\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.VelPoint2VelPoint2","page":"Available Variables/Factors","title":"RoME.VelPoint2VelPoint2","text":"mutable struct VelPoint2VelPoint2{T} <: FunctorPairwiseMinimize\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Point2Point2Velocity","page":"Available Variables/Factors","title":"RoME.Point2Point2Velocity","text":"mutable struct Point2Point2Velocity{T} <: FunctorPairwiseMinimize\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPose2VelocityPrior","page":"Available Variables/Factors","title":"RoME.DynPose2VelocityPrior","text":"mutable struct DynPose2VelocityPrior{T1, T2} <: FunctorSingleton\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.VelPose2VelPose2","page":"Available Variables/Factors","title":"RoME.VelPose2VelPose2","text":"mutable struct VelPose2VelPose2{T1, T2} <: FunctorPairwiseMinimize\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.DynPose2Pose2","page":"Available Variables/Factors","title":"RoME.DynPose2Pose2","text":"mutable struct DynPose2Pose2{T} <: FunctorPairwise\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#RoME.Pose3Pose3","page":"Available Variables/Factors","title":"RoME.Pose3Pose3","text":"mutable struct Pose3Pose3 <: FunctorPairwise\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"Defaults in IncrementalInference.jl:","category":"page"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"LinearConditional\nMixtureLinearConditional","category":"page"},{"location":"concepts/available_varfacs/#IncrementalInference.LinearConditional","page":"Available Variables/Factors","title":"IncrementalInference.LinearConditional","text":"struct LinearConditional{T} <: FunctorPairwise\n\nDefault linear offset between two scalar variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#IncrementalInference.MixtureLinearConditional","page":"Available Variables/Factors","title":"IncrementalInference.MixtureLinearConditional","text":"struct MixtureLinearConditional{T} <: FunctorPairwise\n\nDefine a categorical mixture of (relative) likelihood beliefs between any two variables.\n\n\n\n\n\n","category":"type"},{"location":"concepts/available_varfacs/#Extending-Caesar-with-New-Variables-and-Factors-1","page":"Available Variables/Factors","title":"Extending Caesar with New Variables and Factors","text":"","category":"section"},{"location":"concepts/available_varfacs/#","page":"Available Variables/Factors","title":"Available Variables/Factors","text":"A question that frequently arises is how to design custom variables and factors to solve a specific type of graph. One strength of Caesar is the ability to incorporate new variables and factors at will. Please refer to Adding Factors for more information on creating your own factors.","category":"page"},{"location":"concepts/interacting_fgs/#Querying-the-FactorGraph-1","page":"Interacting w/ Factor Graphs","title":"Querying the FactorGraph","text":"","category":"section"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"There are a variety of functions to query the factor graph, please refer to Function Reference for details.","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"A quick summary of the variables in the factor graph can be retrieved with:","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"# List variables\nls(fg)\n# List factors attached to x0\nls(fg, :x0)\n# TODO: Provide an overview of getVal, getVert, getBW, getVertKDE, etc.","category":"page"},{"location":"concepts/interacting_fgs/#Solving-Graphs-1","page":"Interacting w/ Factor Graphs","title":"Solving Graphs","text":"","category":"section"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"When you have built the graph, you can call the solver to perform inference with the following:","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"# Perform inference\nbatchSolve!(fg)","category":"page"},{"location":"concepts/interacting_fgs/#Peeking-at-Results-1","page":"Interacting w/ Factor Graphs","title":"Peeking at Results","text":"","category":"section"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"Once you have solved the graph, you can review the full marginal with:","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"X0 = getKDE(fg, :x0) # Get the raw KDE\n# Evaluate the marginal density function just for fun at [0.01, 0, 0].\nX0([0.01, 0, 0])","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"For finding the MAP value in the density functions, you can use getKDEMax or getKDEMean. Here we are asking for the MAP values for all the variables in the factor graph:","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"verts = ls(fg)\nmap(v -> println(\"$v : $(getKDEMax(getVertKDE(fg, v)))\"), verts[1]);","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"Also see built-in function printgraphmax(fg) which performs a similar function.","category":"page"},{"location":"concepts/interacting_fgs/#Plotting-1","page":"Interacting w/ Factor Graphs","title":"Plotting","text":"","category":"section"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"Once the graph has been built, a simple plot of the values can be produced with RoMEPlotting.jl. For example:","category":"page"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"using RoMEPlotting\n\ndrawPoses(fg)\n# If you have landmarks, you can instead call\n# drawPosesLandms(fg)\n\n# Draw the KDE for x0\nplotKDE(fg, :x0)\n# Draw the KDE's for x0 and x1\nplotKDE(fg, [:x0, :x1])","category":"page"},{"location":"concepts/interacting_fgs/#Next-Steps-1","page":"Interacting w/ Factor Graphs","title":"Next Steps","text":"","category":"section"},{"location":"concepts/interacting_fgs/#","page":"Interacting w/ Factor Graphs","title":"Interacting w/ Factor Graphs","text":"Although the above graph demonstrates the fundamental operations, it's not particularly useful. Take a look at Hexagonal Example for a complete example that builds on these operations.","category":"page"},{"location":"concepts/mmisam_alg/#Multimodal-incremental-Smoothing-and-Mapping-Algorithm-1","page":"Multimodal iSAM Algorithm","title":"Multimodal incremental Smoothing and Mapping Algorithm","text":"","category":"section"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Work In Progress","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"Placeholder for details on how the approximate sum-product inference algorithm (mmiSAM) works.  Until then, see related literature for more details.","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"(Image: mmfgbt)","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"See tree solve video here.","category":"page"},{"location":"concepts/mmisam_alg/#","page":"Multimodal iSAM Algorithm","title":"Multimodal iSAM Algorithm","text":"(Image: bayestreeexample)","category":"page"},{"location":"concepts/multilang/#Multi-Language-and-Shared-Objects-1","page":"Multi-Language Support","title":"Multi-Language and Shared Objects","text":"","category":"section"},{"location":"concepts/multilang/#Multilanguage-Interops:-Caesar-SDKs-and-APIs-1","page":"Multi-Language Support","title":"Multilanguage Interops: Caesar SDKs and APIs","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"The Caesar framework is not limited to direct Julia use. The following Github projects provide access to features of Caesar in their language:","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Julia Web interface:\nGraffSDK.jl\nZMQ Interface\nC/C++:\nGraff Cpp\nCaesar LCM\nPython:\nGraffSDK.py","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Contributions are welcome! If you are developing an extension we would like to help, please feel free to contact us (details below).","category":"page"},{"location":"concepts/multilang/#ZMQ-Messaging-Interface-1","page":"Multi-Language Support","title":"ZMQ Messaging Interface","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Caesar.jl has a ZMQ messaging interface (interested can see code here  here) that allows users to interact with the solver code base in a variety of ways.  The messaging interface is not meant to replace static .so library file compilation–see below–-but rather a more versatile and flexible development strategy.","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"The current known interface implementations to Caesar.jl are:","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"C/C++ GraffCPP,\nPython GraffSDK.py (needs to be updated),","category":"page"},{"location":"concepts/multilang/#Starting-the-Caesar-ZMQ-Navigation-Server-1","page":"Multi-Language Support","title":"Starting the Caesar ZMQ Navigation Server","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Start the Caesar.ZmqCaesar server in a Julia session with a few process cores and full optimization:","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"julia -p4 -O3","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Then run the following commands, and note these steps have also been scripted here:","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"#import the required modules\nusing Caesar, Caesar.ZmqCaesar\n\n# create empty factor graph and config objects\nfg = Caesar.initfg()\nconfig = Dict{String, String}()\nzmqConfig = ZmqServer(fg, config, true, \"tcp://*:5555\");\n\n# Start the server over ZMQ\nstart(zmqConfig)\n\n# give the server a minute to start up ...","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"The current tests are a good place to see some examples of the current interfacing functions.  Feel free to change the ZMQ interface for to any of the ZMQ supported modes of data transport, such as Interprocess Communication (IPC) vs. TCP.","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"TODO: expand the ZMQ documentation","category":"page"},{"location":"concepts/multilang/#ROS-Integration-1","page":"Multi-Language Support","title":"ROS Integration","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Yes, but not yet.  See:","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"FAQ: ROS Integration","category":"page"},{"location":"concepts/multilang/#Static,-Shared-Object-.so-Compilation-1","page":"Multi-Language Support","title":"Static, Shared Object .so Compilation","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"FAQ: Static, Shared Object .so Compilation","category":"page"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"The future planning for the Caesar.jl framework and the mm-iSAM inference algorithm is to use the package: https://github.com/JuliaLang/PackageCompiler.jl so that linkable .so files or even full executables can be compiled.  Please add your comments to this issue discussion.","category":"page"},{"location":"concepts/multilang/#Alternative-Methods-1","page":"Multi-Language Support","title":"Alternative Methods","text":"","category":"section"},{"location":"concepts/multilang/#","page":"Multi-Language Support","title":"Multi-Language Support","text":"Interfacing from languages like Python may also be achieved using PyCall.jl although little work has been done in the Caesar.jl framework to explore this path.  Julia is itself interactive/dynamic and has plenty of line-by-line and Integrated Development Environment support – consider trying Julia for your application.","category":"page"},{"location":"concepts/arena_visualizations/#Visualization-with-Arena.jl-1","page":"Arena Visualization","title":"Visualization with Arena.jl","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Caesar.jl uses the Arena.jl package for all the visualization requirements.  This part of the documentation discusses the robotic visualization aspects supported by Arena.jl. Arena.jl supports a wide variety of general visualization as well as developer visualization tools more focused on research and development.","category":"page"},{"location":"concepts/arena_visualizations/#Current-Work-In-Progress-1","page":"Arena Visualization","title":"Current Work In Progress","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Written Nov 2018","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"While Arena.jl is still being upgraded for Julia 1.0 (mostly relating to updates in 3D visualization), the 2D visualizations available through the development master branch in RoMEPlotting.jl are available in Julia 1.0.  The master branch version can be installed using the Julia package manager with add RoMEPlotting#master, see also environment installation page.","category":"page"},{"location":"concepts/arena_visualizations/#Introduction-1","page":"Arena Visualization","title":"Introduction","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Over time, Caesar.jl has used a least three different 3D visualization technologies, with the most recent based on WebGL and three.js by means of the MeshCat.jl package. The previous incarnation used a client side installation of VTK  by means of the DrakeVisualizer.jl and Director libraries. Different 2D plotting libraries have also been used, with evolutions to improve usability for a wider user base. Each epoch has aimed at reducing dependencies and increasing multi-platform support.","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"The sections below discuss 2D and 3D visualization techniques available to the Caesar.jl robot navigation system. Visualization examples will be seen throughout the Caesar.jl package documentation. Arena.jl is intended to simplify the process 2D plotting for robot trajectories in two or three dimensions. The visualizations are also intended to help with subgraph plotting for finding loop closures in data or compare two datasets.","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Note that all visualizations used to be part of the Caesar.jl package itself, but was separated out to Arena.jl in early 2018.","category":"page"},{"location":"concepts/arena_visualizations/#Installation-1","page":"Arena Visualization","title":"Installation","text":"","category":"section"},{"location":"concepts/arena_visualizations/#MeshCat-/-three.js-Viewer-(WebGL)-1","page":"Arena Visualization","title":"MeshCat / three.js Viewer (WebGL)","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"For the 3D visualization tools provided for Caesar.jl–-in a Julia or (JuliaPro) terminal/REPL–-type ] to activate pkg manager and install Arena the master branch","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"(v1.0) pkg> add Arena#master","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Current master branch development allows the user to use the three.js WebGL based viewer via MeshCat.jl.","category":"page"},{"location":"concepts/arena_visualizations/#D-Visualization-1","page":"Arena Visualization","title":"2D Visualization","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"2D plot visualizations, provided by [RoMEPlotting.jl(http://www.github.com/JuliaRobotics/RoMEPlotting.jl) and KernelDensityEstimatePlotting.jl, are generally useful for repeated analysis of a algorithm or data set being studied. These visualizations are often manipulated to emphasize particular aspects of mobile platform navigation.","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Install RoMEPlotting master branch:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"(v1.0) pkg> add RoMEPlotting#master","category":"page"},{"location":"concepts/arena_visualizations/#Interactive-Gadfly.jl-Plots-1","page":"Arena Visualization","title":"Interactive Gadfly.jl Plots","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"See the following two discussions on Interactive 2D plots:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Interactivity\nInteractive-SVGs","category":"page"},{"location":"concepts/arena_visualizations/#Hexagonal-2D-SLAM-example-visualization-1","page":"Arena Visualization","title":"Hexagonal 2D SLAM example visualization","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"The major 2D plotting functions between RoMEPlotting.jl:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"drawPoses\ndrawPosesLandms\ndrawSubmaps","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"and KernelDensityEstimatePlotting.jl:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"plotKDE / plot(::KernelDensityEstimate)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"This simplest example for visualizing a 2D robot trajectory–-such as first running the Hexagonal 2D SLAM example–-","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"# Assuming some fg::FactorGraph has been loaded/constructed\n# ...\n\nusing RoMEPlotting\n\n# For Juno/Jupyter style use\npl = drawPosesLandms(fg)\n\n# For scripting use-cases you can export the image\nGadfly.draw(PDF(\"/tmp/test.pdf\", 20cm, 10cm),pl)  # or PNG(...)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"(Image: test)","category":"page"},{"location":"concepts/arena_visualizations/#Density-Contour-Map-1","page":"Arena Visualization","title":"Density Contour Map","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"KernelDensityEstimatePlotting (as used in RoMEPlotting) provides an interface to visualize belief densities as counter plots. The following basic example shows some of features of the API, where plotKDE(..., dims=[1;2]) implies the marginal over variables (x,y):","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"using RoME, Distributions\nusing RoMEPlotting\n\nfg = initfg()\naddVariable!(fg, :x0, Pose2)\naddFactor!(fg, [:x0], PriorPose2(MvNormal(zeros(3), eye(3))))\naddVariable!(fg, :x1, Pose2)\naddFactor!(fg, [:x0;:x1], Pose2Pose2(MvNormal([10.0;0;0], eye(3))))\n\nensureAllInitialized!(fg)\n\n# plot one contour density\nplX0 = plotKDE(fg, :x0, dims=[1;2])\n# using Gadfly; Gadfly.draw(PNG(\"/tmp/testX0.png\",20cm,10cm),plX0)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"(Image: test)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"The contour density relates to the distribution of marginal samples as seen with this Gadfly.jl package histogram comparison.","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"pl1 = drawPoses(fg, to=0);\nX0 = getVal(fg, :x0);\npl2 = Gadfly.plot(x=X0[1,:],y=X0[2,:], Geom.hexbin);\nplH = hstack(pl1, pl2)\n# Gadfly.draw(PNG(\"/tmp/testH.png\",20cm,10cm),plH)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"(Image: testh)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"NOTE Red and Green lines represent Port and Starboard direction of Pose2, respectively.","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Multiple beliefs can be plotted at the same time, while setting levels=4 rather than the default value:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"plX1 = plotKDE(fg, [:x0; :x1], dims=[1;2], levels=4)\n# Gadfly.draw(PNG(\"/tmp/testX1.png\",20cm,10cm),plX1)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"(Image: testx1)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"One dimensional (such as Θ) or a stack of all plane projections is also available:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"plTh = plotKDE(fg, [:x0; :x1], dims=[3], levels=4)\n# Gadfly.draw(PNG(\"/tmp/testTh.png\",20cm,10cm),plTh)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"(Image: testth)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"plAll = plotKDE(fg, [:x0; :x1], levels=3)\n# Gadfly.draw(PNG(\"/tmp/testX1.png\",20cm,15cm),plAll)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"(Image: testall)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"NOTE The functions hstack and vstack is provided through the Gadfly package and allows the user to build a near arbitrary composition of plots.","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Please see KernelDensityEstimatePlotting package source for more features.","category":"page"},{"location":"concepts/arena_visualizations/#D-Visualization-2","page":"Arena Visualization","title":"3D Visualization","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Factor graphs of two or three dimensions can be visualized with the 3D visualizations provided by Arena.jl and it's dependencies. The 2D example above and also be visualized in a 3D space with the commands:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"vc = startdefaultvisualization() # to load a DrakeVisualizer/Director process instance\nvisualize(fg, vc, drawlandms=false)\n# visualizeallposes!(vc, fg, drawlandms=false)","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Here is a basic example of using visualization and multi-core factor graph solving:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"addprocs(2)\nusing Caesar, RoME, TransformUtils, Distributions\n\n# load scene and ROV model (might experience UDP packet loss LCM buffer not set)\nsc1 = loadmodel(:scene01); sc1(vc)\nrovt = loadmodel(:rov); rovt(vc)\n\ninitCov = 0.001*eye(6); [initCov[i,i] = 0.00001 for i in 4:6];\nodoCov = 0.0001*eye(6); [odoCov[i,i] = 0.00001 for i in 4:6];\nrangecov, bearingcov = 3e-4, 2e-3\n\n# start and add to a factor graph\nfg = identitypose6fg(initCov=initCov)\ntf = SE3([0.0;0.7;0.0], Euler(pi/4,0.0,0.0) )\naddOdoFG!(fg, Pose3Pose3(MvNormal(veeEuler(tf), odoCov) ) )\n\naddLinearArrayConstraint(fg, (4.0, 0.0), :x0, :l1, rangecov=rangecov,bearingcov=bearingcov)\naddLinearArrayConstraint(fg, (4.0, 0.0), :x1, :l1, rangecov=rangecov,bearingcov=bearingcov)\n\nsolveBatch!(fg)\n\nusing Arena\n\nvc = startdefaultvisualization()\nvisualize(fg, vc, drawlandms=true, densitymeshes=[:l1;:x2])\nvisualizeDensityMesh!(vc, fg, :l1)\n# visualizeallposes!(vc, fg, drawlandms=false)","category":"page"},{"location":"concepts/arena_visualizations/#Previous-3D-Viewer-(VTK-/-Director)-–-no-longer-required-1","page":"Arena Visualization","title":"Previous 3D Viewer (VTK / Director) – no longer required","text":"","category":"section"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"Previous versions used the much larger VTK based Director available via DrakeVisualizer.jl package.  This requires the following preinstalled packages:","category":"page"},{"location":"concepts/arena_visualizations/#","page":"Arena Visualization","title":"Arena Visualization","text":"    sudo apt-get install libvtk5-qt4-dev python-vtk","category":"page"},{"location":"concepts/database_interactions/#Using-The-Cloud-Server-1","page":"Cloud Server/Database","title":"Using The Cloud Server","text":"","category":"section"},{"location":"concepts/database_interactions/#","page":"Cloud Server/Database","title":"Cloud Server/Database","text":"See ongoing work at GraffSDK.jl.","category":"page"},{"location":"concepts/database_interactions/#Cloud-Server-offers-Multi-session/agent-Support-1","page":"Cloud Server/Database","title":"Cloud Server offers Multi-session/agent Support","text":"","category":"section"},{"location":"concepts/database_interactions/#","page":"Cloud Server/Database","title":"Cloud Server/Database","text":"Next page Multisession","category":"page"},{"location":"concepts/multisession/#Multisession-Operation-1","page":"Multi/Cross Session Solving","title":"Multisession Operation","text":"","category":"section"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"Having all the data consolidated in a factor graph allows us to do something we find really exciting: reason against data for different robots, different robot sessions, even different users. Of course, this is all optional, and must be explicitly configured, but if enabled, current inference solutions can make use of historical data to continually improve their solutions.","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"Consider a single robot working in a common environment that has driven around the same area a number of times and has identified a landmark that is (probably) the same. We can automatically close the loop and use the information from the prior data to improve our current solution. This is called a multisession solve.","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"To perform a multisession solve, you need to specify that a session is part of a common environment, e.g 'lab'. A user then requests a multisession solve (manually for the moment), and this creates relationships between common landmarks. The collective information is used to produce a consensus on the shared landmarks. A chain of session solves is then created, and the information is propagated into the individual sessions, improving their results.","category":"page"},{"location":"concepts/multisession/#Steps-in-Multisession-Solve-1","page":"Multi/Cross Session Solving","title":"Steps in Multisession Solve","text":"","category":"section"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"The following steps are performed by the user:","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"Indicate which sessions are part of a common environment - this is done via GraffSDK when the session is created\nRequest a multisession solve","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"Upon request, the solver performs the following actions:","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"Updates the common existing multisession landmarks with any new information (propagation from session to common information)\nBuilds common landmarks for any new sessions or updated data\nSolves the common, multisession graph\nPropagates the common consensus result to the individual sessions\nFreezes all the session landmarks so that the session solving does not update the consensus result\nRequests session solves for all the updated sessions","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"Note the current approach is well positioned to transition to the \"Federated Bayes (Junction) Tree\" multisession solving method, and will be updated accordingly in due coarse.  The Federated method will allow faster multi-session solving times by avoiding the current iterated approach.","category":"page"},{"location":"concepts/multisession/#Example-1","page":"Multi/Cross Session Solving","title":"Example","text":"","category":"section"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"Consider three sessions which exist in the same, shared environment. In this environment, during each session the robot identified the same l0 landmark, as shown in the below figure. (Image: Independent Sessions)","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"If we examine this in terms of the estimates of the actual landmarks, we have three independent densities (blue, green, and orange) giving measures of l0 located at (20, 0):","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"(Image: Independent densities)","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"Now we trigger a multisession solve. For each landmark that is seen in multiple session, we produce a common landmark (we call a prime landmark) and link it to the session landmarks via factors - all denoted in black outline.","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"(Image: Linked landmarks)","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"A multisession solve is performed, which for each common (prime) landmark, we produce a common estimate. In terms of densities, this is a single answer for the disparate information, as shown in red in the below figure (for a slightly different dataset):","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"(Image: Prime density)","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"This information is then propagated back to the individual session landmarks, giving one common density for each landmark. As above, our green, blue, and orange individual densities are now all updated to match the consensus shown in black:","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"(Image: Prime density)","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"The session landmarks are then frozen, and individual session solves are triggered to propagate the information back into the sessions.  Until the federated upgrade is completed, the above process is iterated a few times to allow information to cross propagate through all sessions.  There federated tree solution requires only a single iteration up and down the federated Bayes (Junction) tree. ","category":"page"},{"location":"concepts/multisession/#Next-Steps-1","page":"Multi/Cross Session Solving","title":"Next Steps","text":"","category":"section"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"This provides an initial implementation for stitching data from multiple sessions, robots, and users. In the short term, we may trigger this automatically for any shared environments.  Multisession solving along with other automated techniques for additional measurement discovery in data allows the system to 'dream' – i.e. reducing succint info from the large volumes of heterogenous sensor data.","category":"page"},{"location":"concepts/multisession/#","page":"Multi/Cross Session Solving","title":"Multi/Cross Session Solving","text":"In the medium future we will extend this functionality to operate in the Bayes tree, which we call 'federated solving', so that we perform the operation using cached results of subtrees. ","category":"page"},{"location":"examples/examples/#Examples-1","page":"Caesar Examples","title":"Examples","text":"","category":"section"},{"location":"examples/examples/#Basics-1","page":"Caesar Examples","title":"Basics","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"The following examples demonstrate the conceptual operation of Caesar, highlighting specific features of the framework and its use.","category":"page"},{"location":"examples/examples/#Continuous-Scalar-1","page":"Caesar Examples","title":"Continuous Scalar","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"This abstract example illustrates how IncrementalInference enables algebraic relations between stochastic variables, and how a final posterior belief estimate is calculated from several pieces of information.","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Continuous Scalar Example","category":"page"},{"location":"examples/examples/#Hexagonal-2D-1","page":"Caesar Examples","title":"Hexagonal 2D","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"A simple 2D robot trajectory example is expanded below using techniques developed in simultaneous localization and mapping (SLAM).","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Hexagonal 2D Example","category":"page"},{"location":"examples/examples/#Fixed-Lag-Solving-Hexagonal2D-Revisited-1","page":"Caesar Examples","title":"Fixed-Lag Solving - Hexagonal2D Revisited","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Hexagonal Fixed-Lag","category":"page"},{"location":"examples/examples/#A-Under-Constrained-Solution-(unforced-multimodality)-1","page":"Caesar Examples","title":"A Under-Constrained Solution (unforced multimodality)","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"This tutorial describes a range-only system where there are always more variable dimensions than range measurements made. The error distribution over ranges could be nearly anything, but are restricted to Gaussian-only in this example to illustrate an alternative point – other examples show inference results where highly non-Gaussian error distributions are used.","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Multi-modal range only example (click here or image for full Vimeo):   ","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"http://vimeo.com/190052649\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/JuliaRobotics/IncrementalInference.jl/master/doc/images/mmisamvid01.gif\" alt=\"IMAGE ALT TEXT HERE\" width=\"640\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Multi-Modal Under-Constrained Example","category":"page"},{"location":"examples/examples/#Uncertain-Data-Associations,-a-Multi-Modal-Solution-(forced-multi-hypothesis)-1","page":"Caesar Examples","title":"Uncertain Data Associations, a Multi-Modal Solution (forced multi-hypothesis)","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Documentation in progress, in the mean time please see the addFactor!(..., multihypo=[1.0; 0.5;0.5]) feature for 50/50 uncertainty. Similarly for trinary or higher multi-hypotheses per factor.","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"TODO: add example.","category":"page"},{"location":"examples/examples/#Adding-Factors-Simple-Factor-Design-1","page":"Caesar Examples","title":"Adding Factors - Simple Factor Design","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Caesar can be extended with new variables and factors without changing the core code. An example of this design pattern is provided in this example.","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Defining New Variables and Factor","category":"page"},{"location":"examples/examples/#Adding-Factors-DynPose-Factor-1","page":"Caesar Examples","title":"Adding Factors - DynPose Factor","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Intermediate Example: Adding Dynamic Factors and Variables","category":"page"},{"location":"examples/examples/#Application-Examples-and-Demos-1","page":"Caesar Examples","title":"Application Examples and Demos","text":"","category":"section"},{"location":"examples/examples/#Multi-session-Use-case-1","page":"Caesar Examples","title":"Multi-session Use-case","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Multi-session Turtlebot example of the second floor in the Stata Center:   ","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/turtlemultisession.gif\" alt=\"Turtlebot Multi-session animation\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"See reference for more details:","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Fourie, D., Claassens, S., Pillai, S., Mata, R., Leonard, J.: \"SLAMinDB: Centralized graph databases for mobile robotics\", IEEE International Conference on Robotics and Automation (ICRA), Singapore, 2017.","category":"page"},{"location":"examples/examples/#Simulated-Ambiguous-SONAR-in-3D-1","page":"Caesar Examples","title":"Simulated Ambiguous SONAR in 3D","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Intersection of ambiguous elevation angle from planar SONAR sensor:   ","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"http://vimeo.com/198237738\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/rovasfm02.gif\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Bi-modal belief   ","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"http://vimeo.com/198872855\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/rovyaw90.gif\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#Synthetic-Aperture-Sonar-SLAM-1","page":"Caesar Examples","title":"Synthetic Aperture Sonar SLAM","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"The full functional (approximate sum-product) inference approach can be used to natively imbed single hydrophone acoustic waveform data into highly non-Gaussian SAS factors–that implicitly perform beamforming/micro-location–-for a simultaneous localization and mapping solution (image links to video):","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"https://www.youtube.com/watch?v=_RfXLQ67N4o\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/6412556/52547229-3048d500-2d94-11e9-8a46-811316a45283.png\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"See reference for more details:","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Cheung, M., Fourie, D., Rypkema, N., Vaz Teixeira, P., Schmidt, H., and Leonard, J.: \"Non-Gaussian SLAM utilizing Synthetic Aperture Sonar\", Intl. Conf. On Robotics and Automation (ICRA), IEEE, Montreal, 2019.","category":"page"},{"location":"examples/examples/#Probabilistic-Data-Association-(Uncertain-loop-closures)-1","page":"Caesar Examples","title":"Probabilistic Data Association (Uncertain loop closures)","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Example where the standard multihypothesis addFactor!(.., multihypo=[1.0;0.5;0.5]) interface is used.  This is from the Kitti driving dataset.  Video here.","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"<a href=\"https://www.youtube.com/watch?v=9hEonD8KDrs\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/6412556/53611733-9065b680-3b9d-11e9-8b0f-cb292a25fbb3.png\" alt=\"IMAGE ALT TEXT HERE\" width=\"480\" border=\"0\" /></a>","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"See reference for more details:","category":"page"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Doherty, K., Fourie, D., Leonard, J.: \"Multimodal Semantic SLAM with Probabilistic Data Association\", Intl. Conf. On Robotics and Automation (ICRA), IEEE, Montreal, 2019.","category":"page"},{"location":"examples/examples/#More-Examples-1","page":"Caesar Examples","title":"More Examples","text":"","category":"section"},{"location":"examples/examples/#","page":"Caesar Examples","title":"Caesar Examples","text":"Please see examples folders for Caesar and RoME for more examples, with expanded documentation in the works.","category":"page"},{"location":"examples/basic_continuousscalar/#Tutorials-1","page":"ContinuousScalar as 1D Example","title":"Tutorials","text":"","category":"section"},{"location":"examples/basic_continuousscalar/#IncrementalInference.jl-ContinuousScalar-1","page":"ContinuousScalar as 1D Example","title":"IncrementalInference.jl ContinuousScalar","text":"","category":"section"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This tutorial illustrates how IncrementalInference enables algebraic relations (residual functions) between multiple stochastic variables, and how a final posterior belief estimate is calculated from several pieces of information. The application of this tutorial is presented in abstract from which the user is free to imagine any system of relationships:  For example, a robot driving in a one dimensional world; or a time traveler making uncertain jumps forwards and backwards in time. The tutorial implicitly shows a multi-modal uncertainty introduced and transmitted. The tutorial also illustrates consensus through an additional piece of information, which reduces all stochastic variable marginal beliefs to unimodal only beliefs. The example will also illustrate the use of non-Gaussian beliefs and global inference. Lastly, the tutorial demonstrates how automatic initialization of variables works.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This tutorial requires IncrementalInference v0.3.0+, RoME v0.1.0, RoMEPlotting packages be installed. In addition, the optional GraphViz package will allow easy visualization of the FactorGraph object structure.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"To start, the two major mathematical packages are brought into scope.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"using IncrementalInference\n# using Distributions # automatically reexported by IncrementalInference","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Guidelines for developing your own functions are discussed here in Adding Variables and Factors, and we note that mechanizations and manifolds required for robotic simultaneous localization and mapping (SLAM) has been tightly integrated with the expansion package RoME.jl.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The next step is to describe the inference problem with a graphical model of type IncrementalInference.FactorGraph. The first step is to create an empty factor graph object and start populating it with variable nodes. The variable nodes are identified by Symbols, namely :x0, :x1, :x2, :x3.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"# Start with an empty factor graph\nfg = initfg()\n\n# add the first node\naddVariable!(fg, :x0, ContinuousScalar)\n\n# this is unary (prior) factor and does not immediately trigger autoinit of :x0.\naddFactor!(fg, [:x0], Prior(Normal(0,1)))","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Factor graphs are bipartite graphs with factors that act as mathematical structure between interacting variables. After adding node :x0, a singleton factor of type Prior (which was defined by the user earlier) is 'connected to' variable node :x0. This unary factor is taken as a Distributions.Normal distribution with zero mean and a standard devitation of 1. Graphviz can be used to visualize the factor graph structure, although the package is not installed by default – $ sudo apt-get install graphviz. Furthermore, the writeGraphPdf member definition is given at the end of this tutorial, which allows the user to store the graph image in graphviz supported image types.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"writeGraphPdf(fg)\n# writeGraphPdf(fg, file=\"fgx01.pdf\") # file=\"fgx01.png\"","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The two node factor graph is shown in the image below.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx0.png\" width=\"120\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Automatic initialization of variables depend on how the factor graph model is constructed. This tutorial demonstrates this behavior by first showing that :x0 is not initialized:","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"@show isInitialized(fg, :x0) # false","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Why is :x0 not initialized? Since no other variable nodes have been 'connected to' (or depend) on :x0 and future intentions of the user are unknown, the initialization of :x0 is deferred until the latest possible moment. IncrementalInference.jl assumes that the user will generally populate new variable nodes with most of the associated factors before moving to the next variable. By delaying initialization of a new variable (say :x0) until a second newer uninitialized variable (say :x1) depends on :x0, the IncrementalInference algorithms hope to then initialize :x0 with the more information from previous and surrounding variables and factors. Also note that initialization of variables is a local operation based only on the neighboring nodes – global inference will over the entire graph is shows later in this tutorial.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"By adding :x1 and connecting it through the LinearConditional and Normal distributed factor, the automatic initialization of :x0 is triggered.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addVariable!(fg, :x1, ContinuousScalar)\n# P(Z | :x1 - :x0 ) where Z ~ Normal(10,1)\naddFactor!(fg, [:x0, :x1], LinearConditional(Normal(10.0,1)))\n@show isInitialized(fg, :x0) # true","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Note that the automatic initialization of :x0 is aware that :x1 is not initialized and therefore only used the Prior(Normal(0,1)) unary factor to initialize the marginal belief estimate for :x0. The structure of the graph has now been updated to two variable nodes and two factors.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx01.png\" width=\"240\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Global inference requires that the entire factor graph be initialized before the numerical belief computation algorithms can be performed. Notice how the new :x1 variable is not yet initialized:","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"@show isInitialized(fg, :x1) # false","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The RoMEPlotting.jl package allows visualization (plotting) of the belief state over any of the variable nodes. Remember the first time executions are slow given required code compilation, and that future versions of these package will use more precompilation to reduce first execution running cost.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"using RoMEPlotting\n\nplotKDE(fg, :x0)","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx0.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"By forcing the initialization of :x1 and plotting its belief estimate,","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"ensureAllInitialized!(fg)\nplotKDE(fg, [:x0, :x1])","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"the predicted influence of the P(Z| X1 - X0) = LinearConditional(Normal(10, 1)) is shown by the red trace.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx01.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The red trace (predicted belief of :x1) is noting more than the approximated convolution of the current marginal belief of :x0 with the conditional belief described by P(Z | X1 - X0).","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Another ContinuousScalar variable :x2 is 'connected' to :x1 through a more complicated MixtureLinearConditional likelihood function.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addVariable!(fg, :x2, ContinuousScalar)\nmmo = MixtureLinearConditional([Rayleigh(3); Uniform(30,55)], Categorical([0.4; 0.6]))\naddFactor!(fg, [:x1, :x2], mmo)","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx012.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The mmo variable illustrates how a near arbitrary mixture probability distribution can be used as a conditional relationship between variable nodes in the factor graph. In this case, a 40%/60% balance of a Rayleigh and truncated Uniform distribution which acts as a multi-modal conditional belief. Interpret carefully what a conditional belief of this nature actually means.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Following the tutorial's practical example frameworks (robot navigation or time travel), this multi-modal belief implies that moving from one of the probable locations in :x1 to a location in :x2 by some processes defined by mmo=P(Z | X2, X1) is uncertain to the same 40%/60% ratio. In practical terms, collapsing (through observation of an event) the probabilistic likelihoods of the transition from :x1 to :x2 may result in the :x2 location being at either 15-20, or 40-65-ish units. The predicted belief over :x2 is illustrated by plotting the predicted belief (green trace), after forcing initialization.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"ensureAllInitialized!(fg)\nplotKDE(fg, [:x0, :x1, :x2])","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx012.png\" width=\"360\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Adding one more variable :x3 through another LinearConditional(Normal(-50,1))","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addVariable!(fg, :x3, ContinuousScalar)\naddFactor!(fg, [:x2, :x3], LinearConditional(Normal(-50, 1)))","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"expands the factor graph to to four variables and four factors.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx0123.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This part of the tutorial shows how a unimodal likelihood (conditional belief) can transmit the bimodal belief currently contained in :x2.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"ensureAllInitialized!(fg)\nplotKDE(fg, [:x0, :x1, :x2, :x3])","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Notice the blue trace (:x3) is a shifted and slightly spread out version of the initialized belief on :x2, through the convolution with the conditional belief P(Z | X2, X3).","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx0123.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Global inference over the entire factor graph has still not occurred, and will at this stage produce roughly similar results to the predicted beliefs shown above. Only by introducing more information into the factor graph can inference extract more precise marginal belief estimates for each of the variables. A final piece of information added to this graph is a factor directly relating :x3 with :x0.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"addFactor!(fg, [:x3, :x0], LinearConditional(Normal(40, 1)))","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Pay close attention to what this last factor means in terms of the probability density traces shown in the previous figure. The blue trace for :x3 has two major modes, one that overlaps with :x0, :x1 near 0 and a second mode further to the left at -40. The last factor introduces a shift LinearConditional(Normal(40,1)) which essentially aligns the left most mode of :x3 back onto :x0.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/fgx0123c.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"This last factor forces a mode selection through consensus. By doing global inference, the new information obtained in :x3 will be equally propagated to :x2 where only one of the two modes will remain.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"Global inference is achieved with local computation using two function calls, as follows.","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"tree = batchSolve!(fg)\n\n# and visualization\nplotKDE(fg, [:x0, :x1, :x2, :x3])","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"The resulting posterior marginal beliefs over all the system variables are:","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/src/assets/tutorials/ContinuousScalar/plx0123infr.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"examples/basic_continuousscalar/#","page":"ContinuousScalar as 1D Example","title":"ContinuousScalar as 1D Example","text":"It is import to note that although this tutorial ends with all marginal beliefs having near Gaussian shape and are unimodal, that the package supports multi-modal belief estimates during both the prediction and global inference processes. In fact, many of the same underlying inference functions are involved with the automatic initialization process and the global multi-modal iSAM inference procedure. This concludes the ContinuousScalar tutorial particular to the IncrementalInference package.","category":"page"},{"location":"examples/basic_slamedonut/#Singular-Ranges-only-SLAM-Solution-(i.e.-\"Under-Constrained\")-1","page":"Under-defined Trilateration SLAM 2D","title":"Singular Ranges-only SLAM Solution (i.e. \"Under-Constrained\")","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"This tutorial describes a range-only system where there are always more variable dimensions than range measurements made. The error distribution over ranges could be nearly anything, but are restricted to Gaussian-only in this example to illustrate an alternative point – other examples show inference results where highly non-Gaussian error distributions are used. The one pre-baked result of this of this singular range-only illustration can be seen in this video:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Multi-modal range only example (click here or image for full Vimeo):   ","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"<a href=\"http://vimeo.com/190052649\" target=\"_blank\"><img src=\"https://raw.githubusercontent.com/JuliaRobotics/IncrementalInference.jl/master/doc/images/mmisamvid01.gif\" alt=\"IMAGE ALT TEXT HERE\" width=\"640\" border=\"0\" /></a>","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"This example is also available as a script here in RoME.jl.","category":"page"},{"location":"examples/basic_slamedonut/#REQUIRES-1","page":"Under-defined Trilateration SLAM 2D","title":"REQUIRES","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"RoME v0.2.2\nRoMEPlotting v0.1.0+","category":"page"},{"location":"examples/basic_slamedonut/#Loading-The-Data-1","page":"Under-defined Trilateration SLAM 2D","title":"Loading The Data","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Starting a Juno IDE or Julia REPL session, the ground truth positions for vehicle positions GTp and landmark positions GTl can be loaded into memory directly with these values:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"GTp = Dict{Symbol, Vector{Float64}}()\nGTp[:l100] = [0.0;0]\nGTp[:l101] = [50.0;0]\nGTp[:l102] = [100.0;0]\nGTp[:l103] = [100.0;50.0]\nGTp[:l104] = [100.0;100.0]\nGTp[:l105] = [50.0;100.0]\nGTp[:l106] = [0.0;100.0]\nGTp[:l107] = [0.0;50.0]\nGTp[:l108] = [0.0;-50.0]\nGTp[:l109] = [0.0;-100.0]\nGTp[:l110] = [50.0;-100.0]\nGTp[:l111] = [100.0;-100.0]\nGTp[:l112] = [100.0;-50.0]\n\nGTl = Dict{Symbol, Vector{Float64}}()\nGTl[:l1] = [10.0;30]\nGTl[:l2] = [30.0;-30]\nGTl[:l3] = [80.0;40]\nGTl[:l4] = [120.0;-50]","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"NOTE 1. that by using location indicators :l1, :l2, ... or :l100, :l101, ... is of practical benefit when visualizing with existing RoMEPlotting functions.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"NOTE 2. Landmarks must be in range before range measurements can be made to them.","category":"page"},{"location":"examples/basic_slamedonut/#Creating-the-Factor-Graph-with-Point2-1","page":"Under-defined Trilateration SLAM 2D","title":"Creating the Factor Graph with Point2","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"The first step is to load the required modules, and in our case we will add a few Julia processes to help with the compute later on.  ","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"# add more julia processes\nusing Distributed\nnprocs() < 4 ? addprocs(4-nprocs()) : nothing\n\n# tell Julia that you want to use these modules/namespaces\nusing RoME, LinearAlgebra","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"NOTE Julia uses just-in-time compiling (unless pre-compiled), therefore each time a new function call on a Julia process will be slow, but all following calls to the same functions will be as fast as the statically compiled code.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"This example exclusively uses Point2 variable node types, which have dimension 2 and represent [x, y] position estimates in the world frame.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Next construct the factor graph containing the first pose :l100 (without any knowledge of where it is) and three measured beacons/landmarks :l1,:l2,:l3 – with prior location knowledge for :l1 and :l2:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"# create the factor graph object\nfg = initfg()\n\n# first pose with no initial estimate\naddVariable!(fg, :l100, Point2)\n\n# add three landmarks\naddVariable!(fg, :l1, Point2)\naddVariable!(fg, :l2, Point2)\naddVariable!(fg, :l3, Point2)\n\n# and put priors on :l101 and :l102\naddFactor!(fg, [:l1;], PriorPoint2(MvNormal(GTl[:l1], Matrix(LinearAlgebra.I,2,2))) )\naddFactor!(fg, [:l2;], PriorPoint2(MvNormal(GTl[:l2], Matrix(LinearAlgebra.I,2,2))) )","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"The PriorPoint2 is assumed to be a multivariate normal distribution of covariance Matrix(LinearAlgebra.I,2,2), as well as a weighting factor of [1.0].","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"NOTE API changed to PriorPoint2(::T) where T <: SamplableBelief = PriorPoint2{T} to accept distribution objects and discard (standard in RoME v0.1.5 – see issue 72 here).","category":"page"},{"location":"examples/basic_slamedonut/#Adding-Range-Measurements-Between-Variables-1","page":"Under-defined Trilateration SLAM 2D","title":"Adding Range Measurements Between Variables","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Next we connect the three range measurements from the vehicle location :l0 to the three beacons, respectively – and consider that the range measurements are completely relative between the vehicle and beacon position estimates:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"# first range measurement\nrhoZ1 = norm(GTl[:l1]-GTp[:l100])\nppr = Point2Point2Range( Normal(rhoZ1, 2.0) )\naddFactor!(fg, [:l100;:l1], ppr)\n\n# second range measurement\nrhoZ2 = norm(GTl[:l2]-GTp[:l100])\nppr = Point2Point2Range( Normal(rhoZ2, 3.0) )\naddFactor!(fg, [:l100; :l2], ppr)\n\n# second range measurement\nrhoZ3 = norm(GTl[:l3]-GTp[:l100])\nppr = Point2Point2Range( Normal(rhoZ3, 3.0) )\naddFactor!(fg, [:l100; :l3], ppr)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"The ranging measurement standard deviation of 2.0 or 3.0 is taken, assuming a Gaussian measurement assumption.   Again, any distribution could have been used. The factor graph should look as follows:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"writeGraphPdf(fg) # show the factor graph","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"(Image: rangesonlyfirstfg)","category":"page"},{"location":"examples/basic_slamedonut/#Inference-and-Visualizations-1","page":"Under-defined Trilateration SLAM 2D","title":"Inference and Visualizations","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"At this point we can call the solver start interpreting the first results:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"tree = batchSolve!(fg)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"The factor graph figure above showed the structure between variables and factors. In order to see the numerical values contained in the factor graph, a set of tools are provided by the RoMEPlotting and KernelDensityEstimatePlotting packages. For more details, please see the dedicated visualization discussion here.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"First look at the two landmark positions :l1, :l2 at (10.0,30),(30.0,-30) respectively.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"using RoMEPlotting\n\nplotKDE(fg, [:l1;:l2], dims=[1;2])","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"(Image: testl1_2)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Similarly, the belief estimate for the first vehicle position :l100 is bi-modal, due to the intersection of two range measurements:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"plotKDE(fg, :l100, dims=[1;2], levels=6)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"(Image: testl100)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"An alternative plotting interface can also be used, that shows a histogram of desired elements instead:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"drawLandms(fg, from=1, to=101)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"(Image: testlall)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Notice the ring of particles which represents the belief on the third beacon/landmark :l3, which was not constrained by a prior factor. Instead, the belief over the position of :l3 is being estimated simultaneous to estimating the vehicle position :l100.","category":"page"},{"location":"examples/basic_slamedonut/#Implicit-Growth-and-Decay-of-Modes-(i.e.-Hypotheses)-1","page":"Under-defined Trilateration SLAM 2D","title":"Implicit Growth and Decay of Modes (i.e. Hypotheses)","text":"","category":"section"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Next consider the vehicle moving a distance of 50 units–-and by design the direction of travel is not known–-to the next true position. The video above gives away the vehicle position with the cyan line, showing travel in the shape of a lower case 'e'. The following function handles (pseudo odometry) factors as range-only between positions and range-only measurement factors to beacons as the vehice travels.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"function vehicle_drives_to!(fgl::FactorGraph, pos_sym::Symbol, GTp::Dict, GTl::Dict; measurelimit::R=150.0) where {R <: Real}\n  currvar = union(ls(fgl)...)\n  prev_sym = Symbol(\"l$(maximum(Int[parse(Int,string(currvar[i])[2:end]) for i in 2:length(currvar)]))\")\n  if !(pos_sym in currvar)\n    println(\"Adding variable vertex $pos_sym, not yet in fgl::FactorGraph.\")\n    addVariable!(fgl, pos_sym, Point2)\n    @show rho = norm(GTp[prev_sym] - GTp[pos_sym])\n    ppr = Point2Point2Range( Normal(rho, 3.0) )\n    addFactor!(fgl, [prev_sym;pos_sym], ppr)\n  else\n    @warn \"Variable node $pos_sym already in the factor graph.\"\n  end\n  beacons = keys(GTl)\n  for ll in beacons\n    rho = norm(GTl[ll] - GTp[pos_sym])\n    # Check for feasible measurements:  vehicle within 150 units from the beacons/landmarks\n    if rho < measurelimit\n      ppr = Point2Point2Range( Normal(rho, 3.0) )\n      if !(ll in currvar)\n        println(\"Adding variable vertex $ll, not yet in fgl::FactorGraph.\")\n        addVariable!(fgl, ll, Point2)\n      end\n      addFactor!(fgl, [pos_sym;ll], ppr)\n    end\n  end\n  nothing\nend","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"After pasting (or running) this function in Julia, a new member definition vehicle_drives_to! can be used line any other function.  Julia will handle the just-in-time compiling for the type specific function required and cach the static code for repeat executions.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"NOTE The exclamation mark at the end of the function name has no syntactic significance in Julia, since the full UTF8 character set is available for functions or variables.  Instead, the exclamation serves as a Julia community convention to tell the caller that this function will modify the contents of at least some of the variables being passed into it – in this case the factor graph fg will be modified.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Now the actual driving event can be added to the factor graph:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"#drive to location :l101, then :l102\nvehicle_drives_to!(fg, :l101, GTp, GTl)\nvehicle_drives_to!(fg, :l102, GTp, GTl)\n\n# see the graph\nwriteGraphPdf(fg)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"NOTE The distance traveled could be any combination of accrued direction and speeds, however, a straight line Gaussian error model is used to keep the visual presentation of this example as simple as possible.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"The marginal posterior estimates are found by repeating inference over the factor graph, followed drawing all vehicle locations as a contour map:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"# solve and show message passing on Bayes (Juntion) tree\ntree = batchSolve!(fg, drawpdf=true, show=true)\n\n# draw all vehicle locations\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 0:2], dims=[1;2])\n# Gadfly.draw(PDF(\"/tmp/testL100_102.pdf\", 20cm, 10cm),pl) # for storing image to disk\n\npl = plotKDE(fg, [:l3;:l4], dims=[1;2], levels=4)\n# Gadfly.draw(PNG(\"/tmp/testL3_4.png\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Notice how the vehicle positions have two hypotheses, one left to right and one diagonal right to bottom left – both are valid solutions!","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"(Image: testl100_102)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"The two \"free\" beacons/landmarks :l3,:l4 still have several modes each, implying insufficient data to constrain either to a strong unimodal belief.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"(Image: testl3_4)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"\nvehicle_drives_to!(fg, :l103, GTp, GTl)\nvehicle_drives_to!(fg, :l104, GTp, GTl)\n\ntree = batchSolve!(fg)\n\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 0:4], dims=[1;2])\n# Gadfly.draw(PDF(\"/tmp/testL100_104.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Moving up to position :l104 still shows strong multiodality in the vehicle position estimates:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"(Image: testl100_105)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"vehicle_drives_to!(fg, :l105, GTp, GTl)\nvehicle_drives_to!(fg, :l106, GTp, GTl)\n\ntree = batchSolve!(fg)\n\n\nvehicle_drives_to!(fg, :l107, GTp, GTl)\n\ntree = batchSolve!(fg)\n\n\nvehicle_drives_to!(fg, :l108, GTp, GTl)\n\ntree = batchSolve!(fg)\n\n\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 2:8], dims=[1;2], levels=6)\n# Gadfly.draw(PDF(\"/tmp/testL103_108.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Next we see a strong return to a single dominant mode in all vehicle position estimates, owing to the increased measurements to beacons/landmarks as well as more unimodal estimates in :l3, :l4 beacon/landmark positions.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"vehicle_drives_to!(fg, :l109, GTp, GTl)\nvehicle_drives_to!(fg, :l110, GTp, GTl)\n\ntree = batchSolve!(fg)\n\n\nvehicle_drives_to!(fg, :l111, GTp, GTl)\nvehicle_drives_to!(fg, :l112, GTp, GTl)\n\ntree = batchSolve!(fg)\n\n\npl = plotKDE(fg, [Symbol(\"l$(100+i)\") for i in 7:12], dims=[1;2])\n# Gadfly.draw(PDF(\"/tmp/testL106_112.pdf\", 20cm, 10cm),pl)\n\npl = plotKDE(fg, [:l1;:l2;:l3;:l4], dims=[1;2], levels=4)\n# Gadfly.draw(PDF(\"/tmp/testL1234.pdf\", 20cm, 10cm),pl)\n\npl = drawLandms(fg, from=100)\n# Gadfly.draw(PDF(\"/tmp/testLocsAll.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Several location belief estimates exhibit multimodality as the trajectory progresses (not shown), but collapses and finally collapses to a stable set of dominant position estimates.","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"(Image: testl106_112)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"Landmark estimates are also stable at one estimate:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"(Image: testl1234)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"In addition, the SLAM 2D landmark visualization can be re-used to plot more information at once:","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"# pl = drawLandms(fg, from=100, to=200)\n# Gadfly.draw(PDF(\"/tmp/testLocsAll.pdf\", 20cm, 10cm),pl)\n\npl = drawLandms(fg)\n# Gadfly.draw(PDF(\"/tmp/testAll.pdf\", 20cm, 10cm),pl)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"(Image: testall)","category":"page"},{"location":"examples/basic_slamedonut/#","page":"Under-defined Trilateration SLAM 2D","title":"Under-defined Trilateration SLAM 2D","text":"This example used the default of N=200 particles per marginal belief. By increasing the number to N=300 throughout the test many more modes and interesting features can be explored, and we refer the reader to an alternative and longer discussion on the same example, in Chapter 6 here.","category":"page"},{"location":"examples/basic_hexagonal2d/#Hexagonal-2D-SLAM-Example-(Local-Compute)-1","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM Example (Local Compute)","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"A simple 2D robot trajectory example is expanded below using techniques developed in simultaneous localization and mapping (SLAM). This example is available as a single script here.","category":"page"},{"location":"examples/basic_hexagonal2d/#Creating-the-Factor-Graph-with-Pose2-1","page":"Hexagonal 2D SLAM","title":"Creating the Factor Graph with Pose2","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"The first step is to load the required modules, and in our case we will add a few Julia processes to help with the compute later on.  ","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# add more julia processes\nnprocs() < 4 ? addprocs(4-nprocs()) : nothing\n\n# tell Julia that you want to use these modules/namespaces\nusing RoME, Distributions, LinearAlgebra","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"After loading the RoME and Distributions modules, we construct a local factor graph object in memory:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# start with an empty factor graph object\nfg = initfg()\n\n# Add the first pose :x0\naddVariable!(fg, :x0, Pose2)\n\n# Add at a fixed location PriorPose2 to pin :x0 to a starting location\naddFactor!(fg, [:x0], PriorPose2(MvNormal(zeros(3), 0.01*Matrix(LinearAlgebra.I,3,3))) )","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"A factor graph object fg (of type ::FactorGraph) has been constructed; the first pose :x0 has been added; and a prior factor setting the origin at [0,0,0] over variable node dimensions [x,y,θ] in the world frame. The type Pose2 is used to indicate what variable is stored in the node. Caesar.jl allows a little more freedom in how factor and variable nodes can be connected, while still allowing for type-assertion to occur.","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"NOTE Julia uses just-in-time compilation (unless pre-compiled)  which is slow the first time a function is called but fast from the second call onwards, since the static function is now cached and ready for use.","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"The next 6 nodes are added with odometry in an counter-clockwise hexagonal manner. Note how variables are denoted with symbols, :x2 == Symbol(\"x2\"):","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# Drive around in a hexagon\nfor i in 0:5\n  psym = Symbol(\"x$i\")\n  nsym = Symbol(\"x$(i+1)\")\n  addVariable!(fg, nsym, Pose2)\n  pp = Pose2Pose2(MvNormal([10.0;0;pi/3], Matrix(Diagonal([0.1;0.1;0.1].^2))))\n  addFactor!(fg, [psym;nsym], pp )\nend","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"At this point it would be good to see what the factor graph actually looks like:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"writeGraphPdf(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"You should see the program evince open with this visual:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: exfg2d)","category":"page"},{"location":"examples/basic_hexagonal2d/#Performing-Inference-1","page":"Hexagonal 2D SLAM","title":"Performing Inference","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"Let's run the multimodal-incremental smoothing and mapping (mm-iSAM) solver against this fg object:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# perform inference, and remember first runs are slower owing to Julia's just-in-time compiling\nbatchSolve!(fg)\n\n# For those interested, the internal batch solve steps currently involve:\n# tree = wipeBuildNewTree!(fg)\n# inferOverTree!(fg, tree)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"This will take a couple of seconds (including first time compiling for all Julia processes).","category":"page"},{"location":"examples/basic_hexagonal2d/#Some-Visualization-Plot-1","page":"Hexagonal 2D SLAM","title":"Some Visualization Plot","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"2D plots of the factor graph contents is provided by the RoMEPlotting package. See further discussion on visualizations and packages here.","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"## Inter-operating visualization packages for Caesar/RoME/IncrementalInference exist\nusing RoMEPlotting\n\n# For Juno/Jupyter style use\npl = drawPoses(fg)\n\n# For scripting use-cases you can export the image\nGadfly.draw(Gadfly.PDF(\"/tmp/test.pdf\", 20cm, 10cm),pl)  # or PNG(...)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: test)","category":"page"},{"location":"examples/basic_hexagonal2d/#Adding-Landmarks-as-Point2-1","page":"Hexagonal 2D SLAM","title":"Adding Landmarks as Point2","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"Suppose some sensor detected a feature of interest with an associated range and bearing measurement The new variable and measurement can be included into the factor graph as follows:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# Add landmarks with Bearing range measurements\naddVariable!(fg, :l1, Point2, labels=[\"LANDMARK\"])\np2br = Pose2Point2BearingRange(Normal(0,0.1),Normal(20.0,1.0))\naddFactor!(fg, [:x0; :l1], p2br)\n\n# Initialize :l1 numerical values but do not rerun solver\nensureAllInitialized!(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"NOTE The default behavior for initialization of variable nodes implies the last variable noded added will not have any numerical values yet, please see ContinuousScalar Tutorial for deeper discussion on automatic initialization (autoinit). A slightly expanded plotting function will draw both poses and landmarks (and currently assumes labels starting with :x and :l respectively) – notice the new landmark bottom right:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"drawPosesLandms(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: test)","category":"page"},{"location":"examples/basic_hexagonal2d/#One-type-of-Loop-Closure-1","page":"Hexagonal 2D SLAM","title":"One type of Loop-Closure","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"Loop-closures are a major part of SLAM based state estimation. One illustration is to take a second sighting of the same :l1 landmark from the last pose :x6; followed by repeating the inference and re-plotting the result – notice the tighter confidences over all variables:","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"# Add landmarks with Bearing range measurements\np2br2 = Pose2Point2BearingRange(Normal(0,0.1),Normal(20.0,1.0))\naddFactor!(fg, [:x6; :l1], p2br2)\n\n# solve\nbatchSolve!(fg)\n\n# redraw\npl = drawPosesLandms(fg)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: test)","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"This concludes the Hexagonal 2D SLAM example.","category":"page"},{"location":"examples/basic_hexagonal2d/#Interest:-The-Bayes-(Junction)-tree-1","page":"Hexagonal 2D SLAM","title":"Interest: The Bayes (Junction) tree","text":"","category":"section"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"The Bayes (Junction) tree is used as an acyclic (has no loops) computational object, an exact algebraic refactorizating of factor graph, to perform the associated sum-product inference. The visual structure of the tree can extracted by modifying the command tree = wipeBuildNewTree!(fg, drawpdf=true) to produce representations such as this in bt.pdf.","category":"page"},{"location":"examples/basic_hexagonal2d/#","page":"Hexagonal 2D SLAM","title":"Hexagonal 2D SLAM","text":"(Image: exbt2d)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Hexagonal-2D-with-Fixed-Lag-Solving-1","page":"Fixed-Lag Solving 2D","title":"Hexagonal 2D with Fixed-Lag Solving","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"NOTE: This is an experimental feature that is currently being developed. This example provides an overview of how to enable it and the benefits of using fixed-lag solving. The objective is to provide a near-constant solve time for ever-growing graphs by only recalculating the most recent portion. Think of this as a placeholder, as we develop the solution this tutorial will be updated to demonstrate how that is achieved.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Example-Code-1","page":"Fixed-Lag Solving 2D","title":"Example Code","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"The complete code for this example can be found in the fixed-lag branch of RoME: Hexagonal Fixed-Lag Example.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Introduction-1","page":"Fixed-Lag Solving 2D","title":"Introduction","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Fixed-lag solving is enabled when creating the factor-graph. Users provide a window - the quasi fixed-lag constant (QFL) - which defines how many of the most-recent variables should be calculated. Any other variables are 'frozen'. The objective of this example is to explore providing a near-constant solve time for ever-growing graphs by only recalculating the most recent portion.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Example-Overview-1","page":"Fixed-Lag Solving 2D","title":"Example Overview","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"In the example, the basic Hexagonal 2D is grown to solve 200 variables. The original example is remains the same, i.e. a vehicle is driving around in a hexagon and seeing the same bearing+range landmark as it crosses the starting point. At every 20th variable, a solve is invoked. Rather than use batchSolve(), the solve is performed in parts (construction of Bayes tree, solving the graph) to get performance statistics as the graph grows.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"numVariables = 200\nsolveEveryNVariables = 20\nlagLength = 30\n\n# Standard Hexagonal example for totalIterations - solve every iterationsPerSolve iterations.\nfunction runHexagonalExample(fg::FactorGraph, totalIterations::Int, iterationsPerSolve::Int)::DataFrame\n    # Add the first pose :x0\n    addVariable!(fg, :x0, Pose2)\n\n    # Add at a fixed location PriorPose2 to pin :x0 to a starting location\n    addFactor!(fg, [:x0], PriorPose2(MvNormal(zeros(3), 0.01*Matrix{Float64}(LinearAlgebra.I, 3,3))))\n\n    # Add a landmark l1\n    addVariable!(fg, :l1, Point2, labels=[\"LANDMARK\"])\n\n    # Drive around in a hexagon a number of times\n    solveTimes = DataFrame(GraphSize = [], TimeBuildBayesTree = [], TimeSolveGraph = [])\n    for i in 0:totalIterations\n        psym = Symbol(\"x$i\")\n        nsym = Symbol(\"x$(i+1)\")\n        @info \"Adding pose $nsym...\"\n        addVariable!(fg, nsym, Pose2)\n        pp = Pose2Pose2(MvNormal([10.0;0;pi/3], Matrix(Diagonal( [0.1;0.1;0.1].^2 ) )))\n        @info \"Adding odometry factor between $psym -> $nsym...\"\n        addFactor!(fg, [psym;nsym], pp )\n\n        if i % 6 == 0\n            @info \"Creating factor between $psym and l1...\"\n            p2br = Pose2Point2BearingRange(Normal(0,0.1),Normal(20.0,1.0))\n            addFactor!(fg, [psym; :l1], p2br)\n        end\n        if i % iterationsPerSolve == 0 && i != 0\n            @info \"Performing inference!\"\n            if fg.isfixedlag\n                @info \"Quasi fixed-lag is enabled (a feature currently in testing)!\"\n                fifoFreeze!(fg)\n            end\n            tBuild = @timed tree = wipeBuildNewTree!(fg)\n            tInfer = @timed inferOverTree!(fg, tree, N=100)\n            graphSize = length([ls(fg)[1]..., ls(fg)[2]...])\n            push!(solveTimes, (graphSize, tBuild[2], tInfer[2]))\n        end\n    end\n    return solveTimes\nend","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Two cases are set up:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"One solving the full graph every time a solve is performed:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"# start with an empty factor graph object\nfg = initfg()\n# DO NOT enable fixed-lag operation\nsolverTimesForBatch = runHexagonalExample(fg, numVariables, solveEveryNVariables)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"The other enabling fixed-lag with a window of 20 variables:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"fgFixedLag = initfg()\nfgFixedLag.isfixedlag = true\nfgFixedLag.qfl = lagLength\n\nsolverTimesFixedLag = runHexagonalExample(fgFixedLag, numVariables, solveEveryNVariables)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"The resultant path of the robot can be seen by using RoMEPlotting and is drawn if the visualization lines are uncommented:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"#### Visualization\n\n# Plot the many iterations to see that it succeeded.\n# Batch\n# drawPosesLandms(fg)\n\n# Fixed lag\n# drawPosesLandms(fgFixedLag)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Lastly, the timing results of both scenarios are merged into a single DataFrame table, exported to CSV, and a summary graph is shown using GadFly.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"using Gadfly\nusing Colors\nusing CSV\n\n# Make a clean dataset\nrename!(solverTimesForBatch, :TimeBuildBayesTree => :Batch_BayedBuild, :TimeSolveGraph => :Batch_SolveGraph);\nrename!(solverTimesFixedLag, :TimeBuildBayesTree => :FixedLag_BayedBuild, :TimeSolveGraph => :FixedLag_SolveGraph);\ntimingMerged = DataFrames.join(solverTimesForBatch, solverTimesFixedLag, on=:GraphSize)\nCSV.write(\"timing_comparison.csv\", timingMerged)\n\nPP = []\npush!(PP, Gadfly.layer(x=timingMerged[:GraphSize], y=timingMerged[:FixedLag_SolveGraph], Geom.path, Theme(default_color=colorant\"green\"))[1]);\npush!(PP, Gadfly.layer(x=timingMerged[:GraphSize], y=timingMerged[:Batch_SolveGraph], Geom.path, Theme(default_color=colorant\"magenta\"))[1]);\n\nplt = Gadfly.plot(PP...,\n    Guide.title(\"Solving Time vs. Iteration for Fixed-Lag Operation\"),\n    Guide.xlabel(\"Solving Iteration\"),\n    Guide.ylabel(\"Solving Time (seconds)\"),\n    Guide.manual_color_key(\"Legend\", [\"fixed\", \"batch\"], [\"green\", \"magenta\"]))\nGadfly.draw(PNG(\"results_comparison.png\", 12cm, 15cm), plt)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Results-1","page":"Fixed-Lag Solving 2D","title":"Results","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Preliminary results for the comparison can be seen below. However, this is just a start and we need to perform more testing. At the moment we are working on providing consistent results and further improving performance/flattening the fixed-lag time. It should be noted that the below graph is not to demonstrate the absolute solve time, but rather the relative behavior of full-graph solve vs. fixed-lag.","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"(Image: Timing comparison of full solve vs. fixed-lag)","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"NOTE Work is underway (aka \"Project Tree House\") to reduce overhead computations that result in poorer fixed-lag solving times.  We expect the fixed-lag performance to improve in the coming months (Written Nov 2018).  Please file issues if a deeper discussion is required. ","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#Additional-Example-1","page":"Fixed-Lag Solving 2D","title":"Additional Example","text":"","category":"section"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"Work In Progress, but In the mean time see the following examples:","category":"page"},{"location":"examples/interm_fixedlag_hexagonal/#","page":"Fixed-Lag Solving 2D","title":"Fixed-Lag Solving 2D","text":"https://github.com/JuliaRobotics/Caesar.jl/blob/master/examples/wheeled/racecar/apriltagandzed_slam.jl","category":"page"},{"location":"principles/multiplyingDensities/#Principle:-Multiplying-Functions-(Python)-1","page":"Multiplying Functions (.py)","title":"Principle: Multiplying Functions (Python)","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"This example illustrates a central concept in Caesar.jl (and the multimodal-iSAM algorithm), whereby different probability belief functions are multiplied together. The true product between various likelihood beliefs is very complicated to compute, but a good approximations exist. In addition, ZmqCaesar offers a ZMQ interface to the factor graph solution for multilanguage support.  This example is a small subset that shows how to use the ZMQ infrastructure, but avoids the larger factor graph related calls.","category":"page"},{"location":"principles/multiplyingDensities/#Products-of-Infinite-Objects-(Functionals)-1","page":"Multiplying Functions (.py)","title":"Products of Infinite Objects (Functionals)","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Consider multiplying multiple belief density functions together, for example ","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"f = f_1 times f_2 times f_3","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"which is a core operation required for solving the Chapman-Kolmogorov transit equations.","category":"page"},{"location":"principles/multiplyingDensities/#Direct-Julia-Calculation-1","page":"Multiplying Functions (.py)","title":"Direct Julia Calculation","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"The ApproxManifoldProducts.jl package (under development) is meant to unify many on-manifold product operations, and can be called directly in Julia:","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"using ApproxManifoldProducts\n\nf1 = manikde!(randn(100,1).-3.0, (:Euclid,))\nf2 = manikde!(randn(100,1).+3.0, (:Euclid,))\n...\n\nf12 = maniproduct([f1;f2], (:Euclid,))","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Also see previous KernelDensityEstimate.jl.","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"To make Caesar.jl usable from other languages, a ZMQ server interface model has been developed which can also be used to test this principle functional product operation.","category":"page"},{"location":"principles/multiplyingDensities/#Not-Susceptible-to-Particle-Depletion-1","page":"Multiplying Functions (.py)","title":"Not Susceptible to Particle Depletion","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"The product process of say f1*f2 is not a importance sampling procedure that is commonly used in particle filtering, but instead a more advanced Bayesian inference process based on a wide variety of academic literature.  The KernelDensityEstimate method is a stochastic method, what active research is looking into deterministic homotopy/continuation methods.","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"The easy example that demonstrates that particle depletion is avoided here, is where f1 and f2 are represented by well separated and evenly weighted samples – the Bayesian inference 'product' technique efficiently produces new (evenly weighted) samples for f12 somewhere in between f1 and f2, but clearly not overlapping the original population of samples used for f1 and f2.  In contrast, conventional particle filtering measurement updates would have \"de-weighted\" particles of either input function and then be rejected during an eventual resampling step, thereby depleting the sample population.","category":"page"},{"location":"principles/multiplyingDensities/#Starting-the-ZMQ-server-1","page":"Multiplying Functions (.py)","title":"Starting the ZMQ server","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Caesar.jl provides a startup script for a default ZMQ instance.  Start a server and allow precompilations to finish, as indicated by a printout message \"waiting to receive...\".  More details here.","category":"page"},{"location":"principles/multiplyingDensities/#Functional-Products-via-Python-1","page":"Multiplying Functions (.py)","title":"Functional Products via Python","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Clone the Python GraffSDK.py code here and look at the product.py file.","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"import sys\nsys.path.append('..')\n\nimport numpy as np\nfrom graff.Endpoint import Endpoint\nfrom graff.Distribution.Normal import Normal\nfrom graff.Distribution.SampleWeights import SampleWeights\nfrom graff.Distribution.BallTreeDensity import BallTreeDensity\n\nfrom graff.Core import MultiplyDistributions\n\nimport matplotlib.pyplot as plt\n\nif __name__ == '__main__':\n    e = Endpoint()\n\n    e.Connect('tcp://192.168.0.102:5555')\n    print(e.Status())\n\n    N = 1000\n    u1 = 0.0\n    s1 = 10.0\n    x1 = u1+s1*np.random.randn(N)\n\n    u2 = 50.0\n    s2 = 10.0\n    x2 = u2+s2*np.random.randn(N)\n    b1 = BallTreeDensity('Gaussian', np.ones(N), np.ones(N), x1)\n    b2 = BallTreeDensity('Gaussian', np.ones(N), np.ones(N), x2)\n\n    rep = MultiplyDistributions(e, [b1,b2])\n    print(rep)\n    x = np.array(rep['points'] )\n    # plt.stem(x, np.ones(len(x)) )\n    plt.hist(x, bins = int(len(x)/10.0), color= 'm')\n    plt.hist(x1, bins = int(len(x)/10.0),color='r')\n    plt.hist(x2, bins = int(len(x)/10.0),color='b')\n    plt.show()\n\n    e.Disconnect()","category":"page"},{"location":"principles/multiplyingDensities/#A-Basic-Factor-Graph-Product-Illustration-1","page":"Multiplying Functions (.py)","title":"A Basic Factor Graph Product Illustration","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Using the factor graph methodology, we can repeat the example by adding variable and two prior factors.  This can be done directly in Julia (or via ZMQ in the further Python example below)","category":"page"},{"location":"principles/multiplyingDensities/#Products-of-Functions-(Factor-Graphs-in-Julia)-1","page":"Multiplying Functions (.py)","title":"Products of Functions (Factor Graphs in Julia)","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Directly in Julia:","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"using IncrementalInference\n\nfg = initfg()\n\naddVariable!(fg, :x0, ContinuousScalar)\naddFactor!(fg, [:x0], Prior(Normal(-3.0,1.0)))\naddFactor!(fg, [:x0], Prior(Normal(+3.0,1.0)))\n\nbatchSolve!(fg)\n\n# plot the results\nusing KernelDensityEstimatePlotting\n\nplotKDE(getKDE(fg, :x0))","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"Example figure:","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/JuliaRobotics/Caesar.jl/master/docs/imgs/productexample.png\" width=\"480\" border=\"0\" />\n</p>","category":"page"},{"location":"principles/multiplyingDensities/#Products-of-Functions-(Via-Python-and-ZmqCaesar)-1","page":"Multiplying Functions (.py)","title":"Products of Functions (Via Python and ZmqCaesar)","text":"","category":"section"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"We repeat the example using Python and the ZMQ interface:","category":"page"},{"location":"principles/multiplyingDensities/#","page":"Multiplying Functions (.py)","title":"Multiplying Functions (.py)","text":"import sys\nsys.path.append('..')\n\nimport numpy as np\nfrom graff.Endpoint import Endpoint\nfrom graff.Distribution.Normal import Normal\nfrom graff.Distribution.SampleWeights import SampleWeights\nfrom graff.Distribution.BallTreeDensity import BallTreeDensity\n\nfrom graff.Core import MultiplyDistributions\n\n\nif __name__ == '__main__':\n    \"\"\"\n\n    \"\"\"\n    e.Connect('tcp://127.0.0.1:5555')\n    print(e.Status())\n\n    # Add the first pose x0\n    x0 = Variable('x0', 'ContinuousScalar')\n    e.AddVariable(x0)\n\n    # Add at a fixed location PriorPose2 to pin x0 to a starting location\n    prior = Factor('Prior', ['x0'], Normal(np.zeros(1,1)-3.0, np.eye(1)) )\n    e.AddFactor(prior)\n    prior = Factor('Prior', ['x0'], Normal(np.zeros(1,1)+3.0, np.eye(1)) )\n    e.AddFactor(prior)","category":"page"},{"location":"concepts/adding_variables_factors/#Creating-New-Variables-and-Factors-1","page":"Custom Variables and Factors","title":"Creating New Variables and Factors","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"In most scenarios, the existing variables and factors should be sufficient for most robotics applications. Caesar however, is extensible and allows you to easily incorporate your own variable and factor types for specialized applications.","category":"page"},{"location":"concepts/adding_variables_factors/#Considerations-1","page":"Custom Variables and Factors","title":"Considerations","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"A couple of important points:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You do not need to modify/fork/edit internal Caesar/RoME/IncrementalInference source code to introduce new variable and factor types!\nAs long as the factors exist in the working space when the solver is run, the factors are automatically used – this is possible due to Julia's multiple dispatch design\nCaesar is designed to allow you to add new variables and factors to your own independent repository and incorporate them at will at compile-time or even run-time\nResidual function definitions for new factors types use a callable struct (a.k.a functor) architecture to simultaneously allow:  \nMultiple dispatch (i.e. 'polymorphic' behavior)\nMeta-data and in-place memory storage for advanced and performant code\nAn outside callback implementation style\nIn most robotics scenarios, there is no need for new variables or factors:\nVariables have various mechanisms that allow you to attach data to them, e.g. raw sensory data or identified April tags, so you do not need to create a new variable type just to store data\nNew variables are required only if you are representing a new state - TODO: Example of needed state\nNew factors are needed if:\nYou need to represent a constraint for a variable (known as a singleton) and that constraint type doesn't exist\nYou need to represent a constraint between two variables and that constraint type doesn't exist","category":"page"},{"location":"concepts/adding_variables_factors/#Getting-Started-1","page":"Custom Variables and Factors","title":"Getting Started","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"We suggest the following design pattern for developing and building new factors:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You have reviewed the variable and factor types available in Caesar, RoME, and IncrementalInference and a new type is required - please see Building and Solving Graphs if you want to review what is currently available\n[OPTIONAL] Create a GitHub repository to store the new types (new types in the Julia Main scope is perfectly okay!)\nCreate your new variable types\nCreate your new factor types\nImplement unit tests to validate the correct operation of the types\nSet up your solver to make use the custom types","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"1.1. This is much easier than it sounds","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"If the code is public and may be useful to the community, we ask if you could submit an issue against Caesar with information about the new types and the repository. Ideally we'd like to continually improve the core code and fold in community contributions.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"The remainder of this section discusses each of these steps.","category":"page"},{"location":"concepts/adding_variables_factors/#[OPTIONAL]-Creating-a-Repository-1","page":"Custom Variables and Factors","title":"[OPTIONAL] Creating a Repository","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You can fork the following template repository to construct your own Caesar Variable and Factor Examples.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"If this repository is going to be used for development of the new variables/factors as well as for the experiment (i.e. the code that builds the graph and solves it), you should probably start a simple end-to-end test that validates a basic version of your experimental setup (e.g. ):","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"#### This example is a basic test of the new variables and factors\n#### that are added in this repo. The example is derived from\n#### the hexagonal test example.\n\nusing Caesar, RoME\nusing Caesar_VariableFactorExamples # Your new variable/factor repository\n# Using plotting for experiment validation\nusing RoMEPlotting\n\n# 1. Init factor graph\n#TODO\n\n# 2. Add variables\n#TODO\n\n# 3. Add factors\n# 3a. Add a new test prior\n#TODO\n# 3b. Add new types of odometry factors.\n#TODO\n\n# 4. Solve graph\nbatchSolve!(fg)\n\n# 5. Graph solution - assuming that you have this open in Atom.\ndrawPoses(fg)","category":"page"},{"location":"concepts/adding_variables_factors/#Creating-New-Variables-1","page":"Custom Variables and Factors","title":"Creating New Variables","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"All variables have to derive from IncrementalInference.InferenceVariable.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"What you need to build in the variable:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"dims - This is used during computation and defines the degrees of freedom (dimensions) for variable\nlabels - This a required field, although it does not need to be populated. It consists of unique, indexable string identifiers, such as 'POSE', 'LANDMARK'. It assists with querying the data efficiently in large systems when using the database layer.  ","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You can then also add any additional fields that you would like to use for saving state information in variable. Note that these fields must be serializable as both JSON and Protobufs. Although you don't need to validate this, please keep the fields fairly simple and avoid complex structures with optional fields. TBD - provide a compatibility check for serialization and a docpage on it.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"In a trivial example of Pose2:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"Our dimensions would then be 3: X, Y, theta\nThe labels for Pose2 could be \"POSE\"","category":"page"},{"location":"concepts/adding_variables_factors/#Creating-New-Factors-1","page":"Custom Variables and Factors","title":"Creating New Factors","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"All factors inherit from one of the following types, depending on their function:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"FunctorSingleton: FunctorSingletons are priors (unary factors) that provide an absolute constraint for a single variable. A simple example of this is an absolute GPS prior, or equivalently a (0, 0, 0) starting location in a RoME.Pose2 scenario.\nRequires: A getSample function\nFunctorPairwiseMinimize: FunctorPairwiseMinimize are relative factors that introduce an algebraic relationship between two or more variables. A simple example of this is an odometry factor between two pose variables, or a range factor indicating the range between a pose and another variable.\nRequires: A getSample function and a residual function definition\nThe minimize suffix specifies that the residual function of this factor will be enforced by numerical minimization (find me the minimum of this function)\nFunctorPairwise: FunctorPairwise are relative factors that introduce algebraic relationships between two or more variables. They are the same as FunctorPairwiseMinimize, however they use root finding to find the zero crossings (rather than numerical minimization).\nRequires: A getSample function and a residual function definition","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"How do you decide which to use?","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"If you are creating factors for world-frame information that will be tied to a single variable, inherit from FunctorSingleton\nGPS coordinates should be priors\nIf you are creating factors for local-frame relationships between variables, inherit from FunctorPairwiseMinimize\nOdometry and bearing deltas should be introduced as pairwise factors and should be local frame","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"TBD: sUsers should start with FunctorPairwiseMinimize, discuss why and when they should promote their factors to FunctorPairwise.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"Note: FunctorPairwiseMinimize does not imply that the overall inference algorithm only minimizes an objective function. The Multi-model iSAM algorithm is built around fixed-point analysis. Minimization is used here to locally enforce the residual function.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"What you need to build in the new factor:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"A struct for the factor itself\nA sampler function to return measurements from the random ditributions\nIf you are building a FunctorPairwiseMinimize or a FunctorPairwise you need to define a residual function to introduce the relative algebraic relationship between the variables\nMinimization function should be lower-bounded and smooth\nA packed type of the factor which must be named Packed[Factor name], and allows the factor to be packed/transmitted/unpacked\nSerialization and deserialization methods\nThese are convert functions that pack and unpack the factor (which may be highly complex) into serialization-compatible formats\nAs the factors are mostly comprised of distributions (of type SamplableBelief), functions are provided to pack and unpack the distributions:\nPacking: To convert from a SamplableBelief to a string, use string(::SamplableBelief)::String\nUnpacking: To convert from string back to a SamplableBelief, use extractdistribution(::String)::SamplableBelief  ","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"An example of this is the Pose2Point2BearingRange, which provides a bearing+range relationship between a 2D pose and a 2D point.","category":"page"},{"location":"concepts/adding_variables_factors/#Pose2Point2BearingRange-Struct-1","page":"Custom Variables and Factors","title":"Pose2Point2BearingRange Struct","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"mutable struct Pose2Point2BearingRange{B <: IIF.SamplableBelief, R <: IIF.SamplableBelief} <: IncrementalInference.FunctorPairwise\n    bearing::B\n    range::R\n    Pose2Point2BearingRange{B,R}() where {B,R} = new{B,R}()\n    Pose2Point2BearingRange{B,R}(x1::B,x2::R) where {B <: IIF.SamplableBelief,R <: IIF.SamplableBelief} = new{B,R}(x1,x2)\nend\n# Convenient constructor\nPose2Point2BearingRange(x1::B,x2::R) where {B <: IIF.SamplableBelief,R <: IIF.SamplableBelief} = Pose2Point2BearingRange{B,R}(x1,x2)","category":"page"},{"location":"concepts/adding_variables_factors/#Pose2Point2BearingRange-Sampler-1","page":"Custom Variables and Factors","title":"Pose2Point2BearingRange Sampler","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"# Return N samples from the two distributions\nfunction getSample(pp2br::Pose2Point2BearingRange, N::Int=1)\n  smpls = zeros(2, N)\n  smpls[1,:] = rand(pp2br.bearing, N)[:]\n  smpls[2,:] = rand(pp2br.range, N)[:]\n  return (smpls,)\nend","category":"page"},{"location":"concepts/adding_variables_factors/#Pose2Point2BearingRange-Residual-Function-(Functor)-1","page":"Custom Variables and Factors","title":"Pose2Point2BearingRange Residual Function (Functor)","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"# define the conditional probability constraint\nfunction (pp2br::Pose2Point2BearingRange)(res::Array{Float64},\n        userdata::FactorMetadata,\n        idx::Int,\n        meas::Tuple{Array{Float64,2}},\n        xi::Array{Float64,2},\n        lm::Array{Float64,2} )\n  #\n  res[1] = lm[1,idx] - (meas[1][2,idx]*cos(meas[1][1,idx]+xi[3,idx]) + xi[1,idx])\n  res[2] = lm[2,idx] - (meas[1][2,idx]*sin(meas[1][1,idx]+xi[3,idx]) + xi[2,idx])\n  nothing\nend","category":"page"},{"location":"concepts/adding_variables_factors/#Pose2Point2BearingRange-Packing-and-Unpacking-1","page":"Custom Variables and Factors","title":"Pose2Point2BearingRange Packing and Unpacking","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"The packing structure:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"mutable struct PackedPose2Point2BearingRange <: IncrementalInference.PackedInferenceType\n    bearstr::String\n    rangstr::String\n    PackedPose2Point2BearingRange() = new()\n    PackedPose2Point2BearingRange(s1::AS, s2::AS) where {AS <: AbstractString} = new(string(s1),string(s2))\nend","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"The packing and unpacking converters (note the use of string and extractdistribution):","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"function convert(::Type{PackedPose2Point2BearingRange}, d::Pose2Point2BearingRange{B, R}) where {B <: IIF.SamplableBelief, R <: IIF.SamplableBelief}\n  return PackedPose2Point2BearingRange(string(d.bearing), string(d.range))\nend\n\nfunction convert(::Type{Pose2Point2BearingRange}, d::PackedPose2Point2BearingRange)\n # where {B <: IIF.SamplableBelief, R <: IIF.SamplableBelief}\n  Pose2Point2BearingRange(extractdistribution(d.bearstr), extractdistribution(d.rangstr))\nend","category":"page"},{"location":"concepts/adding_variables_factors/#Unit-Tests-1","page":"Custom Variables and Factors","title":"Unit Tests","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"What you should test:","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"Creation of the factor\nSampling of the factor\nResidual testing\nSolving using the variables and factors\nSerialization and deserialization","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"An example of these tests can be seen for the trivial case shown in the example repo ExamplePrior Unit Tests.","category":"page"},{"location":"concepts/adding_variables_factors/#Using-your-Types-with-the-Caesar-Solver-1","page":"Custom Variables and Factors","title":"Using your Types with the Caesar Solver","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"As above, as long as you bring your factors into the workspace, you should be able to use them in your experimental setup.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"You can validate this with the existence check code in Building and Solving Graphs.","category":"page"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"Note: This has been made available as IncrementalInference.getCurrentWorkspaceVariables() and IncrementalInference.getCurrentWorkspaceFactors()in IncrementalInference v0.4.4.","category":"page"},{"location":"concepts/adding_variables_factors/#Contributing-to-Community-1","page":"Custom Variables and Factors","title":"Contributing to Community","text":"","category":"section"},{"location":"concepts/adding_variables_factors/#","page":"Custom Variables and Factors","title":"Custom Variables and Factors","text":"We really appreciate any contributions, so if you have developed variables and factors that may be useful to the community, please write up an issue in Caesar.jl with a link to your repo and a short description of the use-case(s).","category":"page"},{"location":"examples/basic_definingfactors/#Defining-New-Variables-and-Factors-1","page":"Creating Variables and Factors","title":"Defining New Variables and Factors","text":"","category":"section"},{"location":"examples/basic_definingfactors/#","page":"Creating Variables and Factors","title":"Creating Variables and Factors","text":"TODO: Smooth text and flow.","category":"page"},{"location":"examples/basic_definingfactors/#Quick-Example-in-One-Dimension-1","page":"Creating Variables and Factors","title":"Quick Example in One Dimension","text":"","category":"section"},{"location":"examples/basic_definingfactors/#","page":"Creating Variables and Factors","title":"Creating Variables and Factors","text":"Note these factors already exists in IncrementalInference (and many more in RoME) and are presented here as a first introduction into the process of defining your own factors.","category":"page"},{"location":"examples/basic_definingfactors/#","page":"Creating Variables and Factors","title":"Creating Variables and Factors","text":"User scope Prior, LinearOffset, and MultiModalOffset with arbitrary distributions are defined as:","category":"page"},{"location":"examples/basic_definingfactors/#","page":"Creating Variables and Factors","title":"Creating Variables and Factors","text":"import IncrementalInference: getSample\n\nstruct Prior{T} <: IncrementalInference.FunctorSingleton where T <: Distribution\n  z::T\nend\ngetSample(s::Prior, N::Int=1) = (reshape(rand(s.z,N),1,:), )\nstruct LinearOffset{T} <: IncrementalInference.FunctorPairwise where T <: Distribution\n  z::T\nend\ngetSample(s::LinearOffset, N::Int=1) = (reshape(rand(s.z,N),1,:), )\nfunction (s::LinearOffset)(res::Array{Float64},\n                           userdata::FactorMetadata,\n                           idx::Int,\n                           meas::Tuple{Array{Float64, 2}},\n                           X1::Array{Float64,2},\n                           X2::Array{Float64,2}  )\n  #\n  res[1] = meas[1][idx] - (X2[1,idx] - X1[1,idx])\n  nothing\nend\nstruct MultiModalOffset <: IncrementalInference.FunctorPairwise\n  z::Vector{Distribution}\n  c::Categorical\nend\ngetSample(s::MultiModalOffset, N::Int=1) = (reshape.(rand.(s.z, N),1,:)..., rand(s.c, N))\nfunction (s::MultiModalOffset)(res::Array{Float64},\n                               userdata::FactorMetadata,\n                               idx::Int,\n                               meas::Tuple,\n                               X1::Array{Float64,2},\n                               X2::Array{Float64,2}  )\n  #\n  res[1] = meas[meas[end][idx]][idx] - (X2[1,idx] - X1[1,idx])\n  nothing\nend","category":"page"},{"location":"examples/basic_definingfactors/#","page":"Creating Variables and Factors","title":"Creating Variables and Factors","text":"Notice the residual function relating to the two PairwiseFunctor derived definitions. The one dimensional residual functions, res[1] = measurement - prediction, are used during inference to approximate the convolution of conditional beliefs from the sample approximate marginal beliefs of the connected variables.","category":"page"},{"location":"examples/interm_dynpose/#Adding-Dynamic-Factors-and-Variables-1","page":"Creating DynPose Factor","title":"Adding Dynamic Factors and Variables","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"This tutorial describes how a new factor can be developed, beyond the pre-existing implementation in RoME.jl.  Factors can accept any number of variable dependencies and allow for a wide class of allowable function calls can be used.  Our intention is to make it as easy as possible for users to create their own factor types.","category":"page"},{"location":"examples/interm_dynpose/#Example:-Adding-Velocity-to-RoME.Point2-1","page":"Creating DynPose Factor","title":"Example: Adding Velocity to RoME.Point2","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A smaller example in two dimensions where we wish to estimate the velocity of some target:  Consider two variables :x0 with a prior as well as a conditional–-likelihood for short–-to variable :x1.  Priors are in the \"global\" reference frame (how ever you choose to define it), while likelihoods are in the \"local\" / \"relative\" frame that only exist between variables.","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"(Image: dynpoint2fg)","category":"page"},{"location":"examples/interm_dynpose/#Brief-on-Variable-Node-softtypes-1","page":"Creating DynPose Factor","title":"Brief on Variable Node softtypes","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Variable nodes retain meta data (so called \"soft types\") describing the type of variable.  Common VariableNode types are RoME.Point2D, RoME.Pose3D.  VariableNode soft types are passed during construction of the factor graph, for example:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"v1 = addVariable!(fg, :x1, Pose2)","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Certain cases require that more information be retained for each VariableNode, and velocity calculations are a clear example where time stamp data across positions is required.  ","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Note Larger data can also be stored under the bigdata framework which is discussed here (TBD).","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"If the required VariableNode does not exist, then one can be created, such as adding velocity states with DynPoint2:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct DynPoint2 <: IncrementalInference.InferenceVariable\n  ut::Int64 # microsecond time\n  dims::Int\n  labels::Vector{String}\n  DynPoint2(;ut::Int64=0, labels::Vector{<:AbstractString}=String[]) = new(ut, 4, labels)\nend","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"The dims field is permanently set to 4, i.e. [x, y, dx/dt, dy/dt].  Labels represent special labels that can be used for more efficient indexing in database systems.  The utparameter is for storing the microsecond time stamp for that variable node.","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"In order to implement your own factor type outside IncrementalInference you should import the required identifiers, as follows:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"using IncrementalInference\nimport IncrementalInference: getSample","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Note that new factor types can be defined at any time, even after you have started to construct the FactorGraph object.","category":"page"},{"location":"examples/interm_dynpose/#DynPoint2VelocityPrior-1","page":"Creating DynPose Factor","title":"DynPoint2VelocityPrior","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Work in progress.","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct DynPoint2VelocityPrior{T} <: IncrementalInference.FunctorSingleton where {T <: Distribution}\n  z::T\n  DynPoint2VelocityPrior{T}() where {T <: Distribution} = new{T}()\n  DynPoint2VelocityPrior(z1::T) where {T <: Distribution} = new{T}(z1)\nend\ngetSample(dp2v::DynPoint2VelocityPrior, N::Int=1) = (rand(dp2v.z,N), )","category":"page"},{"location":"examples/interm_dynpose/#DynPoint2DynPoint2-(preintegration)-1","page":"Creating DynPose Factor","title":"DynPoint2DynPoint2 (preintegration)","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"The basic idea is that change in position is composed of three components (originating from double integration of Newton's second law):","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"(Image: deltapositionplus) ( eq. 1)","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"DynPoint2DynPoint2 factor is using the above equation to define the difference in position between the two DynPoint2s.  The position part stored in DynPoint2DynPoint2 factor corresponds to (Image: deltaposplusonly).  A new multi-variable (so called \"pairwise\") factor between any number of variables is defined with three elements:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Factor type definition that inherits either IncrementalInference.FunctorPairwise or IncrementalInference.FunctorPairwiseMinimize;","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct DynPoint2DynPoint2{T} <: IncrementalInference.FunctorPairwise where {T <: Distribution}\n  z::T\n  DynPoint2DynPoint2{T}() where {T <: Distribution} = new{T}()\n  DynPoint2DynPoint2(z1::T) where {T <: Distribution} = new{T}(z1)\nend","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A sampling function with exactly the signature: getSample(dp2dp2::DynPoint2DynPoint2, N::Int=1) and returning a Tuple (legacy reasons);","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"getSample(dp2dp2::DynPoint2DynPoint2, N::Int=1) = (rand(dp2dp2.z,N), )","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A residual or minimization function with exactly the signature described below.","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Residual (related to FunctorPairwise) or factor minimization function (related to FunctorPairwiseMinimize) signatures should match this dp2dp2::DynPoint2DynPoint2 example:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"function (dp2dp2::DynPoint2DynPoint2)(\n            res::Array{Float64},\n            userdata,\n            idx::Int,\n            meas::Tuple,\n            Xs...  )::Nothing","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"where Xs can be expanded to the particular number of variable nodes this factor will be associated, and note they are order sensitive at addFactor!(fg, ...) time.  The res parameter is a vector of the same dimension defined by the largest of the Xs terms.  The userdata value contains the small metadata / userdata portions of information that was introduced to the factor graph at construction time – please consult error(string(fieldnames(userdata))) for details at this time.  This is a relatively new feature in the code and likely to be improved.  The idx parameter represents a legacy index into the measurement meas[1] and variables Xs to select the desired marginal sample value.  Future versions of the code plan to remove the idx parameter entirely.  The Xs array of parameter are each of type ::Array{Float64,2} and contain the estimated samples from each of the current best marginal belief estimates of the factor graph variable node.  ","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"function (dp2dp2::DynPoint2DynPoint2)(\n            res::Array{Float64},\n            userdata,\n            idx::Int,\n            meas::Tuple,\n            Xi::Array{Float64,2},\n            Xj::Array{Float64,2}  )\n  #\n  z = meas[1][:,idx]\n  xi, xj = Xi[:,idx], Xj[:,idx]\n  dt = (userdata.variableuserdata[2].ut - userdata.variableuserdata[1].ut)*1e-6   # roughly the intended use of userdata\n  res[1:2] = z[1:2] - (xj[1:2] - (xi[1:2]+dt*xi[3:4]))\n  res[3:4] = z[3:4] - (xj[3:4] - xi[3:4])\n  nothing\nend","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A brief usage example looks as follows, and further questions about how the preintegration strategy was implemented can be traced through the original issue JuliaRobotics/RoME.jl#60 or the literature associated with this project, or contact for more information.","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"using RoME, Distributions\nfg = initfg()\nv0 = addVariable!(fg, :x0, DynPoint2(ut=0))\n\n# Prior factor as boundary condition\npp0 = DynPoint2VelocityPrior(MvNormal([zeros(2);10*ones(2)], 0.1*eye(4)))\nf0 = addFactor!(fg, [:x0;], pp0)\n\n# conditional likelihood between Dynamic Point2\nv1 = addVariable!(fg, :x1, DynPoint2(ut=1000_000)) # time in microseconds\ndp2dp2 = DynPoint2DynPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))\nf1 = addFactor!(fg, [:x0;:x1], dp2dp2)\n\nensureAllInitialized!(fg)\ntree = wipeBuildNewTree!(fg)\ninferOverTree!(fg, tree)\n\nusing KernelDensityEstimate\n@show x0 = getKDEMax(getVertKDE(fg, :x0))\n# julia> ... = [-0.19441, 0.0187019, 10.0082, 10.0901]\n@show x1 = getKDEMax(getVertKDE(fg, :x1))\n # julia> ... = [19.9072, 19.9765, 10.0418, 10.0797]","category":"page"},{"location":"examples/interm_dynpose/#VelPoint2VelPoint2-(back-differentiation)-1","page":"Creating DynPose Factor","title":"VelPoint2VelPoint2 (back-differentiation)","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"In case the preintegrated approach is not the first choice, we include VelPoint2VelPoint2 <: IncrementalInference.FunctorPairwiseMinimize as a second likelihood factor example which may seem more intuitive:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"mutable struct VelPoint2VelPoint2{T} <: IncrementalInference.FunctorPairwiseMinimize where {T <: Distribution}\n  z::T\n  VelPoint2VelPoint2{T}() where {T <: Distribution} = new{T}()\n  VelPoint2VelPoint2(z1::T) where {T <: Distribution} = new{T}(z1)\nend\ngetSample(vp2vp2::VelPoint2VelPoint2, N::Int=1) = (rand(vp2vp2.z,N), )\nfunction (vp2vp2::VelPoint2VelPoint2)(\n                res::Array{Float64},\n                userdata,\n                idx::Int,\n                meas::Tuple,\n                Xi::Array{Float64,2},\n                Xj::Array{Float64,2}  )\n  #\n  z = meas[1][:,idx]\n  xi, xj = Xi[:,idx], Xj[:,idx]\n  dt = (userdata.variableuserdata[2].ut - userdata.variableuserdata[1].ut)*1e-6   # roughly the intended use of userdata\n  dp = (xj[1:2]-xi[1:2])\n  dv = (xj[3:4]-xi[3:4])\n  res[1] = 0.0\n  res[1] += sum((z[1:2] - dp).^2)\n  res[1] += sum((z[3:4] - dv).^2)\n  res[1] += sum((dp/dt - xi[3:4]).^2)  # (dp/dt - 0.5*(xj[3:4]+xi[3:4])) # midpoint integration\n  res[1]\nend","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"A similar usage example here shows:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"fg = initfg()\n\n# add three point locations\nv0 = addVariable!(fg, :x0, DynPoint2(ut=0))\nv1 = addVariable!(fg, :x1, DynPoint2(ut=1000_000))\nv2 = addVariable!(fg, :x2, DynPoint2(ut=2000_000))\n\n# Prior factor as boundary condition\npp0 = DynPoint2VelocityPrior(MvNormal([zeros(2);10*ones(2)], 0.1*eye(4)))\nf0 = addFactor!(fg, [:x0;], pp0)\n\n# conditional likelihood between Dynamic Point2\ndp2dp2 = VelPoint2VelPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))\nf1 = addFactor!(fg, [:x0;:x1], dp2dp2)\n\n# conditional likelihood between Dynamic Point2\ndp2dp2 = VelPoint2VelPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))\nf2 = addFactor!(fg, [:x1;:x2], dp2dp2)\n\n# Graphs.plot(fg.g)\nensureAllInitialized!(fg)\ntree = wipeBuildNewTree!(fg)\ninferOverTree!(fg, tree)\n\n# see the output\n@show x0 = getKDEMax(getVertKDE(fg, :x0))\n@show x1 = getKDEMax(getVertKDE(fg, :x1))\n@show x2 = getKDEMax(getVertKDE(fg, :x2))","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Producing output:","category":"page"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"x0 = getKDEMax(getVertKDE(fg, :x0)) = [0.101503, -0.0273216, 9.86718, 9.91146]\nx1 = getKDEMax(getVertKDE(fg, :x1)) = [10.0087, 9.95139, 10.0622, 10.0195]\nx2 = getKDEMax(getVertKDE(fg, :x2)) = [19.9381, 19.9791, 10.0056, 9.92442]","category":"page"},{"location":"examples/interm_dynpose/#IncrementalInference.jl-Defining-Factors-(Future-API)-1","page":"Creating DynPose Factor","title":"IncrementalInference.jl Defining Factors (Future API)","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"We would like to remove the idx indexing from the residual function calls, since that is an unnecessary burden on the user.  Instead, the package will use views and SubArray types to simplify the interface.  Please contact author for more details (8 June 2018).","category":"page"},{"location":"examples/interm_dynpose/#Contributions-1","page":"Creating DynPose Factor","title":"Contributions","text":"","category":"section"},{"location":"examples/interm_dynpose/#","page":"Creating DynPose Factor","title":"Creating DynPose Factor","text":"Thanks to mc2922 for raising the catalyst issue and conversations that followed from JuliaRobotics/RoME.jl#60.","category":"page"},{"location":"dev/wiki/#Developer-Wiki-1","page":"Wiki Pointer","title":"Developer Wiki","text":"","category":"section"},{"location":"dev/wiki/#","page":"Wiki Pointer","title":"Wiki Pointer","text":"More developer zone material will be added here in the future, but for the time being check out the Caesar Wiki.","category":"page"},{"location":"refs/literature/#Literature-1","page":"References","title":"Literature","text":"","category":"section"},{"location":"refs/literature/#","page":"References","title":"References","text":"Newly created page to list related references and additional literature pertaining to this package.","category":"page"},{"location":"refs/literature/#Direct-References-1","page":"References","title":"Direct References","text":"","category":"section"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.1]  Fourie, D., Leonard, J., Kaess, M.: \"A Nonparametric Belief Solution to the Bayes Tree\" IEEE/RSJ Intl. Conf. on Intelligent Robots and Systems (IROS), (2016).","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.2]  Fourie, D.: \"Multi-modal and Inertial Sensor Solutions for Navigation-type Factor   Graphs\", Ph.D. Thesis, Massachusetts Institute of Technology Electrical Engineering and Computer Science together with Woods Hole Oceanographic Institution Department for Applied Ocean Science and Engineering, September 2017.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.3]  Fourie, D., Claassens, S., Pillai, S., Mata, R., Leonard, J.: \"SLAMinDB: Centralized graph databases for mobile robotics\", IEEE Intl. Conf. on Robotics and Automation (ICRA), Singapore, 2017.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.4]  Cheung, M., Fourie, D., Rypkema, N., Vaz Teixeira, P., Schmidt, H., and Leonard, J.: \"Non-Gaussian SLAM utilizing Synthetic Aperture Sonar\", Intl. Conf. On Robotics and Automation (ICRA), IEEE, Montreal, 2019.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.5]  Doherty, K., Fourie, D., Leonard, J.: \"Multimodal Semantic SLAM with Probabilistic Data Association\", Intl. Conf. On Robotics and Automation (ICRA), IEEE, Montreal, 2019.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.6]  Fourie, D., Vaz Teixeira, P., Leonard, J.: \"Non-parametric Mixed-Manifold Products using Multiscale Kernel Densities\", IEEE Intl. Conf. on Intelligent Robots and Systems (IROS), (2019), under-review.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[1.7]  Fourie, D., Leonard, J.: \"Inertial Odometry with Retroactive Sensor Calibration\", publication under review.","category":"page"},{"location":"refs/literature/#Important-References-1","page":"References","title":"Important References","text":"","category":"section"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.1]  Kaess, Michael, et al. \"iSAM2: Incremental smoothing and mapping using the Bayes tree\" The International Journal of Robotics Research (2011): 0278364911430419.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.2]  Kaess, Michael, et al. \"The Bayes tree: An algorithmic foundation for probabilistic robot mapping.\" Algorithmic Foundations of Robotics IX. Springer, Berlin, Heidelberg, 2010. 157-173.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.3]  Kschischang, Frank R., Brendan J. Frey, and Hans-Andrea Loeliger. \"Factor graphs and the sum-product algorithm.\" IEEE Transactions on information theory 47.2 (2001): 498-519.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.4]  Dellaert, Frank, and Michael Kaess. \"Factor graphs for robot perception.\" Foundations and Trends® in Robotics 6.1-2 (2017): 1-139.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.5]  Sudderth, E.B., Ihler, A.T., Isard, M., Freeman, W.T. and Willsky, A.S., 2010. \"Nonparametric belief propagation.\" Communications of the ACM, 53(10), pp.95-103","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.6] Paskin, Mark A. \"Thin junction tree filters for simultaneous localization and mapping.\" in Int. Joint Conf. on Artificial Intelligence. 2003.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.7]  Farrell, J., and Matthew B.: \"The global positioning system and inertial navigation.\" Vol. 61. New York: Mcgraw-hill, 1999.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.8]  Zarchan, Paul, and Howard Musoff, eds. Fundamentals of Kalman filtering: a practical approach. American Institute of Aeronautics and Astronautics, Inc., 2013.","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.9]  Hanebeck, Uwe D. \"FLUX: Progressive State Estimation Based on Zakai-type Distributed Ordinary Differential Equations.\" arXiv preprint arXiv:1808.02825 (2018).","category":"page"},{"location":"refs/literature/#","page":"References","title":"References","text":"[2.10]  Muandet, Krikamol, et al. \"Kernel mean embedding of distributions: A review and beyond.\" Foundations and Trends® in Machine Learning 10.1-2 (2017): 1-141.","category":"page"},{"location":"refs/literature/#Additional-References-1","page":"References","title":"Additional References","text":"","category":"section"},{"location":"refs/literature/#","page":"References","title":"References","text":"[3.1]  Duits, Remco, Erik J. Bekkers, and Alexey Mashtakov. \"Fourier Transform on the Homogeneous Space of 3D Positions and Orientations for Exact Solutions to Linear Parabolic and (Hypo-) Elliptic PDEs.\" arXiv preprint arXiv:1811.00363 (2018).","category":"page"},{"location":"func_ref/#Function-Reference-1","page":"Caesar's Reference","title":"Function Reference","text":"","category":"section"},{"location":"func_ref/#","page":"Caesar's Reference","title":"Caesar's Reference","text":"Pages = [\n    \"func_ref.md\"\n]\nDepth = 3","category":"page"},{"location":"func_ref/#","page":"Caesar's Reference","title":"Caesar's Reference","text":"WORK IN PROGRESS  Not all functions have been added to this directory yet.","category":"page"},{"location":"func_ref/#Caesar-1","page":"Caesar's Reference","title":"Caesar","text":"","category":"section"},{"location":"func_ref/#","page":"Caesar's Reference","title":"Caesar's Reference","text":"appendvertbigdata!\nconsoleaskuserfordb\ndb2jld\nexecuteQuery\nfetchrobotdatafirstpose\nfetchsubgraph!\nfindExistingMSConstraints\ngetAllLandmarkNeoIDs\ngetBigDataElement\ngetExVertexNeoIDs\ngetLandmOtherSessNeoIDs\ngetLocalSubGraphMultisession\ngetPoseExVertexNeoIDs\ngetVertNeoIDs!\ngetfirstpose\ngetnewvertdict\ngetprpt2kde\nhasBigDataElement\ninsertrobotdatafirstpose!\nremoveNeo4jID\nresetentireremotesession\nrmInstMultisessionPriors!\nstandardcloudgraphsetup\nupdatenewverts!\nwhosNear2D\nwhosNear3D","category":"page"},{"location":"func_ref/#Caesar.appendvertbigdata!","page":"Caesar's Reference","title":"Caesar.appendvertbigdata!","text":"appendvertbigdata!(cloudGraph::CloudGraphs.CloudGraph, cv::CloudGraphs.CloudVertex, description::Any, data::Array{UInt8,1})\n\n\nAppend big data element into current blob store and update associated global vertex information.\n\n\n\n\n\nappendvertbigdata!(fgl::FactorGraph, vert::ExVertex, description::AbstractString, data::Array{UInt8,1})\n\n\nAppend big data element into current blob store and update associated global vertex information.\n\n\n\n\n\nappendvertbigdata!(fg, sym, descr, data)\n\nAppend big data element into current blob store using parent appendvertbigdata!, but here specified by symbol of variable node in the FactorGraph. Note the default data layer api definition. User must define dlapi to refetching the  vertex from the data layer. localapi avoids repeated network database fetches.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.consoleaskuserfordb","page":"Caesar's Reference","title":"Caesar.consoleaskuserfordb","text":"consoleaskuserfordb(; nparticles, drawdepth, clearslamindb, multisession, drawedges) -> Dict{AbstractString,Any}\n\n\nObtain database addresses and login credientials from STDIN, as well as a few case dependent options.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.db2jld","page":"Caesar's Reference","title":"Caesar.db2jld","text":"db2jld(cgl::CloudGraph, session::AbstractString, filename::AbstractString)\n\nFetch and save a FactorGraph session to a jld, using CloudGraph object and session definition.\n\n\n\n\n\ndb2jld(filename::AbstractString; addrdict::NothingUnion{Dict{AbstractString, AbstractString}}=nothing )\n\nFetch and save a FactorGraph session to a jld, using or asking STDIN for credentials in the addrdict field.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.executeQuery","page":"Caesar's Reference","title":"Caesar.executeQuery","text":"executeQuery(connection::AS<:AbstractString, query::AS<:AbstractString)\n\n\nRun Neo4j Cypher queries on the cloudGraph database, and return Tuple with the unparsed (results, loadresponse). Throws an error if the query fails.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.fetchrobotdatafirstpose","page":"Caesar's Reference","title":"Caesar.fetchrobotdatafirstpose","text":"fetchrobotdatafirstpose(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString)\n\nReturn dict of JSON parsed \"robot_description\" field as was inserted by counterpart insertrobotdatafirstpose! function. Used for storing general robot specific data in easily accessible manner.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.fetchsubgraph!","page":"Caesar's Reference","title":"Caesar.fetchsubgraph!","text":"fetchsubgraph!(fgl::FactorGraph, cvs::Array{CloudGraphs.CloudVertex,1}; numneighbors)\n\n\nFetch and insert list of CloudVertices into FactorGraph object, up to neighbor depth.\n\n\n\n\n\nfetchsubgraph!(fgl, neoids; numneighbors)\n\n\nFetch and insert list of Neo4j IDs into FactorGraph object, up to neighbor depth.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.findExistingMSConstraints","page":"Caesar's Reference","title":"Caesar.findExistingMSConstraints","text":"findExistingMSConstraints(fgl::FactorGraph)\n\nReturn Dict{Symbol, Int} of vertex symbol to Neo4j node ID of MULTISESSION constraints in this fgl.sessionname.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getAllLandmarkNeoIDs","page":"Caesar's Reference","title":"Caesar.getAllLandmarkNeoIDs","text":"getAllLandmarkNeoIDs(::Dict{Symbol, Dict{Symbol, Int}}, ::Symbol)\n\nReturn Vector{Int} of Neo4j vertex IDs relating to symbol, as listed in lm2others.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getBigDataElement","page":"Caesar's Reference","title":"Caesar.getBigDataElement","text":"getBigDataElement(vertex::CloudGraphs.CloudVertex, description::AbstractString) -> Union{Nothing, BigDataElement}\n\n\nWalk through vertex bigDataElements and return the last matching description.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getExVertexNeoIDs","page":"Caesar's Reference","title":"Caesar.getExVertexNeoIDs","text":"getExVertexNeoIDs(conn::Neo4j.Connection; label, ready, backendset, session, robot, user, reqbackendset) -> Array{Tuple{Int64,Int64,Symbol},1}\n\n\nReturn array of tuples with ExVertex IDs and Neo4j IDs for vertices with label in session.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getLandmOtherSessNeoIDs","page":"Caesar's Reference","title":"Caesar.getLandmOtherSessNeoIDs","text":"getLandmOtherSessNeoIDs{T <: AbstractString}(::CloudGraph, session::T=\"\", robot::T=\"\", user::T=\"\", multisessions=Vector{T}())\n\nReturn dict of dict of Neo4j vertex IDs by session and landmark symbols.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getLocalSubGraphMultisession","page":"Caesar's Reference","title":"Caesar.getLocalSubGraphMultisession","text":"getLocalSubGraphMultisession(cg::T<:AbstractString, lm2others::T<:AbstractString; session, robot, user, numneighbors)\n\n\nReturn subgraph copy of type FactorGraph contaning values from session in lm2others, and Vector{Symbol} of primary key symbols used for graph exstraction.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getPoseExVertexNeoIDs","page":"Caesar's Reference","title":"Caesar.getPoseExVertexNeoIDs","text":"getPoseExVertexNeoIDs(conn::Neo4j.Connection; ready, backendset, session, reqbackendset)\n\n\nReturn array of tuples with ExVertex IDs and Neo4j IDs for all poses.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getVertNeoIDs!","page":"Caesar's Reference","title":"Caesar.getVertNeoIDs!","text":"getVertNeoIDs!(::CloudGraph, res::Dict{Symbol, Int}; session::AbstractString=\"NA\", robot::AbstractString=\"NA\", user::AbstractString=\"NA\")\n\nInsert into and return dict res with Neo4j IDs of ExVertex labels as stored per session in Neo4j database.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getfirstpose","page":"Caesar's Reference","title":"Caesar.getfirstpose","text":"getfirstpose(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString)\n\nReturn Tuple{Symbol, Int} of first pose symbol and Neo4j node ID.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getnewvertdict","page":"Caesar's Reference","title":"Caesar.getnewvertdict","text":"getnewvertdict(conn, session::AbstractString, robot::AbstractString, user::AbstractString)\n\nReturn a dictionary with frtend and mongo_keys json string information for :NEWDATA elements in Neo4j database.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.getprpt2kde","page":"Caesar's Reference","title":"Caesar.getprpt2kde","text":"getprp2kde(::CloudGraph, neoids::Vector{Int}; N::Int=100)\n\nReturn PriorPoint2DensityNH with N points based on beliefs of neoids, and equal share null hypothesis between length(neoids)+1 beliefs.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.hasBigDataElement","page":"Caesar's Reference","title":"Caesar.hasBigDataElement","text":"hasBigDataElement(vertex::CloudGraphs.CloudVertex, description::AbstractString) -> Bool\n\n\nReturn true if vertex has bigDataElements with matching description.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.insertrobotdatafirstpose!","page":"Caesar's Reference","title":"Caesar.insertrobotdatafirstpose!","text":"insertrobotdatafirstpose!(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString, robotdict::Dict)\n\nSaves robotdict via JSON to first pose in a SESSION in the database. Used for storing general robot specific data in easily accessible manner. Can fetch later retrieve same dict with counterpart fetchrobotdatafirstpose function.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.removeNeo4jID","page":"Caesar's Reference","title":"Caesar.removeNeo4jID","text":"removeNeo4jID(cg::CloudGraph, neoid=-1)\n\nRemove node from Neo4j according to Neo4j Node ID. Big data elements that may be associated with this node are not removed.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.resetentireremotesession","page":"Caesar's Reference","title":"Caesar.resetentireremotesession","text":"resetentireremotesession(conn, session, robot, user)\n\nmatch (n:session) remove n.backendset, n.ready, n.data, n.bigData, n.label, n.packedType, n.exVertexId, n.shape, n.width set n :NEWDATA return n\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.rmInstMultisessionPriors!","page":"Caesar's Reference","title":"Caesar.rmInstMultisessionPriors!","text":"rmInstMultisessionPriors!(::CloudGraph; session<:AbstractString=, multisessions::Vector{<:AbstractString}= )\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.standardcloudgraphsetup","page":"Caesar's Reference","title":"Caesar.standardcloudgraphsetup","text":"standardcloudgraphsetup(; addrdict, nparticles, drawdepth, drawedges, clearslamindb, multisession) -> Tuple{CloudGraphs.CloudGraph,Dict{AbstractString,Any}}\n\n\nConnect to databases via network according to addrdict, or ask user for credentials and return active cloudGraph object, as well as addrdict.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.updatenewverts!","page":"Caesar's Reference","title":"Caesar.updatenewverts!","text":"updatenewverts!(fgl::FactorGraph; N::Int)\n\nConvert vertices of session in Neo4j DB with Caesar.jl's required data elements in preparation for MM-iSAMCloudSolve process.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.whosNear2D","page":"Caesar's Reference","title":"Caesar.whosNear2D","text":"whosNear2D(cg::CloudGraphs.CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString; x, y, yaw, dist, angle)\n\n\nFind vertices near the point specified and return dictionary of symbol to Neo4j ID pairs.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#Caesar.whosNear3D","page":"Caesar's Reference","title":"Caesar.whosNear3D","text":"whosNear3D(cg::CloudGraphs.CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString; x, y, z, roll, pitch, yaw, dist, angle)\n\n\nFind vertices near the point specified and return dictionary of symbol to Neo4j ID pairs.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#RoME-1","page":"Caesar's Reference","title":"RoME","text":"","category":"section"},{"location":"func_ref/#","page":"Caesar's Reference","title":"Caesar's Reference","text":"getRangeKDEMax2D\ninitFactorGraph!\naddOdoFG!","category":"page"},{"location":"func_ref/#RoME.getRangeKDEMax2D","page":"Caesar's Reference","title":"RoME.getRangeKDEMax2D","text":"getRangeKDEMax2D(fgl, vsym1, vsym2)\n\n\nCalculate the cartesian distance between two vertices in the graph using their symbol name, and by maximum belief point.\n\n\n\n\n\ngetRangeKDEMax2D(cgl::CloudGraph, session::AbstractString, vsym1::Symbol, vsym2::Symbol)\n\nCalculate the cartesian distange between two vertices in the graph, by session and symbol names, and by maximum belief point.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#RoME.initFactorGraph!","page":"Caesar's Reference","title":"RoME.initFactorGraph!","text":"initFactorGraph!(fg; P0, init, N, lbl, ready, firstPoseType, labels)\n\n\nInitialize a factor graph object as Pose2, Pose3, or neither and returns variable and factor symbols as array.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#RoME.addOdoFG!","page":"Caesar's Reference","title":"RoME.addOdoFG!","text":"addOdoFG!(fg, n, DX, cov; N, ready, labels)\n\n\nCreate a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x<k+1> for new node new node and constraint factor are returned as a tuple.\n\n\n\n\n\naddOdoFG!(fgl, odo; N, ready, labels)\n\n\nCreate a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x<k+1> for new node new node and constraint factor are returned as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference-1","page":"Caesar's Reference","title":"IncrementalInference","text":"","category":"section"},{"location":"func_ref/#","page":"Caesar's Reference","title":"Caesar's Reference","text":"addVariable!\naddFactor!\nallnums\napproxCliqMarginalUp!\napproxConv\nbatchSolve!\nchildCliqs\ncliqGibbs\nconvert2packedfunctionnode\ndecodefg\ndeleteFactor!\ndeleteVariable!\ndoautoinit!\ndownMsgPassingRecursive\ndwnMsg\nencodefg\nfifoFreeze!\nfindRelatedFromPotential\nfmcmc!\ngetCurrentWorkspaceFactors\ngetCurrentWorkspaceVariables\ngetCliq\ngetData\ngetFactor\ngetKDE\ngetParent\ngetSofttype\ngetVal\ngetVariable\ngetVertKDE\ngetUpMsgs\ngetDwnMsgs\ninitfg\nlandmarks\nloadjld\nlocalProduct\nls\nlsf\nlsRear\nmanualinit!\nparentCliq\npackFromLocalPotentials!\nprintgraphmax\nproductpartials!\nprodmultiplefullpartials\nprodmultipleonefullpartials\nsavejld\nsetDwnMsg!\nsetfreeze!\nsetUpMsg!\nsubgraphFromVerts\ntreeProductDwn\ntreeProductUp\nupdateFGBT!\nupGibbsCliqueDensity\nupMsg\nwriteGraphPdf\nshowFactor","category":"page"},{"location":"func_ref/#IncrementalInference.addVariable!","page":"Caesar's Reference","title":"IncrementalInference.addVariable!","text":"addVariable!(fg, lbl, softtype; N, autoinit, ready, dontmargin, labels, api, uid, smalldata, checkduplicates)\n\n\nAdd a variable node lbl::Symbol to fg::FactorGraph, as softtype<:InferenceVariable.\n\nExample\n\nfg = initfg()\naddVariable!(fg, :x0, Pose2)\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.addFactor!","page":"Caesar's Reference","title":"IncrementalInference.addFactor!","text":"addFactor!(fgl, Xi, usrfnc; multihypo, ready, api, labels, uid, autoinit, threadmodel)\n\n\nAdd factor with user defined type <: FunctorInferenceType to the factor graph object.  Define whether the automatic initialization of variables should be performed.  Use order sensitive multihypo keyword argument to define if any variables are related to data association uncertainty.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.allnums","page":"Caesar's Reference","title":"IncrementalInference.allnums","text":"Test if all elements of the string is a number:  Ex, \"123\" is true, \"1_2\" is false.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.approxCliqMarginalUp!","page":"Caesar's Reference","title":"IncrementalInference.approxCliqMarginalUp!","text":"approxCliqMarginalUp!(fgl, treel, csym)\napproxCliqMarginalUp!(fgl, treel, csym, onduplicate; N, dbg, iters, drawpdf)\n\n\nApproximate Chapman-Kolmogorov transit integral and return separator marginals as messages to pass up the Bayes (Junction) tree, along with additional clique operation values for debugging.\n\nNotes\n\nonduplicate=true by default internally uses deepcopy of factor graph and Bayes tree, and does not update the given objects.  Set false to update fgl and treel during compute.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.approxConv","page":"Caesar's Reference","title":"IncrementalInference.approxConv","text":"approxConv(fgl, fct, towards; api, N)\n\n\nDraw samples from the approximate convolution of towards symbol using factor fct relative to the other variables.  In addition the api can be adjusted to recover the data from elsewhere (likely to be replaced/removed in the future).\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.batchSolve!","page":"Caesar's Reference","title":"IncrementalInference.batchSolve!","text":"batchSolve!(fgl; drawpdf, show, N, recursive, dbg)\n\n\nPerform multimodal incremental smoothing and mapping (mm-iSAM) computations over given factor graph fgl::FactorGraph on the local computer.  A pdf of the Bayes (Junction) tree will be generated in the working folder with drawpdf=true\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.childCliqs","page":"Caesar's Reference","title":"IncrementalInference.childCliqs","text":"childCliqs(treel, cliq)\n\n\nReturn a vector of child cliques to cliq.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.cliqGibbs","page":"Caesar's Reference","title":"IncrementalInference.cliqGibbs","text":"cliqGibbs(fg, cliq, vertid, inmsgs, N, dbg, manis)\n\n\nPerform one step of the minibatch clique Gibbs operation for solving the Chapman-Kolmogov trasit integral – here involving separate approximate functional convolution and product operations.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.convert2packedfunctionnode","page":"Caesar's Reference","title":"IncrementalInference.convert2packedfunctionnode","text":"convert2packedfunctionnode(fgl, fsym)\nconvert2packedfunctionnode(fgl, fsym, api)\n\n\nEncode complicated function node type to related 'Packed<type>' format assuming a user supplied convert function .\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.decodefg","page":"Caesar's Reference","title":"IncrementalInference.decodefg","text":"decodefg(fgs; api)\n\n\nUnpack PackedFunctionNodeData formats back to regular FunctonNodeData.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.deleteFactor!","page":"Caesar's Reference","title":"IncrementalInference.deleteFactor!","text":"deleteFactor!(fgl, fsym)\n\n\nDelete factor and its edges.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.deleteVariable!","page":"Caesar's Reference","title":"IncrementalInference.deleteVariable!","text":"deleteVariable!(fgl, vsym; andfactors)\n\n\nDelete variables, and also the factors+edges if andfactors=true (default).\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.doautoinit!","page":"Caesar's Reference","title":"IncrementalInference.doautoinit!","text":"doautoinit!(fgl, Xi; api, singles, N)\n\n\nEXPERIMENTAL: initialize destination variable nodes based on this factor in factor graph, fg, generally called during addFactor!. Destination factor is first (singletons) or second (dim 2 pairwise) variable vertex in Xi.\n\n\n\n\n\ndoautoinit!(fgl, xsyms; api, singles, N)\n\n\nInitialize destination variable nodes based on this factor in factor graph, fg, generally called during addFactor!.  Destination factor is first (singletons) or second (dim 2 pairwise) variable vertex in Xi.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.downMsgPassingRecursive","page":"Caesar's Reference","title":"IncrementalInference.downMsgPassingRecursive","text":"Pass NBPMessages back down the tree – pre order tree traversal.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.dwnMsg","page":"Caesar's Reference","title":"IncrementalInference.dwnMsg","text":"dwnMsg(cliq)\n\n\nReturn the last down message stored in cliq of Bayes (Junction) tree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.encodefg","page":"Caesar's Reference","title":"IncrementalInference.encodefg","text":"encodefg(fgl; api)\n\n\nMake a full memory copy of the graph and encode all composite function node types – assuming that convert methods for 'Packed<type>' formats exist.  The same converters are used for database persistence with CloudGraphs.jl.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.fifoFreeze!","page":"Caesar's Reference","title":"IncrementalInference.fifoFreeze!","text":"fifoFreeze!(fgl)\n\n\nFreeze nodes that are older than the quasi fixed-lag length defined by fg.qfl, according to fg.fifo ordering.\n\nFuture:\n\nAllow different freezing strategies beyond fifo.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.findRelatedFromPotential","page":"Caesar's Reference","title":"IncrementalInference.findRelatedFromPotential","text":"findRelatedFromPotential(fg, idfct, vertid, N)\nfindRelatedFromPotential(fg, idfct, vertid, N, dbg; api)\n\n\nCompute proposal belief on vertid through idfct representing some constraint in factor graph. Always full dimension variable node – partial constraints will only influence subset of variable dimensions. The remaining dimensions will keep pre-existing variable values.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.fmcmc!","page":"Caesar's Reference","title":"IncrementalInference.fmcmc!","text":"fmcmc!(fgl, cliq, fmsgs, IDs, N, MCMCIter)\nfmcmc!(fgl, cliq, fmsgs, IDs, N, MCMCIter, dbg)\nfmcmc!(fgl, cliq, fmsgs, IDs, N, MCMCIter, dbg, api)\n\n\nIterate successive approximations of clique marginal beliefs by means of the stipulated proposal convolutions and products of the functional objects for tree clique cliq.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCurrentWorkspaceFactors","page":"Caesar's Reference","title":"IncrementalInference.getCurrentWorkspaceFactors","text":"getCurrentWorkspaceFactors()\n\n\nReturn all factors currently registered in the workspace.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCurrentWorkspaceVariables","page":"Caesar's Reference","title":"IncrementalInference.getCurrentWorkspaceVariables","text":"getCurrentWorkspaceVariables()\n\n\nReturn all variables currently registered in the workspace.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getCliq","page":"Caesar's Reference","title":"IncrementalInference.getCliq","text":"getCliq(bt, frt)\n\n\nReturn the Graphs.ExVertex node object that represents a clique in the Bayes (Junction) tree, as defined by one of the frontal variables frt.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getData","page":"Caesar's Reference","title":"IncrementalInference.getData","text":"getData(v)\n\n\nRetrieve data structure stored in a node.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getFactor","page":"Caesar's Reference","title":"IncrementalInference.getFactor","text":"getFactor(fvert)\n\n\nReturn reference to the user factor in ::FactorGraph identified by ::Symbol.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getKDE","page":"Caesar's Reference","title":"IncrementalInference.getKDE","text":"getKDE(v)\n\n\nGet KernelDensityEstimate kde estimate stored in variable node.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getParent","page":"Caesar's Reference","title":"IncrementalInference.getParent","text":"getParent(treel, afrontal)\n\n\nReturn cliq's parent clique.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getSofttype","page":"Caesar's Reference","title":"IncrementalInference.getSofttype","text":"getSofttype(vnd)\n\n\nVariable nodes softtype information holding a variety of meta data associated with the type of variable stored in that node of the factor graph.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getVal","page":"Caesar's Reference","title":"IncrementalInference.getVal","text":"getVal(vnd)\n\n\nConvenience function to get point values sampled i.i.d from marginal of lbl variable in the current factor graph.\n\n\n\n\n\ngetVal(vA)\n\n\nFetch the variable marginal sample points without the KDE bandwidth parameter.  Use getVertKDE to retrieve the full KDE object.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getVariable","page":"Caesar's Reference","title":"IncrementalInference.getVariable","text":"getVariable(fgl, lbl)\ngetVariable(fgl, lbl, api)\n\n\nReturn reference to a variable in ::FactorGraph identified by ::Symbol.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getVertKDE","page":"Caesar's Reference","title":"IncrementalInference.getVertKDE","text":"getVertKDE(v)\n\n\nGet KernelDensityEstimate kde estimate stored in variable node.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getUpMsgs","page":"Caesar's Reference","title":"IncrementalInference.getUpMsgs","text":"getUpMsgs(btl, sym)\n\n\nReturn the last up message stored in cliq of Bayes (Junction) tree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.getDwnMsgs","page":"Caesar's Reference","title":"IncrementalInference.getDwnMsgs","text":"getDwnMsgs(btl, sym)\n\n\nReturn the last down message stored in cliq of Bayes (Junction) tree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.initfg","page":"Caesar's Reference","title":"IncrementalInference.initfg","text":"Initialize an empty ::FactorGraph object while initializing sessionname, robotname, and cloudgraph.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.landmarks","page":"Caesar's Reference","title":"IncrementalInference.landmarks","text":"landmarks(fgl::FactorGraph, vsym::Symbol)\n\nReturn Vector{Symbol} of landmarks attached to vertex vsym in fgl.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.loadjld","page":"Caesar's Reference","title":"IncrementalInference.loadjld","text":"loadjld(; file)\n\n\nOpposite of savejld(fg, gt=gt, file=\"tempfg.jl\") to load data from file. This function uses the unpacking converters for converting all PackedInferenceType to FunctorInferenceType.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.localProduct","page":"Caesar's Reference","title":"IncrementalInference.localProduct","text":"localProduct(fgl, sym; N, dbg, api)\n\n\nUsing factor graph object fg, project belief through connected factors (convolution with conditional) to variable sym followed by a approximate functional product.\n\nReturn: product belief, full proposals, partial dimension proposals, labels\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.ls","page":"Caesar's Reference","title":"IncrementalInference.ls","text":"ls(fgl, lbl; api, ring)\n\n\nReturn all elements ls(fg) as tuples, or nodes connected to the a specific element, eg. `ls(fg, :x1)\n\n\n\n\n\nls(fgl, lbls; api, ring)\n\n\nExperimental union of elements version of ls(::FactorGraph, ::Symbol).  Not mean't to replace broadcasting ls.(fg, [:x1;:x2])\n\n\n\n\n\nls(fgl; key1, key2)\n\n\nList the nodes in a factor graph.\n\nExamples\n\nls(fg)\n\n\n\n\n\nls(cgl::CloudGraphs.CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString; sym, neoid, exvid) -> Dict{Symbol,Tuple{Int64,Int64,Array{Symbol,1}}}\n\n\nList neighbors to node in cgl::CloudGraph by returning Dict{Sym}=(exvid, neoid, Symbol[labels]), and can take any of the three as input node identifier. Not specifying an identifier will result in all Variable nodes being returned.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.lsf","page":"Caesar's Reference","title":"IncrementalInference.lsf","text":"lsf(fgl, lbl; api)\n\n\nList factors in a factor graph.\n\nExamples\n\nlsf(fg)\n\n\n\n\n\nlsf(fgl, lbl)\n\n\nList factors in a factor graph.\n\nExamples\n\nlsf(fg)\n\n\n\n\n\nlsf(fgl, mt; api)\n\n\nList factors in a factor graph.\n\nExamples\n\nlsf(fg)\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.lsRear","page":"Caesar's Reference","title":"IncrementalInference.lsRear","text":"lsRear(fgl)\nlsRear(fgl, n)\n\n\nReturn array of all variable nodes connected to the last n many poses (:x*).\n\nExample:\n\n# Shallow copy the tail end of poses from a factor graph `fg1`\nvars = lsRear(fg1, 5)\nfg1_r5 = subgraphFromVerts(fg1, vars)\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.manualinit!","page":"Caesar's Reference","title":"IncrementalInference.manualinit!","text":"manualinit!(fgl, vert, pX)\n\n\nWorkaround function when first-version (factor graph based) auto initialization fails.  Usually occurs when using factors that have high connectivity to multiple variables.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.parentCliq","page":"Caesar's Reference","title":"IncrementalInference.parentCliq","text":"parentCliq(treel, cliq)\n\n\nReturn cliq's parent clique.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.packFromLocalPotentials!","page":"Caesar's Reference","title":"IncrementalInference.packFromLocalPotentials!","text":"packFromLocalPotentials!(fgl, dens, wfac, cliq, vertid, N)\npackFromLocalPotentials!(fgl, dens, wfac, cliq, vertid, N, dbg)\n\n\nAdd all potentials associated with this clique and vertid to dens.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.printgraphmax","page":"Caesar's Reference","title":"IncrementalInference.printgraphmax","text":"printgraphmax(fgl)\n\n\nPrint the maximum point values form all variables approximate marginals in the factor graph. The full marginal can be recovered for example X0 = getVertKDE(fg, :x0).\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.productpartials!","page":"Caesar's Reference","title":"IncrementalInference.productpartials!","text":"productpartials!(pGM, dummy, partials, manis)\n\n\nMultiply different dimensions from partial constraints individually.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.prodmultiplefullpartials","page":"Caesar's Reference","title":"IncrementalInference.prodmultiplefullpartials","text":"prodmultiplefullpartials(dens, partials, Ndims, N, manis)\n\n\nMultiply various full and partial dimension constraints.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.prodmultipleonefullpartials","page":"Caesar's Reference","title":"IncrementalInference.prodmultipleonefullpartials","text":"Multiply a single full and several partial dimension constraints.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.savejld","page":"Caesar's Reference","title":"IncrementalInference.savejld","text":"savejld(fgl; file, groundtruth)\n\n\nSave mostly complete Factor Graph type by converting complicated FunctionNodeData types to 'Packed' types using user supplied converters. Ground truth can also be saved and recovered by the associated loadjld(file=\"tempfg.jld2\") method.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setDwnMsg!","page":"Caesar's Reference","title":"IncrementalInference.setDwnMsg!","text":"setDwnMsg!(cliql, msgs)\n\n\nSet the downward passing message for Bayes (Junction) tree clique cliql.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setfreeze!","page":"Caesar's Reference","title":"IncrementalInference.setfreeze!","text":"setfreeze!(fgl, sym)\n\n\nSet variable(s) sym of factor graph to be marginalized – i.e. not be updated by inference computation.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.setUpMsg!","page":"Caesar's Reference","title":"IncrementalInference.setUpMsg!","text":"setUpMsg!(cliql, msgs)\n\n\nSet the upward passing message for Bayes (Junction) tree clique cliql.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.treeProductDwn","page":"Caesar's Reference","title":"IncrementalInference.treeProductDwn","text":"treeProductDwn(fg, tree, cliq, sym; N, dbg)\n\n\nCalculate a fresh–-single step–-approximation to the variable sym in clique cliq as though during the downward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variable based on the structure of variables, factors, and incoming messages to this clique. Which clique to be used is defined by frontal variable symbols (cliq in this case) – see whichCliq(...) for more details.  The sym symbol indicates which symbol of this clique to be calculated.  Note that the sym variable must appear in the clique where cliq is a frontal variable.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.treeProductUp","page":"Caesar's Reference","title":"IncrementalInference.treeProductUp","text":"treeProductUp(fg, tree, cliq, sym; N, dbg)\n\n\nCalculate a fresh (single step) approximation to the variable sym in clique cliq as though during the upward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variables based on the structure of the clique, factors, and incoming messages. Which clique to be used is defined by frontal variable symbols (cliq in this case) – see whichCliq(...) for more details.  The sym symbol indicates which symbol of this clique to be calculated.  Note that the sym variable must appear in the clique where cliq is a frontal variable.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.updateFGBT!","page":"Caesar's Reference","title":"IncrementalInference.updateFGBT!","text":"updateFGBT!(fg, bt, cliqID, ddt; dbg, fillcolor)\n\n\nUpdate cliq cliqID in Bayes (Juction) tree bt according to contents of ddt – intended use is to update main clique after a downward belief propagation computation has been completed per clique.\n\n\n\n\n\nupdateFGBT!(fg, bt, cliqID, urt; dbg, fillcolor)\n\n\nUpdate cliq cliqID in Bayes (Juction) tree bt according to contents of urt – intended use is to update main clique after a upward belief propagation computation has been completed per clique.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.upGibbsCliqueDensity","page":"Caesar's Reference","title":"IncrementalInference.upGibbsCliqueDensity","text":"upGibbsCliqueDensity(inp)\nupGibbsCliqueDensity(inp, N)\nupGibbsCliqueDensity(inp, N, dbg)\nupGibbsCliqueDensity(inp, N, dbg, iters)\n\n\nPerform computations required for the upward message passing during belief propation on the Bayes (Junction) tree. This function is usually called as part via remote_call for multiprocess dispatch.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.upMsg","page":"Caesar's Reference","title":"IncrementalInference.upMsg","text":"upMsg(cliq)\n\n\nReturn the last up message stored in cliq of Bayes (Junction) tree.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.writeGraphPdf","page":"Caesar's Reference","title":"IncrementalInference.writeGraphPdf","text":"writeGraphPdf(fgl; viewerapp, filepath, engine, show)\n\n\nExport a dot and pdf file drawn by Graphviz showing the factor graph.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#IncrementalInference.showFactor","page":"Caesar's Reference","title":"IncrementalInference.showFactor","text":"showFactor(fgl, fsym; api)\n\n\nDisplay and return to console the user factor identified by tag name.\n\n\n\n\n\n","category":"function"},{"location":"func_ref/#","page":"Caesar's Reference","title":"Caesar's Reference","text":"<!– IIF v0.5.3 –> <!– showVariable –>","category":"page"},{"location":"vis_func_ref/#Visualization-Function-Reference-1","page":"Visualization Reference","title":"Visualization Function Reference","text":"","category":"section"},{"location":"vis_func_ref/#","page":"Visualization Reference","title":"Visualization Reference","text":"Pages = [\n    \"vis_func_ref.md\"\n]\nDepth = 3","category":"page"},{"location":"vis_func_ref/#RoMEPlotting-1","page":"Visualization Reference","title":"RoMEPlotting","text":"","category":"section"},{"location":"vis_func_ref/#","page":"Visualization Reference","title":"Visualization Reference","text":"drawLandms\ndrawPoses\ndrawPosesLandms\nplotKDE\nplotPose\nplotProductVsKDE","category":"page"},{"location":"vis_func_ref/#RoMEPlotting.drawLandms","page":"Visualization Reference","title":"RoMEPlotting.drawLandms","text":"drawLandms(fg; from, to, minnei, meanmax, lbls, showmm, drawhist, c, MM, api)\n\n\n2D plot of landmarks, assuming :l1, :l2, ... :ln.  Use from and to to control the range of landmarks n to include.\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#RoMEPlotting.drawPoses","page":"Visualization Reference","title":"RoMEPlotting.drawPoses","text":"drawPoses(fg; from, to, meanmax, lbls, drawhist, spscale, api)\n\n\n2D plot of all poses, assuming poses are labeled from `::Symbol type :x0, :x1, ..., :xn.  Use to and from to limit the range of numbers n to be drawn.  The underlying histogram can be enabled or disabled, and the size of maximum-point belief estimate cursors can be controlled with spscale.\n\nFuture:\n\nRelax to user defined pose labeling scheme, for example :p1, :p2, ...\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#RoMEPlotting.drawPosesLandms","page":"Visualization Reference","title":"RoMEPlotting.drawPosesLandms","text":"drawPosesLandms(fgl; from, to, minnei, meanmax, lbls, drawhist, MM, showmm, spscale, window, api, xmin, xmax, ymin, ymax)\n\n\n2D plot of both poses and landmarks contained in factor graph.  Assuming poses and landmarks are labeled :x1, :x2, ... and :l0, :l1, ..., respectively.  The rnage of numbers to include can be controlled with from and to along with other keyword functionality for manipulating the plot.\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#KernelDensityEstimatePlotting.plotKDE","page":"Visualization Reference","title":"KernelDensityEstimatePlotting.plotKDE","text":"plotKDE(fgl, sym; axis, dims, c, levels, title)\n\n\nA peneric KDE plotting function that allows marginals of higher dimensional beliefs and various keyword options.\n\nExample:\n\np = kde!(randn(3,100))\n\nplotKDE(p)\nplotKDE(p, dims=[1;2], levels=3)\nplotKDE(p, dims=[1])\n\nq = kde!(5*randn(3,100))\nplotKDE([p;q])\nplotKDE([p;q], dims=[1;2], levels=3)\nplotKDE([p;q], dims=[1])\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#RoMEPlotting.plotPose","page":"Visualization Reference","title":"RoMEPlotting.plotPose","text":"plotPose(fgl, syms; levels, c, axis, show, filepath, app)\n\n\nExample: pl = plotPose(fg, [:x1; :x2; :x3])\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#RoMEPlotting.plotProductVsKDE","page":"Visualization Reference","title":"RoMEPlotting.plotProductVsKDE","text":"plotProductVsKDE(fgl, sym; levels, c)\n\n\nAnalysis function to compare KDE plots between the factor graph centric product of a variable with current value stored in the factor graph object.\n\n\n\n\n\n","category":"function"},{"location":"vis_func_ref/#","page":"Visualization Reference","title":"Visualization Reference","text":"WORK IN PROGRESS  Not all functions have been added to this directory yet.","category":"page"}]
}
