<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Under-defined Trilateration, 2D · Caesar.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Caesar.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Welcome</span><ul><li><a class="tocitem" href="../../installation_environment/">Installation</a></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../concepts/concepts/">Initial Concepts</a></li><li><a class="tocitem" href="../../concepts/building_graphs/">Building Factor Graphs</a></li><li><a class="tocitem" href="../../concepts/interacting_fgs/">Interacting w/ Factor Graphs</a></li><li><a class="tocitem" href="../../concepts/dataassociation/">Data Association</a></li><li><a class="tocitem" href="../../concepts/available_varfacs/">Available Variables/Factors</a></li><li><a class="tocitem" href="../../concepts/2d_plotting/">Plotting (2D)</a></li><li><a class="tocitem" href="../../concepts/multilang/">Multi-Language Support</a></li><li><a class="tocitem" href="../../concepts/database_interactions/">Cloud Server/Database</a></li><li><a class="tocitem" href="../../concepts/multisession/">Multi-session/agent Solving</a></li><li><a class="tocitem" href="../../concepts/arena_visualizations/">Visualization (3D)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/">Caesar Examples</a></li><li><a class="tocitem" href="../basic_continuousscalar/">ContinuousScalar as 1D Example</a></li><li class="is-active"><a class="tocitem" href>Under-defined Trilateration, 2D</a><ul class="internal"><li><a class="tocitem" href="#Quick-Install"><span>Quick Install</span></a></li><li><a class="tocitem" href="#Loading-The-Data"><span>Loading The Data</span></a></li><li><a class="tocitem" href="#Creating-the-Factor-Graph-with-Point2"><span>Creating the Factor Graph with <code>Point2</code></span></a></li><li><a class="tocitem" href="#Adding-Range-Measurements-Between-Variables"><span>Adding Range Measurements Between Variables</span></a></li><li><a class="tocitem" href="#Inference-and-Visualizations"><span>Inference and Visualizations</span></a></li><li><a class="tocitem" href="#Implicit-Growth-and-Decay-of-Modes-(i.e.-Hypotheses)"><span>Implicit Growth and Decay of Modes (i.e. Hypotheses)</span></a></li></ul></li><li><a class="tocitem" href="../basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="tocitem" href="../interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li><li><a class="tocitem" href="../deadreckontether/">Dead Reckon Tether</a></li></ul></li><li><span class="tocitem">Principles</span><ul><li><a class="tocitem" href="../../principles/filterCorrespondence/">Filters vs. Graphs</a></li><li><a class="tocitem" href="../../principles/approxConvDensities/">Generic Convolutions</a></li><li><a class="tocitem" href="../../principles/multiplyingDensities/">Multiplying Functions (.py)</a></li><li><a class="tocitem" href="../../principles/bayestreePrinciples/">Bayes (Junction) tree</a></li><li><a class="tocitem" href="../../principles/initializingOnBayesTree/">Advanced Bayes Tree Topics</a></li><li><a class="tocitem" href="../../concepts/mmisam_alg/">Multimodal iSAM Algorithm</a></li></ul></li><li><span class="tocitem">How to Expand?</span><ul><li><a class="tocitem" href="../../concepts/adding_variables_factors/">Custom Variables and Factors</a></li><li><a class="tocitem" href="../basic_definingfactors/">Creating Variables and Factors</a></li><li><a class="tocitem" href="../interm_dynpose/">Creating DynPose Factor</a></li></ul></li><li><span class="tocitem">Developer Zone</span><ul><li><a class="tocitem" href="../../dev/wiki/">Wiki Pointers</a></li></ul></li><li><span class="tocitem">Literature</span><ul><li><a class="tocitem" href="../../refs/literature/">References</a></li></ul></li><li><span class="tocitem">Function Reference</span><ul><li><a class="tocitem" href="../../func_ref/">Caesar&#39;s Reference</a></li><li><a class="tocitem" href="../../vis_func_ref/">Visualization Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Under-defined Trilateration, 2D</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Under-defined Trilateration, 2D</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/examples/basic_slamedonut.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Range-only-SLAM,-Singular-–-i.e.-&quot;Under-Constrained&quot;"><a class="docs-heading-anchor" href="#Range-only-SLAM,-Singular-–-i.e.-&quot;Under-Constrained&quot;">Range only SLAM, Singular – i.e. &quot;Under-Constrained&quot;</a><a id="Range-only-SLAM,-Singular-–-i.e.-&quot;Under-Constrained&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#Range-only-SLAM,-Singular-–-i.e.-&quot;Under-Constrained&quot;" title="Permalink"></a></h1><p>This tutorial describes a range-only system where there are always more variable dimensions than range measurements made. The error distribution over ranges could be nearly anything, but are restricted to Gaussian-only in this example to illustrate an alternative point – other examples show inference results where highly non-Gaussian error distributions are used. A file version of this example is provided in <a href="https://github.com/JuliaRobotics/RoME.jl/blob/master/examples/RangesExample.jl">RoME/examples here</a>. The one pre-baked result of this of this singular range-only illustration can be seen in this video:  Multi-modal range only example (<a href="http://vimeo.com/190052649">click here or image for full Vimeo</a>),</p><a href="http://vimeo.com/190052649" target="_blank"><img src="https://raw.githubusercontent.com/JuliaRobotics/IncrementalInference.jl/master/doc/images/mmisamvid01.gif" alt="IMAGE ALT TEXT HERE" width="640" border="0" /></a><p>This example is also available as a script <a href="https://github.com/JuliaRobotics/RoME.jl/blob/master/examples/RangesExample.jl">here in RoME.jl</a>.</p><h2 id="Quick-Install"><a class="docs-heading-anchor" href="#Quick-Install">Quick Install</a><a id="Quick-Install-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Install" title="Permalink"></a></h2><p>If you already have Julia 1.0 or above, alternatively see <a href="http://www.juliarobotics.org/Caesar.jl/latest/installation_environment/">complete installation instructions here</a>:</p><pre><code class="language-julia">julia&gt; ]
(v1.0) pkg&gt; add RoME, Distributed
(v1.0) pkg&gt; add RoMEPlotting</code></pre><p>The Julia REPL/console is sufficient for this example (copy-paste from this page).  Note that more involved work in Julia is simplified by using the Juno IDE.</p><blockquote><p><strong>Note</strong> A recent test (May 2019, IIF v0.6.0) showed a possible bug was introduced with one of the solver upgrades.  THe figures shown on this example page are still, however, valid.  Previous versions of the solver, such as IncrementalInference v0.4.x and v0.5.x, should still work as expected.  Follow progress on <a href="https://github.com/JuliaRobotics/Caesar.jl/issues/335">issue 335 here</a> as bug is being resolved.  Previous versions of the solver can be installed with the package manager, for example: <code>(v1.0) pkg&gt; add IncrementalInference@v0.5.7</code>.  Please comment for further details.</p></blockquote><h2 id="Loading-The-Data"><a class="docs-heading-anchor" href="#Loading-The-Data">Loading The Data</a><a id="Loading-The-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-The-Data" title="Permalink"></a></h2><p>Starting a Juno IDE or Julia REPL session, the ground truth positions for vehicle positions <code>GTp</code> and landmark positions <code>GTl</code> can be loaded into memory directly with these values:</p><pre><code class="language-julia">GTp = Dict{Symbol, Vector{Float64}}()
GTp[:l100] = [0.0;0]
GTp[:l101] = [50.0;0]
GTp[:l102] = [100.0;0]
GTp[:l103] = [100.0;50.0]
GTp[:l104] = [100.0;100.0]
GTp[:l105] = [50.0;100.0]
GTp[:l106] = [0.0;100.0]
GTp[:l107] = [0.0;50.0]
GTp[:l108] = [0.0;-50.0]
GTp[:l109] = [0.0;-100.0]
GTp[:l110] = [50.0;-100.0]
GTp[:l111] = [100.0;-100.0]
GTp[:l112] = [100.0;-50.0]

GTl = Dict{Symbol, Vector{Float64}}()
GTl[:l1] = [10.0;30]
GTl[:l2] = [30.0;-30]
GTl[:l3] = [80.0;40]
GTl[:l4] = [120.0;-50]</code></pre><p><strong>NOTE 1.</strong> that by using location indicators <code>:l1, :l2, ...</code> or <code>:l100, :l101, ...</code> is of practical benefit when visualizing with existing <a href="https://github.com/JuliaRobotics/RoMEPlotting.jl">RoMEPlotting</a> functions.</p><p><strong>NOTE 2.</strong> Landmarks must be in range before range measurements can be made to them.</p><h2 id="Creating-the-Factor-Graph-with-Point2"><a class="docs-heading-anchor" href="#Creating-the-Factor-Graph-with-Point2">Creating the Factor Graph with <code>Point2</code></a><a id="Creating-the-Factor-Graph-with-Point2-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-Factor-Graph-with-Point2" title="Permalink"></a></h2><p>The first step is to load the required modules, and in our case we will add a few Julia processes to help with the compute later on.  </p><pre><code class="language-julia"># add more julia processes
using Distributed
nprocs() &lt; 4 ? addprocs(4-nprocs()) : nothing

# tell Julia that you want to use these modules/namespaces
using RoME</code></pre><p><strong>NOTE</strong> Julia uses just-in-time compiling (<a href="https://stackoverflow.com/questions/40116045/why-is-julia-taking-a-long-time-on-the-first-call-into-my-module">unless pre-compiled</a>), therefore each time a new function call on a Julia process will be slow, but all following calls to the same functions will be as fast as the statically compiled code.</p><p>This example exclusively uses <code>Point2</code> variable node types, which have dimension <code>2</code> and represent <code>[x, y]</code> position estimates in the world frame.</p><p>Next construct the factor graph containing the first pose <code>:l100</code> (without any knowledge of where it is) and three measured beacons/landmarks <code>:l1,:l2,:l3</code> – with prior location knowledge for <code>:l1</code> and <code>:l2</code>:</p><pre><code class="language-julia"># create the factor graph object
fg = initfg()

# first pose with no initial estimate
addVariable!(fg, :l100, Point2)

# add three landmarks
addVariable!(fg, :l1, Point2)
addVariable!(fg, :l2, Point2)
addVariable!(fg, :l3, Point2)

# and put priors on :l101 and :l102
addFactor!(fg, [:l1;], PriorPoint2(MvNormal(GTl[:l1], Matrix{Float64}(LinearAlgebra.I,2,2))) )
addFactor!(fg, [:l2;], PriorPoint2(MvNormal(GTl[:l2], Matrix{Float64}(LinearAlgebra.I,2,2))) )</code></pre><p>The <code>PriorPoint2</code> is assumed to be a multivariate normal distribution of covariance <code>Matrix(LinearAlgebra.I,2,2)</code>, as well as a weighting factor of <code>[1.0]</code>.</p><p><strong>NOTE</strong> API changed to <code>PriorPoint2(::T) where T &lt;: SamplableBelief = PriorPoint2{T}</code> to accept distribution objects and discard (standard in <code>RoME v0.1.5</code> – see <a href="https://github.com/JuliaRobotics/RoME.jl/issues/72">issue 72 here</a>).</p><h2 id="Adding-Range-Measurements-Between-Variables"><a class="docs-heading-anchor" href="#Adding-Range-Measurements-Between-Variables">Adding Range Measurements Between Variables</a><a id="Adding-Range-Measurements-Between-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Range-Measurements-Between-Variables" title="Permalink"></a></h2><p>Next we connect the three range measurements from the vehicle location <code>:l0</code> to the three beacons, respectively – and consider that the range measurements are completely relative between the vehicle and beacon position estimates:</p><pre><code class="language-julia"># first range measurement
rhoZ1 = norm(GTl[:l1]-GTp[:l100])
ppr = Point2Point2Range( Normal(rhoZ1, 2.0) )
addFactor!(fg, [:l100;:l1], ppr)

# second range measurement
rhoZ2 = norm(GTl[:l2]-GTp[:l100])
ppr = Point2Point2Range( Normal(rhoZ2, 3.0) )
addFactor!(fg, [:l100; :l2], ppr)

# second range measurement
rhoZ3 = norm(GTl[:l3]-GTp[:l100])
ppr = Point2Point2Range( Normal(rhoZ3, 3.0) )
addFactor!(fg, [:l100; :l3], ppr)</code></pre><p>The ranging measurement standard deviation of <code>2.0</code> or <code>3.0</code> is taken, assuming a Gaussian measurement assumption.   Again, any distribution could have been used. The factor graph should look as follows:</p><pre><code class="language-julia">drawGraph(fg) # show the factor graph</code></pre><p><img src="https://user-images.githubusercontent.com/6412556/49518425-a1d44680-f86c-11e8-8548-c384bc6df2a6.png" alt="rangesonlyfirstfg"/></p><h2 id="Inference-and-Visualizations"><a class="docs-heading-anchor" href="#Inference-and-Visualizations">Inference and Visualizations</a><a id="Inference-and-Visualizations-1"></a><a class="docs-heading-anchor-permalink" href="#Inference-and-Visualizations" title="Permalink"></a></h2><p>At this point we can call the solver start interpreting the first results:</p><pre><code class="language-julia">tree, smt, hist = solveTree!(fg)</code></pre><p>The factor graph figure above showed the structure between variables and factors. In order to see the numerical values contained in the factor graph, a set of tools are provided by the <code>RoMEPlotting</code> and <code>KernelDensityEstimatePlotting</code> packages. For more details, please see the <a href="http://www.juliarobotics.org/Caesar.jl/latest/arena_visualizations.html">dedicated visualization discussion here</a>.</p><p>First look at the two landmark positions <code>:l1, :l2</code> at <code>(10.0,30)</code>,<code>(30.0,-30)</code> respectively.</p><pre><code class="language-julia">using RoMEPlotting

plotKDE(fg, [:l1;:l2], dims=[1;2])</code></pre><p><img src="https://user-images.githubusercontent.com/6412556/42423068-ca8690c2-82c1-11e8-8f9c-d5df13cca264.png" alt="testl1_2"/></p><p>Similarly, the belief estimate for the first vehicle position <code>:l100</code> is bi-modal, due to the intersection of two range measurements:</p><pre><code class="language-julia">plotKDE(fg, :l100, dims=[1;2], levels=6)</code></pre><p><img src="https://user-images.githubusercontent.com/6412556/42423069-d188212e-82c1-11e8-8af6-7b82f3f14030.png" alt="testl100"/></p><p>An alternative plotting interface can also be used, that shows a histogram of desired elements instead:</p><pre><code class="language-julia">drawLandms(fg, from=1, to=101, contour=false, drawhist=true)</code></pre><p><img src="https://user-images.githubusercontent.com/6412556/42423113-aec928d0-82c2-11e8-9852-c231d1e880fe.png" alt="testlall"/></p><p>Notice the ring of particles which represents the belief on the third beacon/landmark <code>:l3</code>, which was not constrained by a prior factor. Instead, the belief over the position of <code>:l3</code> is being estimated simultaneous to estimating the vehicle position <code>:l100</code>.</p><h2 id="Implicit-Growth-and-Decay-of-Modes-(i.e.-Hypotheses)"><a class="docs-heading-anchor" href="#Implicit-Growth-and-Decay-of-Modes-(i.e.-Hypotheses)">Implicit Growth and Decay of Modes (i.e. Hypotheses)</a><a id="Implicit-Growth-and-Decay-of-Modes-(i.e.-Hypotheses)-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-Growth-and-Decay-of-Modes-(i.e.-Hypotheses)" title="Permalink"></a></h2><p>Next consider the vehicle moving a distance of <code>50</code> units–-and by design the direction of travel is not known–-to the next true position. The video above gives away the vehicle position with the cyan line, showing travel in the shape of a lower case &#39;e&#39;. The following function handles (pseudo odometry) factors as range-only between positions and range-only measurement factors to beacons as the vehice travels.</p><pre><code class="language-julia">function vehicle_drives_to!(fgl::G, pos_sym::Symbol, GTp::Dict, GTl::Dict; measurelimit::R=150.0) where {G &lt;: AbstractDFG, R &lt;: Real}
  currvar = union(ls(fgl)...)
  prev_sym = Symbol(&quot;l$(maximum(Int[parse(Int,string(currvar[i])[2:end]) for i in 2:length(currvar)]))&quot;)
  if !(pos_sym in currvar)
    println(&quot;Adding variable vertex $pos_sym, not yet in fgl&lt;:AbstractDFG.&quot;)
    addVariable!(fgl, pos_sym, Point2)
    @show rho = norm(GTp[prev_sym] - GTp[pos_sym])
    ppr = Point2Point2Range( Normal(rho, 3.0) )
    addFactor!(fgl, [prev_sym;pos_sym], ppr)
  else
    @warn &quot;Variable node $pos_sym already in the factor graph.&quot;
  end
  beacons = keys(GTl)
  for ll in beacons
    rho = norm(GTl[ll] - GTp[pos_sym])
    # Check for feasible measurements:  vehicle within 150 units from the beacons/landmarks
    if rho &lt; measurelimit
      ppr = Point2Point2Range( Normal(rho, 3.0) )
      if !(ll in currvar)
        println(&quot;Adding variable vertex $ll, not yet in fgl&lt;:AbstractDFG.&quot;)
        addVariable!(fgl, ll, Point2)
      end
      addFactor!(fgl, [pos_sym;ll], ppr)
    end
  end
  nothing
end</code></pre><p>After pasting (or running) this function in Julia, a new member definition <code>vehicle_drives_to!</code> can be used line any other function.  Julia will handle the just-in-time compiling for the type specific function required and cach the static code for repeat executions.</p><blockquote><p><strong>NOTE</strong> The exclamation mark at the end of the function name has no syntactic significance in Julia, since the full UTF8 character set is available for functions or variables.  Instead, the exclamation serves as a Julia community convention to tell the caller that this function will modify the contents of at least some of the variables being passed into it – in this case the factor graph <code>fg</code> will be modified.</p></blockquote><p>Now the actual driving event can be added to the factor graph:</p><pre><code class="language-julia">#drive to location :l101, then :l102
vehicle_drives_to!(fg, :l101, GTp, GTl)
vehicle_drives_to!(fg, :l102, GTp, GTl)

# see the graph
drawGraph(fg, engine=&quot;neato&quot;)</code></pre><blockquote><p><strong>NOTE</strong> The distance traveled could be any combination of accrued direction and speeds, however, a straight line Gaussian error model is used to keep the visual presentation of this example as simple as possible.</p></blockquote><p>The marginal posterior estimates are found by repeating inference over the factor graph, followed drawing all vehicle locations as a contour map:</p><pre><code class="language-julia"># solve and show message passing on Bayes (Junction) tree
getSolverParams(fg).drawtree=true
getSolverParams(fg).showtree=true
tree, smt, hist = solveTree!(fg)

# draw all vehicle locations
pl = plotKDE(fg, [Symbol(&quot;l$(100+i)&quot;) for i in 0:2], dims=[1;2])
# Gadfly.draw(PDF(&quot;/tmp/testL100_102.pdf&quot;, 20cm, 10cm),pl) # for storing image to disk

pl = plotKDE(fg, [:l3;:l4], dims=[1;2], levels=4)
# Gadfly.draw(PNG(&quot;/tmp/testL3_4.png&quot;, 20cm, 10cm),pl)</code></pre><p>Notice how the vehicle positions have two hypotheses, one left to right and one diagonal right to bottom left – both are valid solutions!</p><p><img src="https://user-images.githubusercontent.com/6412556/42428772-722555b6-8303-11e8-9931-d3e2e89e3206.png" alt="testl100_102"/></p><p>The two &quot;free&quot; beacons/landmarks <code>:l3,:l4</code> still have several modes each, implying insufficient data to constrain either to a strong unimodal belief.</p><p><img src="https://user-images.githubusercontent.com/6412556/42428800-a5ac86f2-8303-11e8-984c-8952f7cdf839.png" alt="testl3_4"/></p><pre><code class="language-julia">
vehicle_drives_to!(fg, :l103, GTp, GTl)
vehicle_drives_to!(fg, :l104, GTp, GTl)

tree, smt, hist = solveTree!(fg)

pl = plotKDE(fg, [Symbol(&quot;l$(100+i)&quot;) for i in 0:4], dims=[1;2])
# Gadfly.draw(PDF(&quot;/tmp/testL100_104.pdf&quot;, 20cm, 10cm),pl)</code></pre><p>Moving up to position <code>:l104</code> still shows strong multiodality in the vehicle position estimates:</p><p><img src="https://user-images.githubusercontent.com/6412556/42428903-2f0b7e4e-8304-11e8-94b2-44fbee4d1961.png" alt="testl100_105"/></p><pre><code class="language-julia">vehicle_drives_to!(fg, :l105, GTp, GTl)
vehicle_drives_to!(fg, :l106, GTp, GTl)

tree, smt, hist = solveTree!(fg)


vehicle_drives_to!(fg, :l107, GTp, GTl)

tree, smt, hist = solveTree!(fg)


vehicle_drives_to!(fg, :l108, GTp, GTl)

tree, smt, hist = solveTree!(fg)


pl = plotKDE(fg, [Symbol(&quot;l$(100+i)&quot;) for i in 2:8], dims=[1;2], levels=6)
# Gadfly.draw(PDF(&quot;/tmp/testL103_108.pdf&quot;, 20cm, 10cm),pl)</code></pre><p>Next we see a strong return to a single dominant mode in all vehicle position estimates, owing to the increased measurements to beacons/landmarks as well as more unimodal estimates in <code>:l3, :l4</code> beacon/landmark positions.</p><pre><code class="language-julia">vehicle_drives_to!(fg, :l109, GTp, GTl)
vehicle_drives_to!(fg, :l110, GTp, GTl)

tree, smt, hist = solveTree!(fg)


vehicle_drives_to!(fg, :l111, GTp, GTl)
vehicle_drives_to!(fg, :l112, GTp, GTl)

tree, smt, hist = solveTree!(fg)


pl = plotKDE(fg, [Symbol(&quot;l$(100+i)&quot;) for i in 7:12], dims=[1;2])
# Gadfly.draw(PDF(&quot;/tmp/testL106_112.pdf&quot;, 20cm, 10cm),pl)

pl = plotKDE(fg, [:l1;:l2;:l3;:l4], dims=[1;2], levels=4)
# Gadfly.draw(PDF(&quot;/tmp/testL1234.pdf&quot;, 20cm, 10cm),pl)

pl = drawLandms(fg, from=100)
# Gadfly.draw(PDF(&quot;/tmp/testLocsAll.pdf&quot;, 20cm, 10cm),pl)</code></pre><p>Several location belief estimates exhibit multimodality as the trajectory progresses (not shown), but collapses and finally collapses to a stable set of dominant position estimates.</p><p><img src="https://user-images.githubusercontent.com/6412556/42429138-7576dea4-8305-11e8-9a0c-a56984805126.png" alt="testl106_112"/></p><p>Landmark estimates are also stable at one estimate:</p><p><img src="https://user-images.githubusercontent.com/6412556/42429149-85ee3bf6-8305-11e8-8a39-6af5b7496f3c.png" alt="testl1234"/></p><p>In addition, the SLAM 2D landmark visualization can be re-used to plot more information at once:</p><pre><code class="language-julia"># pl = drawLandms(fg, from=100, to=200)
# Gadfly.draw(PDF(&quot;/tmp/testLocsAll.pdf&quot;, 20cm, 10cm),pl)

pl = drawLandms(fg)
# Gadfly.draw(PDF(&quot;/tmp/testAll.pdf&quot;, 20cm, 10cm),pl)</code></pre><p><img src="https://user-images.githubusercontent.com/6412556/42429216-d3b8b73a-8305-11e8-89ba-bb790b0963d5.png" alt="testall"/></p><p>This example used the default of <code>N=200</code> particles per marginal belief. By increasing the number to <code>N=300</code> throughout the test many more modes and interesting features can be explored, and we refer the reader to an alternative and longer discussion on the same example, in <a href="https://darchive.mblwhoilibrary.org/bitstream/handle/1912/9305/Fourie_thesis.pdf?sequence=1">Chapter 6 here</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basic_continuousscalar/">« ContinuousScalar as 1D Example</a><a class="docs-footer-nextpage" href="../basic_hexagonal2d/">Hexagonal 2D SLAM »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 30 July 2020 15:44">Thursday 30 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
