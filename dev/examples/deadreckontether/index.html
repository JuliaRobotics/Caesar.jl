<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dead Reckon Tether · Caesar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Caesar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../introduction/">Introduction</a></li><li><a class="tocitem" href="../../concepts/why_nongaussian/">Gaussian vs. Non-Gaussian</a></li><li><a class="tocitem" href="../../installation_environment/">Installation</a></li><li><a class="tocitem" href="../../concepts/using_julia/">Using Julia</a></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../concepts/concepts/">Initial Concepts</a></li><li><a class="tocitem" href="../../concepts/building_graphs/">Building Graphs</a></li><li><a class="tocitem" href="../../concepts/solving_graphs/">Solving Graphs</a></li><li><a class="tocitem" href="../../concepts/interacting_fgs/">Interact w Graphs</a></li><li><a class="tocitem" href="../../concepts/dataassociation/">Multi-Modal/Hypothesis</a></li><li><a class="tocitem" href="../../concepts/parallel_processing/">Parallel Processing</a></li><li><a class="tocitem" href="../parametric_solve/">[DEV] Parametric Solve</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/">Caesar Examples</a></li><li><a class="tocitem" href="../basic_continuousscalar/">Canonical 1D Example</a></li><li><a class="tocitem" href="../basic_slamedonut/">Underconstrained Range-only</a></li><li><a class="tocitem" href="../basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="tocitem" href="../interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li><li class="is-active"><a class="tocitem" href>Dead Reckon Tether</a><ul class="internal"><li><a class="tocitem" href="#DRT-Functions"><span>DRT Functions</span></a></li><li><a class="tocitem" href="#DRT-Construct"><span>DRT Construct</span></a></li><li><a class="tocitem" href="#Function-Reference"><span>Function Reference</span></a></li><li><a class="tocitem" href="#Additional-Notes"><span>Additional Notes</span></a></li></ul></li></ul></li><li><span class="tocitem">Graph Library</span><ul><li><a class="tocitem" href="../canonical_graphs/">Canonical Generators</a></li><li><a class="tocitem" href="../../concepts/entry_data/">Entry=&gt;Data Blob</a></li><li><a class="tocitem" href="../../concepts/available_varfacs/">Variables/Factors</a></li><li><a class="tocitem" href="../../concepts/flux_factors/">Flux (NN) Factors</a></li><li><a class="tocitem" href="../using_images/">Images and AprilTags</a></li></ul></li><li><span class="tocitem">Visualization</span><ul><li><a class="tocitem" href="../../install_viz/">Installing Viz</a></li><li><a class="tocitem" href="../../concepts/2d_plotting/">Plotting (2D)</a></li><li><a class="tocitem" href="../../concepts/arena_visualizations/">Visualization (3D)</a></li></ul></li><li><span class="tocitem">Middlewares</span><ul><li><a class="tocitem" href="../using_ros/">ROS Middleware</a></li><li><a class="tocitem" href="../../concepts/compile_binary/">Compile Binaries</a></li><li><a class="tocitem" href="../../concepts/zero_install/">Zero Install Solution</a></li><li><a class="tocitem" href="../../concepts/multisession/">Multi-session/agent Solving</a></li><li><a class="tocitem" href="../../concepts/multilang/">Multi-Language Support</a></li></ul></li><li><span class="tocitem">How to Expand?</span><ul><li><a class="tocitem" href="../../caesar_framework/">Pkg Framework</a></li><li><a class="tocitem" href="../adding_variables_factors/">Custom Variables and Factors</a></li><li><a class="tocitem" href="../custom_variables/">Creating Variables</a></li><li><a class="tocitem" href="../basic_definingfactors/">Creating Factors</a></li><li><a class="tocitem" href="../../func_ref/">More Functions</a></li></ul></li><li><span class="tocitem">Principles</span><ul><li><a class="tocitem" href="../../principles/filterCorrespondence/">Filters vs. Graphs</a></li><li><a class="tocitem" href="../../principles/approxConvDensities/">Generic Convolutions</a></li><li><a class="tocitem" href="../../principles/multiplyingDensities/">Multiplying Functions (.py)</a></li><li><a class="tocitem" href="../../principles/bayestreePrinciples/">Bayes (Junction) tree</a></li><li><a class="tocitem" href="../../principles/initializingOnBayesTree/">Advanced Bayes Tree Topics</a></li><li><a class="tocitem" href="../../concepts/mmisam_alg/">Non-Gaussian Algorithm</a></li></ul></li><li><span class="tocitem">Developer Zone</span><ul><li><a class="tocitem" href="../../dev/wiki/">Wiki Pointers</a></li><li><a class="tocitem" href="../../principles/interm_dynpose/">Creating DynPose Factor</a></li><li><a class="tocitem" href="../../dev/known_issues/">Known Issue List</a></li><li><a class="tocitem" href="../../dev/internal_fncs/">Internal Functions</a></li></ul></li><li><span class="tocitem">Literature</span><ul><li><a class="tocitem" href="../../refs/literature/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Dead Reckon Tether</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dead Reckon Tether</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/examples/deadreckontether.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Dead-Reckon-Tether"><a class="docs-heading-anchor" href="#Dead-Reckon-Tether">Dead Reckon Tether</a><a id="Dead-Reckon-Tether-1"></a><a class="docs-heading-anchor-permalink" href="#Dead-Reckon-Tether" title="Permalink"></a></h1><p>Towards real-rime location prediction and model based target tracking.  See brief description in this presentation.</p><iframe src="https://player.vimeo.com/video/474897929#t=11m24s" width="800" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>
<p><a href="https://vimeo.com/474897929">Towards Real-Time Non-Gaussian SLAM</a> from <a href="https://vimeo.com/user35117400">Dehann</a> on <a href="https://vimeo.com">Vimeo</a>.</p><h2 id="DRT-Functions"><a class="docs-heading-anchor" href="#DRT-Functions">DRT Functions</a><a id="DRT-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#DRT-Functions" title="Permalink"></a></h2><p>Overview of related functions while this documentation is being expanded:</p><ul><li><code>addVariable!(fg, :drt_0, ..., solvable=0)</code></li><li><code>drec1 = MutablePose2Pose2Gaussian(...)</code></li><li><code>addFactor!(dfg, [:x0; :drt_0], drec1, solvable=0, graphinit=false)</code></li><li><code>accumulateDiscreteLocalFrame!</code></li><li><code>accumulateFactorMeans</code></li><li><code>duplicateToStandardFactorVariable</code></li></ul><h2 id="DRT-Construct"><a class="docs-heading-anchor" href="#DRT-Construct">DRT Construct</a><a id="DRT-Construct-1"></a><a class="docs-heading-anchor-permalink" href="#DRT-Construct" title="Permalink"></a></h2><p>The idea is that the dead reckong tracking method is to update a single value based on high-rate sensor data.  Perhaps &#39;particles&#39; values can be propagated as a non-Gaussian prediction, depending on allowable compute resources, and for that see <a href="examples/@ref"><code>approxConv</code></a>.  Some specialized plumbing has been built to facilitate rapid single value propagation using the factor graph.  </p><h3 id="Suppress-w/-solvable"><a class="docs-heading-anchor" href="#Suppress-w/-solvable">Suppress w/ <code>solvable</code></a><a id="Suppress-w/-solvable-1"></a><a class="docs-heading-anchor-permalink" href="#Suppress-w/-solvable" title="Permalink"></a></h3><p>The construct uses regular <a href="../../concepts/building_graphs/#DistributedFactorGraphs.addVariable!"><code>addVariable!</code></a> and <a href="../../concepts/building_graphs/#DistributedFactorGraphs.addFactor!"><code>addFactor!</code></a> calls but with a few tweaks.  The first is that some variables and factors should not be incorporated with the regular <a href="../../concepts/solving_graphs/#IncrementalInference.solveTree!"><code>solveTree!</code></a> call and can be achieved on a per node basis, e.g.:</p><pre><code class="language-julia hljs">fg = initfg()

# a regular variable and prior for solving in graph
addVariable!(fg, :x0, Pose2) # default solvable=1
addFactor!(fg, [:x0;], PriorPose2(MvNormal([0;0;0.0],diagm([0.1;0.1;0.01]))))

# now add a variable that will not be included in solves
addVariable!(fg, :drt0, Pose2, solvable=0)</code></pre><h3 id="A-Mutable-Factor"><a class="docs-heading-anchor" href="#A-Mutable-Factor">A Mutable Factor</a><a id="A-Mutable-Factor-1"></a><a class="docs-heading-anchor-permalink" href="#A-Mutable-Factor" title="Permalink"></a></h3><p>The next part is to add a factor that can be rapidly updated from sensor data, hence liberal use of the term &#39;Mutable&#39;:</p><pre><code class="language-julia hljs">drt0 = MutablePose2Pose2Gaussian(MvNormal([0;0;0.0],diagm([0.1;0.1;0.01])))
addFactor!(dfg, [:x0; :drt0], drt0, solvable=0, graphinit=false)</code></pre><p>Notice that this factor is also set with <code>solvable=0</code> to exclude it from the regular solving process.  Also note the <code>graphinit=false</code> to prevent any immediate automated attempts to initialize the values to connected variables using this factor.</p><h3 id="Sensor-rate-updates"><a class="docs-heading-anchor" href="#Sensor-rate-updates">Sensor rate updates</a><a id="Sensor-rate-updates-1"></a><a class="docs-heading-anchor-permalink" href="#Sensor-rate-updates" title="Permalink"></a></h3><p>The idea of a dead reckon tether is that the value in the factor can rapidly be updated without affecting any other regular part of the factor graph or simultaneous solving progress.  Imagine new sensor data from wheel odometry or an IMU is available which is then used to &#39;mutate&#39; the values in a DRT factor:</p><pre><code class="language-julia hljs"># continuous Gaussian process noise Q
Qc = 0.001*diagm(ones(3))

# accumulate a Pose2 delta odometry measurement segment onto existing value in drt0
accumulateDiscreteLocalFrame!(drt0,[0.1;0;0.05],Qc)</code></pre><h3 id="Dead-Reckoned-Prediction"><a class="docs-heading-anchor" href="#Dead-Reckoned-Prediction">Dead Reckoned Prediction</a><a id="Dead-Reckoned-Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Dead-Reckoned-Prediction" title="Permalink"></a></h3><p>Using the latest available inference result <code>fg[:x0]</code>, the <code>drt0</code> factor can be used to predict the single parameteric location of variable <code>:drt0</code>:</p><pre><code class="language-julia hljs"># can happen concurrently with most other operations on fg, including `solveTree!`
predictDRT0 = accumulateFactorMeans(fg, [:x0drt0f1;])</code></pre><p>Note also a convenience function uses similar plumbing for integrating odometry as well as any other DRT operations.  Imagine a robot is driving from pose position 0 to 1, then the final pose trigger value in factor <code>drt0</code> is the same value required to instantiate a new factor graph <code>Pose2Pose2</code>, and hence:</p><pre><code class="language-julia hljs"># add new regular rigid transform (odometry) factor between pose variables 
duplicateToStandardFactorVariable(Pose2Pose2, drt0, fg, :x0, :x1)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>(2021Q1) Some of these function names are likely to be better standardized in the future.  Regular semver deprecation warnings will be used to simplify any potential updates that may occur.  Please file issues at Caesar.jl if any problems arise.</p></div></div><h2 id="Function-Reference"><a class="docs-heading-anchor" href="#Function-Reference">Function Reference</a><a id="Function-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RoME.duplicateToStandardFactorVariable" href="#RoME.duplicateToStandardFactorVariable"><code>RoME.duplicateToStandardFactorVariable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">duplicateToStandardFactorVariable(, mpp, dfg, prevsym, newsym; solvable, graphinit, cov)
</code></pre><p>Helper function to duplicate values from a special factor variable into standard factor and variable.  Returns the name of the new factor.</p><p>Notes:</p><ul><li>Developed for accumulating odometry in a <code>MutablePosePose</code> and then cloning out a standard PosePose and new variable.</li><li>Does not change the original MutablePosePose source factor or variable in any way.</li><li>Assumes timestampe from mpp object.</li></ul><p>Related</p><p><a href="../../concepts/building_graphs/#DistributedFactorGraphs.addVariable!"><code>addVariable!</code></a>, <a href="../../concepts/building_graphs/#DistributedFactorGraphs.addFactor!"><code>addFactor!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RoME.accumulateDiscreteLocalFrame!" href="#RoME.accumulateDiscreteLocalFrame!"><code>RoME.accumulateDiscreteLocalFrame!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accumulateDiscreteLocalFrame!(mpp, DX, Qc)
accumulateDiscreteLocalFrame!(mpp, DX, Qc, dt; Fk, Gk, Phik)
</code></pre><p>Advance an odometry factor as though integrating an ODE – i.e. <span>$X_2 = X_1 ⊕ ΔX$</span>. Accepts continuous domain process noise density <code>Qc</code> which is internally integrated to discrete process noise Qd.  <span>$DX$</span> is assumed to already be incrementally integrated before this function.  See related <code>accumulateContinuousLocalFrame!</code> for fully continuous system propagation.</p><p>Notes</p><ul><li>This update stays in the same reference frame but updates the local vector as though accumulating measurement values over time.</li><li>Kalman filter would have used for noise propagation: <span>$Pk1 = F*Pk*F&#39; + Qdk$</span></li><li>From Chirikjian, Vol.II, 2012, p.35: Jacobian SE(2), Jr = [cθ sθ 0; -sθ cθ 0; 0 0 1] – i.e. dSE2/dX&#39; = SE2([0;0;-θ])</li><li><code>DX = dX/dt*Dt</code></li><li>assumed process noise for <code>{}^b Qc = {}^b [x;y;yaw] = [fwd; sideways; rotation.rate]</code></li></ul><p>Dev Notes</p><ul><li>TODO many operations here can be done in-place.</li></ul><p>Related</p><p>accumulateContinuousLocalFrame!, accumulateDiscreteReferenceFrame!, <a href="#IncrementalInference.accumulateFactorMeans"><code>accumulateFactorMeans</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.accumulateFactorMeans" href="#IncrementalInference.accumulateFactorMeans"><code>IncrementalInference.accumulateFactorMeans</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accumulateFactorMeans(dfg, fctsyms)
</code></pre><p>Accumulate chains of binary factors–-potentially starting from a prior–-as a parameteric mean value only.</p><p>Notes</p><ul><li>Not used during tree inference.</li><li>Expected uses are for user analysis of factors and estimates.</li><li>real-time dead reckoning chain prediction.</li><li>Returns mean value as coordinates</li></ul><p>DevNotes</p><ul><li>TODO consolidate with similar <code>approxConv</code></li></ul><p>Related:</p><p><a href="examples/@ref"><code>approxConv</code></a>, <a href="examples/@ref"><code>solveFactorParameteric</code></a>, <code>RoME.MutablePose2Pose2Gaussian</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RoME.MutablePose2Pose2Gaussian" href="#RoME.MutablePose2Pose2Gaussian"><code>RoME.MutablePose2Pose2Gaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MutablePose2Pose2Gaussian &lt;: IncrementalInference.AbstractManifoldMinimize</code></pre><p>Specialized Pose2Pose2 factor type (Gaussian), which allows for rapid accumulation of odometry information as a branch on the factor graph.</p></div></section></article><h2 id="Additional-Notes"><a class="docs-heading-anchor" href="#Additional-Notes">Additional Notes</a><a id="Additional-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Notes" title="Permalink"></a></h2><p>This will be consolidated with text above:</p><ul><li>regardless of slam solution going on in the background, you can then just call <code>val = accumulateFactorMeans(fg, [:x0deadreckon_x0f1])</code></li></ul><p>for a new dead reckon tether solution;</p><ul><li>you can add as many tethers as you want.  </li><li>So if you solving every 10 poses, you just add a new tether x0, x10, x20, x30...</li><li>as the solves complete on previous segments, then you can just get the latest <code>accumulateFactorMean</code></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interm_fixedlag_hexagonal/">« Fixed-Lag Solving 2D</a><a class="docs-footer-nextpage" href="../canonical_graphs/">Canonical Generators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 24 October 2021 15:55">Sunday 24 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
