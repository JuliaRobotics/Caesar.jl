<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Creating Factors · Caesar.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Caesar.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Welcome</span><ul><li><a class="tocitem" href="../../installation_environment/">Installation</a></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../concepts/concepts/">Initial Concepts</a></li><li><a class="tocitem" href="../../concepts/building_graphs/">Building Factor Graphs</a></li><li><a class="tocitem" href="../../concepts/interacting_fgs/">Solving and Interacting</a></li><li><a class="tocitem" href="../../concepts/available_varfacs/">Internal Variables/Factors</a></li><li><a class="tocitem" href="../../concepts/dataassociation/">Multi-Modal/Hypothesis</a></li><li><a class="tocitem" href="../../concepts/flux_factors/">Flux (NN) Factors</a></li><li><a class="tocitem" href="../../concepts/2d_plotting/">Plotting (2D)</a></li><li><a class="tocitem" href="../../concepts/entry_data/">Entry=&gt;Data Blob</a></li><li><a class="tocitem" href="../../concepts/multilang/">Multi-Language Support</a></li><li><a class="tocitem" href="../../concepts/database_interactions/">Cloud Server/Database</a></li><li><a class="tocitem" href="../../concepts/multisession/">Multi-session/agent Solving</a></li><li><a class="tocitem" href="../parametric_solve/">Parametric Solve (EXP)</a></li><li><a class="tocitem" href="../../concepts/arena_visualizations/">Visualization (3D)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/">Caesar Examples</a></li><li><a class="tocitem" href="../basic_continuousscalar/">ContinuousScalar as 1D Example</a></li><li><a class="tocitem" href="../basic_slamedonut/">Under-defined Trilateration, 2D</a></li><li><a class="tocitem" href="../basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="tocitem" href="../interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li><li><a class="tocitem" href="../using_ros/">ROS Middleware</a></li><li><a class="tocitem" href="../deadreckontether/">Dead Reckon Tether</a></li></ul></li><li><span class="tocitem">Principles</span><ul><li><a class="tocitem" href="../../principles/filterCorrespondence/">Filters vs. Graphs</a></li><li><a class="tocitem" href="../../principles/approxConvDensities/">Generic Convolutions</a></li><li><a class="tocitem" href="../../principles/multiplyingDensities/">Multiplying Functions (.py)</a></li><li><a class="tocitem" href="../../principles/bayestreePrinciples/">Bayes (Junction) tree</a></li><li><a class="tocitem" href="../../principles/initializingOnBayesTree/">Advanced Bayes Tree Topics</a></li><li><a class="tocitem" href="../../concepts/mmisam_alg/">Multimodal iSAM Algorithm</a></li></ul></li><li><span class="tocitem">How to Expand?</span><ul><li><a class="tocitem" href="../adding_variables_factors/">Custom Variables and Factors</a></li><li><a class="tocitem" href="../custom_variables/">Creating Variables</a></li><li class="is-active"><a class="tocitem" href>Creating Factors</a><ul class="internal"><li><a class="tocitem" href="#Defining-a-New-Prior-(Absolute-/-Gauge)"><span>Defining a New Prior (Absolute / Gauge)</span></a></li><li><a class="tocitem" href="#Relative-Factors"><span>Relative Factors</span></a></li><li><a class="tocitem" href="#Special-Considerations"><span>Special Considerations</span></a></li><li><a class="tocitem" href="#[OPTIONAL]-Standardized-Serialization"><span>[OPTIONAL] Standardized Serialization</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><span class="tocitem">Developer Zone</span><ul><li><a class="tocitem" href="../../dev/wiki/">Wiki Pointers</a></li><li><a class="tocitem" href="../../principles/interm_dynpose/">Creating DynPose Factor</a></li><li><a class="tocitem" href="../../dev/known_issues/">Known Issue List</a></li><li><a class="tocitem" href="../../dev/internal_fncs/">Internal Functions</a></li></ul></li><li><span class="tocitem">Literature</span><ul><li><a class="tocitem" href="../../refs/literature/">References</a></li></ul></li><li><span class="tocitem">Function Reference</span><ul><li><a class="tocitem" href="../../func_ref/">Caesar&#39;s Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to Expand?</a></li><li class="is-active"><a href>Creating Factors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Creating Factors</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/examples/basic_definingfactors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Defining-New-Factors"><a class="docs-heading-anchor" href="#Defining-New-Factors">Defining New Factors</a><a id="Defining-New-Factors-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-New-Factors" title="Permalink"></a></h1><p>Julia&#39;s type inference allows overloading of member functions outside a module.  Therefore new factors can be defined at any time.  To better illustrate, in this example we will add new factors into the <code>Main</code> context <strong>after</strong> construction of the factor graph has already begun.</p><pre><code class="language-julia">using IncrementalInference

# You must import this to later overload
import IncrementalInference: getSample</code></pre><p>Let&#39;s start with some factor graph:</p><pre><code class="language-julia"># empty factor graph object
fg = initfg()

# add a variable in 1 dimension
addVariable!(fg, :x0, ContinuousEuclid{1})
addVariable!(fg, :x1, ContinuousEuclid{1})

# and a basic IIF.Prior from existing factors and Distributions.jl
pr0 = Prior(Normal(0,1))
addFactor!(fg, [:x0], pr0)

# making fg slightly more interesting -- i.e. x0 and x1 are 10 units apart on 1D Euclidean space
addFactor!(fg, [:x0; :x1], LinearRelative(Normal(10,1)))</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p><code>IIF</code> is a convenient <code>const</code> alias of the module <code>IncrementalInference</code>, similarly <code>AMP</code> for <code>ApproxManifoldProducts</code>.</p></div></div><h2 id="Defining-a-New-Prior-(Absolute-/-Gauge)"><a class="docs-heading-anchor" href="#Defining-a-New-Prior-(Absolute-/-Gauge)">Defining a New Prior (Absolute / Gauge)</a><a id="Defining-a-New-Prior-(Absolute-/-Gauge)-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-New-Prior-(Absolute-/-Gauge)" title="Permalink"></a></h2><p>Now lets define in <code>Main</code> scope our own prior, <code>MyPrior</code> which allows for arbitrary distributions that inherit from <code>&lt;: IIF.SamplableBelief</code>:</p><pre><code class="language-julia">
struct MyPrior{T &lt;: SamplableBelief} &lt;: IIF.AbstractPrior
  Z::T
end

# import IncrementalInference: getSample
# sampling function
getSample(cfo::CalcFactor{&lt;:MyPrior}, N::Int=1) = (reshape(rand(cfo.factor.Z,N),1,:), )</code></pre><p>Note the following critical aspects that allows IIF to use the new definition:</p><ul><li><code>&lt;:AbstractPrior</code> as a unary factor that introduces absolute (or gauge) information about only one variable.</li><li><code>getSample</code> is overloaded with dispatch on:<ul><li><code>(cfo::CalcFactor{&lt;:MyPrior}, ::Int)</code></li></ul></li><li><code>getSample</code> must return a <code>::Tuple</code>, even if there is only stochastic value (as is the case above).<ul><li>The first value in the tuple is special, and must be of type <code>&lt;:AbstractMatrix{&lt;:Real}</code>.  We ensure that with the <code>reshape</code>.</li></ul></li></ul><p>IIF internally uses the number of rows in the first element of the <code>getSample</code> return tuple (i.e. the matrix) to extract the measurement dimension for this factor.  In this case it is 1 dimensional.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>getSample</code> works similar for factors below.  If the measurement dimension is 2D (i.e. <code>zDim=2</code>) then you should not use <code>reshape(..., 1,N)</code> which would force the samples into a 1 row matrix.  The <code>reshape(.., 1,N)</code> in the above example is added as convenient way to convert from the <code>rand</code> return value a <code>::Array{Float64,1}</code> to the required <code>::Array{Float64,2}</code> type.</p></div></div><p>To recap, the new <code>getSample</code> function in this example factor returns a measurement which is of type <code>::Tuple{::Matrix{Float64}}</code>.  The <code>::Tuple</code> is slightly clunky but was borne out of necessity to allow for versatility when multiple values from sampling are used during residual function evaluation.  Previous uses  include cases such as <code>::Tuple{&lt;:Matrix, &lt;:Vector, &lt;:Function}</code>.</p><h3 id="Ready-to-Use"><a class="docs-heading-anchor" href="#Ready-to-Use">Ready to Use</a><a id="Ready-to-Use-1"></a><a class="docs-heading-anchor-permalink" href="#Ready-to-Use" title="Permalink"></a></h3><p>This new prior can now readily be added to an ongoing factor graph:</p><pre><code class="language-julia"># lets generate a random nonparametric belief
pts = 8 .+ 2*rand(1,75)
someBelief = manikde!(pts, ContinuousEuclid{1})

# and build your new factor as an object
myprior = MyPrior(someBelief)</code></pre><p>and add it to the existing factor graph from earlier, lets say:</p><pre><code class="language-julia">addFactor!(fg, :x1, myprior)</code></pre><p>Thats it, this factor is now part of the graph.  This should be a solvable graph:</p><pre><code class="language-julia">solveGraph!(fg); # exact alias of solveTree!(fg)</code></pre><p>Later we will see how to ensure these new factors can be properly serialized to work with features like <code>saveDFG</code> and <code>loadDFG</code>.</p><h3 id="What-is-CalcFactor"><a class="docs-heading-anchor" href="#What-is-CalcFactor">What is <code>CalcFactor</code></a><a id="What-is-CalcFactor-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-CalcFactor" title="Permalink"></a></h3><p><code>CalcFactor</code> is part of the <code>IIF</code> interface to all factors.  It contains metadata and other important bits of information that are useful in a wide swath of applications.  As work requires more interesting features from the code base, it is likely that the <code>cfo::CalcFactor</code> object will contain such data.  If not, please open an issue with Caesar.jl so that the necessary options may be added.</p><p>The <code>cfo</code> object contains the field <code>.factor::T</code> which is the type of the user factor being used, e.g. <code>myprior</code> from above example.  That is <code>cfo.factor::MyPrior</code>.  This is why <code>getSample</code> is using <code>rand(cfo.factor.Z)</code>.</p><p><code>CalcFactor</code> was introduced in <code>IncrementalInference v0.20</code> to consolidate and standardize a variety of features that had previously been diseparate and unwieldy.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Many factors already exists in <code>IncrementalInference</code>, <code>RoME</code>, and <code>Caesar</code>.  Please see their <code>src</code> directories for more details.</p></div></div><h2 id="Relative-Factors"><a class="docs-heading-anchor" href="#Relative-Factors">Relative Factors</a><a id="Relative-Factors-1"></a><a class="docs-heading-anchor-permalink" href="#Relative-Factors" title="Permalink"></a></h2><h3 id="One-Dimension-Roots-Example"><a class="docs-heading-anchor" href="#One-Dimension-Roots-Example">One Dimension Roots Example</a><a id="One-Dimension-Roots-Example-1"></a><a class="docs-heading-anchor-permalink" href="#One-Dimension-Roots-Example" title="Permalink"></a></h3><p>Previously we looked at adding a prior.  This section demonstrates the first of two <code>&lt;:AbstractRelative</code> factor types.  These are factors that introduce only relative information between variables in the factor graph.</p><p>This example is on <code>&lt;:IIF.AbstractRelativeRoots</code>.  First, lets create the factor as before </p><pre><code class="language-julia">struct MyFactor{T &lt;: SamplableBelief} &lt;: IIF.AbstractRelativeRoots
  Z::T
end
getSample(cfo::CalcFactor{&lt;:MyFactor}, N::Int=1) = (reshape(rand(cfo.factor.Z,N) ,1,N), )

function (cfo::CalcFactor{&lt;:MyFactor})( measurement_z,
                                        x1,
                                        x2  )
  #
  res = measurement_z - (x2[1] - x1[1])
  return res
end</code></pre><p>The selection of <code>&lt;:IIF.AbstractRelativeRoots</code>, akin to earlier <code>&lt;:AbstractPrior</code>, instructs IIF to find the roots of the provided residual function.  That is the one dimensional residual function, <code>res[1] = measurement - prediction</code>, is used during inference to approximate the convolution of conditional beliefs from the approximate beliefs of the connected variables in the factor graph.</p><p>Important aspects to note, <code>&lt;:IIF.AbstractRelativeRoots</code> requires all elements <code>length(res)</code> (the factor measurement dimension) to have a feasible zero crossing solution.  A two dimensional system will solve for variables where both <code>res[1]==0</code> and <code>res[2]==0</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>As of IncrementalInference v0.21, CalcResidual no longer takes a residual as input parameter and should return residual, see IIF#467.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Measurements and variables passed in to the factor residual function do not have the same type as when constructing the factor graph.  It is recommended to leave these incoming types unrestricted.  If you must define the types, these either are (or will be) of element type relating to the manifold on which the measurement or variable beliefs reside.  Probably a vector or manifolds type.  Usage can be very case specific, and hence better to let Julia type-inference automation do the hard work for you. The </p></div></div><h3 id="Two-Dimension-Minimize-Example"><a class="docs-heading-anchor" href="#Two-Dimension-Minimize-Example">Two Dimension Minimize Example</a><a id="Two-Dimension-Minimize-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Dimension-Minimize-Example" title="Permalink"></a></h3><p>The second type is <code>&lt;:IIF.AbstractRelativeMinimize</code> which simply minimizes the residual vector of the user factor. This type is useful for partial constraint situations where the residual function is not gauranteed to have zero crossings in all dimensions and the problem is converted into a minimization problem instead:</p><pre><code class="language-julia">struct OtherFactor{T &lt;: SamplableBelief} &lt;: IIF.AbstractRelativeMinimize
  Z::T             # assuming something 2 dimensional
  userdata::String # or whatever is necessary
end

# just illustrating some arbitraty second value in tuple of different size
getSample(cfo::CalcFactor{&lt;:OtherFactor}, N::Int=1) = (rand(cfo.factor.z,N), rand())

function (cfo::CalcFactor{&lt;:OtherFactor})(res::AbstractVector{&lt;:Real},
                                          z,
                                          second_val,
                                          x1,
                                          x2 )
  #
  # @assert length(z) == 2
  # not doing anything with `second_val` but illustrating
  # not doing anything with `cfo.factor.userdata` either
  
  # the broadcast operators with automatically vectorize
  res = z .- (x1[1:2] .- x1[1:2])
  return res
end</code></pre><h2 id="Special-Considerations"><a class="docs-heading-anchor" href="#Special-Considerations">Special Considerations</a><a id="Special-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Considerations" title="Permalink"></a></h2><h3 id="Partial-Factors"><a class="docs-heading-anchor" href="#Partial-Factors">Partial Factors</a><a id="Partial-Factors-1"></a><a class="docs-heading-anchor-permalink" href="#Partial-Factors" title="Permalink"></a></h3><p>In some cases a factor only effects a partial set of dimensions of a variable.  For example a magnetometer being added onto a <code>Pose2</code> variable would look something like this:</p><pre><code class="language-julia">struct MyMagnetoPrior{T&lt;:SamplableBelief} &lt;: AbstractPrior
  Z::T
  partial::Tuple{Int}
end

# define a helper constructor
MyMagnetoPrior(z) = MyMagnetoPrior(z, (3,))

getSample(cfo::CalcFactor{&lt;:MyMagnetoPrior}, N::Int=1) = (reshape(rand(cfo.factor.Z,N),1,N),)</code></pre><p>Similarly for <code>&lt;:IIF.AbstractRelativeMinimize</code>, and note that the Roots version currently does not support the <code>.partial</code> option.</p><h3 id="Metadata"><a class="docs-heading-anchor" href="#Metadata">Metadata</a><a id="Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata" title="Permalink"></a></h3><p>The MM-iSAMv2 algorithm relies on the Kolmogorov-Criteria as well as uncorrelated factor sampling.  This means that when generating fresh samples for a factor, those samples should not depend on values of variables in the graph or independent volatile variables.  That said, if you are comfortable or have a valid reason for introducing correlation between the factor sampling process with values inside the factor graph then you can do so via the <code>cfo.CalcFactor</code> interface.</p><p>At present <code>cfo</code> contains three main fields:</p><ul><li><code>cfo.factor::MyFactor</code> the factor object as defined in the <code>struct</code> definition,</li><li><code>cfo.metadata::FactorMetadata</code>, which is currently under development and likely to change.<ul><li>This contains references to the connected variables to the factor and more, and is useful for large data retrieval such as used in Terrain Relative Navigation (TRN).</li></ul></li><li><code>cfo._sampleIdx</code> is the index of which computational sample is currently being calculated.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The old <code>.specialSampler</code> framework has been replaced with the standardized <code>::CalcFactor</code> interface.  See http://www.github.com/JuliaRobotics/IIF.jl/issues/467 for details.</p></div></div><h3 id="Multithreading"><a class="docs-heading-anchor" href="#Multithreading">Multithreading</a><a id="Multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreading" title="Permalink"></a></h3><p>Julia and therefore IIF has strong support for shared-memory multithreading.  The thing to keep in mind is what parts of residual factor computation is shared memory.  The most sensible breakdown into threaded work is for separate samples (i.e. <code>cfo._sampleIdx</code>) to be calculated in separate threads.  The user residual function itself could likely also be broken down further into more threaded operations.</p><p>The example above introduced <code>OtherFactor.userdata</code>.  This could cause problems if the residual calculations are actively using <code>userdata</code> for some volatile internal computation.  In that case it might be useful for the user to instead use <code>Threads.nthreads()</code> and <code>Threads.threadid()</code> to make sure the shared-memory issues are avoided:</p><pre><code class="language-julia">struct OtherFactor{T &lt;: SamplableBelief} &lt;: IIF.AbstractRelativeMinimize
  Z::T             # assuming something 2 dimensional
  inplace::Vector{MyInplaceMem}
end

# helper function
OtherFactor(z) = OtherFactor(z, [MyInplaceMem(0) for i in 1:Threads.nthreads()])

# in residual function just use `thr_inplace = cfo.factor.inplace[Threads.threadid()]`</code></pre><h2 id="[OPTIONAL]-Standardized-Serialization"><a class="docs-heading-anchor" href="#[OPTIONAL]-Standardized-Serialization">[OPTIONAL] Standardized Serialization</a><a id="[OPTIONAL]-Standardized-Serialization-1"></a><a class="docs-heading-anchor-permalink" href="#[OPTIONAL]-Standardized-Serialization" title="Permalink"></a></h2><p>To take advantage of features like <code>DFG.saveDFG</code> and <code>DFG.loadDFG</code> a user specified type should be able to serialize via JSON standards.  The decision was taken to require bespoke factor types to always be converted into a JSON friendly <code>struct</code> which must be prefixed as type name with <code>PackedMyPrior{T}</code>.   Similarly, the user must also overload <code>Base.convert</code> as follows:</p><pre><code class="language-julia"># necessary for overloading Base.convert
import Base: convert

struct PackedMyPrior &lt;: PackedInferenceType
  Z::String
end

# IIF provides convert methods for `SamplableBelief` types
convert(::Type{PackedMyPrior}, pr::MyPrior{&lt;:SamplableBelief}) = PackedMyPrior(convert(PackedSamplableBelief, pr.Z))
convert(::Type{MyPrior}, pr::PackedMyPrior) = MyPrior(IIF.convert(SamplableBelief, pr.Z))</code></pre><p>Now you should be able to <code>saveDFG</code> and <code>loadDFG</code> your own factor graph types to Caesar.jl / FileDFG standard <code>.tar.gz</code> format.</p><pre><code class="language-julia">fg = initfg()
addVariable!(fg, :x0, ContinuousScalar)
addFactor!(fg, [:x0], MyPrior(Normal()))

# generate /tmp/myfg.tar.gz
saveDFG(&quot;/tmp/myfg&quot;, fg)

# test loading the .tar.gz (extension optional)
fg2 = loadDFG(&quot;/tmp/myfg&quot;)

# list the contents
ls(fg2), lsf(fg2)
# should see :x0 and :x0f1 listed</code></pre><h3 id="Factors-supporting-a-Parametric-Solution"><a class="docs-heading-anchor" href="#Factors-supporting-a-Parametric-Solution">Factors supporting a Parametric Solution</a><a id="Factors-supporting-a-Parametric-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Factors-supporting-a-Parametric-Solution" title="Permalink"></a></h3><p>See the <a href="../parametric_solve/#parametric_factors">parametric solve section</a></p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>All factors inherit from one of the following types, depending on their function:</p><ul><li>AbstractPrior: AbstractPrior are priors (unary factors) that provide an absolute constraint for a single variable. A simple example of this is an absolute GPS prior, or equivalently a (0, 0, 0) starting location in a <a href="../../concepts/available_varfacs/#RoME.Pose2"><code>Pose2</code></a> scenario.<ul><li>Requires: A getSample function</li></ul></li><li>IIF.AbstractRelativeMinimize: IIF.AbstractRelativeMinimize are relative factors that introduce an algebraic relationship between two or more variables. A simple example of this is an odometry factor between two pose variables, or a range factor indicating the range between a pose and another variable.<ul><li>Requires: A getSample function and a residual function definition</li><li>The minimize suffix specifies that the residual function of this factor will be enforced by numerical minimization (find me the minimum of this function)</li></ul></li><li>IIF.AbstractRelativeRoots: IIF.AbstractRelativeRoots are relative factors that introduce algebraic relationships between two or more variables. They are the same as IIF.AbstractRelativeMinimize, however they use root finding to find the zero crossings (rather than numerical minimization).<ul><li>Requires: A getSample function and a residual function definition</li></ul></li></ul><p>How do you decide which to use?</p><ul><li>If you are creating factors for world-frame information that will be tied to a single variable, inherit from <code>&lt;:AbstractPrior</code><ul><li>GPS coordinates should be priors</li></ul></li><li>If you are creating factors for local-frame relationships between variables, inherit from IIF.AbstractRelativeMinimize<ul><li>Odometry and bearing deltas should be introduced as pairwise factors and should be local frame</li></ul></li></ul><p>TBD: Users should start with IIF.AbstractRelativeMinimize, discuss why and when they should promote their factors to IIF.AbstractRelativeRoots.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>IIF.AbstractRelativeMinimize does not imply that the overall inference algorithm only minimizes an objective function. The Multi-model iSAM algorithm is built around fixed-point analysis. Minimization is used here to locally enforce the residual function.</p></div></div><p>What you need to build in the new factor:</p><ul><li>A struct for the factor itself</li><li>A sampler function to return measurements from the random ditributions</li><li>If you are building a <a href="examples/@ref"><code>IIF.AbstractRelativeMinimize</code></a> or a <a href="examples/@ref"><code>IIF.AbstractRelativeRoots</code></a> you need to define a residual function to introduce the relative algebraic relationship between the variables<ul><li>Minimization function should be lower-bounded and smooth</li></ul></li><li>A packed type of the factor which must be named Packed[Factor name], and allows the factor to be packed/transmitted/unpacked</li><li>Serialization and deserialization methods<ul><li>These are convert functions that pack and unpack the factor (which may be highly complex) into serialization-compatible formats</li><li>As the factors are mostly comprised of distributions (of type <a href="examples/@ref"><code>SamplableBelief</code></a>), functions are provided to pack and unpack the distributions:<ul><li>Packing: To convert from a <a href="examples/@ref"><code>SamplableBelief</code></a> to a serializable obhect, use <code>convert(PackedSamplableBelief, ::SamplableBelief)</code></li><li>Unpacking: To convert from string back to a <code>SamplableBelief</code>, use <code>convert(SamplableBelief, ::PackedSamplableBelief)</code>  </li></ul></li></ul></li></ul><p>An example of this is the <a href="../../concepts/available_varfacs/#RoME.Pose2Point2BearingRange"><code>Pose2Point2BearingRange</code></a>, which provides a bearing+range relationship between a 2D pose and a 2D point.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>IIF.AbstractRelativeMinimize</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>IIF.AbstractRelativeRoots</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../custom_variables/">« Creating Variables</a><a class="docs-footer-nextpage" href="../../dev/wiki/">Wiki Pointers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 2 May 2021 11:13">Sunday 2 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
