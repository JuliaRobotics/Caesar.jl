<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fixed-Lag Solving 2D · Caesar.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Caesar.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Getting Started</span><ul><li><a class="toctext" href="../../installation_environment/">Installation</a></li><li><a class="toctext" href="../../faq/">FAQ</a></li></ul></li><li><span class="toctext">Initial Concepts</span><ul><li><a class="toctext" href="../../concepts/concepts/">Caesar Concepts</a></li><li><a class="toctext" href="../../concepts/building_graphs/">Building Factor Graphs</a></li><li><a class="toctext" href="../../concepts/available_varfacs/">Available Variables/Factors</a></li><li><a class="toctext" href="../../concepts/interacting_fgs/">Interacting w/ Factor Graphs</a></li><li><a class="toctext" href="../../concepts/mmisam_alg/">Multimodal iSAM Algorithm</a></li><li><a class="toctext" href="../../concepts/multilang/">Multi-Language Support</a></li><li><a class="toctext" href="../../concepts/arena_visualizations/">Arena Visualization</a></li><li><a class="toctext" href="../../concepts/database_interactions/">Cloud Server/Database</a></li><li><a class="toctext" href="../../concepts/multisession/">Multi/Cross Session Solving</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/">Caesar Examples</a></li><li><a class="toctext" href="../basic_continuousscalar/">ContinuousScalar as 1D Example</a></li><li><a class="toctext" href="../basic_slamedonut/">Under-defined Trilateration SLAM 2D</a></li><li><a class="toctext" href="../basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li class="current"><a class="toctext" href>Fixed-Lag Solving 2D</a><ul class="internal"><li><a class="toctext" href="#Example-Code-1">Example Code</a></li><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Example-Overview-1">Example Overview</a></li><li><a class="toctext" href="#Results-1">Results</a></li><li><a class="toctext" href="#Additional-Example-1">Additional Example</a></li></ul></li></ul></li><li><span class="toctext">Principles</span><ul><li><a class="toctext" href="../../principles/multiplyingDensities/">Multiplying Functions (.py)</a></li><li><a class="toctext" href="../../principles/approxConvDensities/">Generic Convolutions</a></li><li><a class="toctext" href="../../principles/filterCorrespondence/">Filters vs. Graphs</a></li></ul></li><li><span class="toctext">How to Expand?</span><ul><li><a class="toctext" href="../../concepts/adding_variables_factors/">Custom Variables and Factors</a></li><li><a class="toctext" href="../basic_definingfactors/">Creating Variables and Factors</a></li><li><a class="toctext" href="../interm_dynpose/">Creating DynPose Factor</a></li></ul></li><li><span class="toctext">Developer Zone</span><ul><li><a class="toctext" href="../../dev/wiki/">Wiki Pointer</a></li></ul></li><li><span class="toctext">Literature</span><ul><li><a class="toctext" href="../../refs/literature/">References</a></li></ul></li><li><span class="toctext">Function Reference</span><ul><li><a class="toctext" href="../../func_ref/">Caesar&#39;s Reference</a></li><li><a class="toctext" href="../../vis_func_ref/">Visualization Reference</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>Fixed-Lag Solving 2D</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/examples/interm_fixedlag_hexagonal.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Fixed-Lag Solving 2D</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Hexagonal-2D-with-Fixed-Lag-Solving-1" href="#Hexagonal-2D-with-Fixed-Lag-Solving-1">Hexagonal 2D with Fixed-Lag Solving</a></h1><blockquote><p><strong>NOTE:</strong> This is an experimental feature that is currently being developed. This example provides an overview of how to enable it and the benefits of using fixed-lag solving. The objective is to provide a near-constant solve time for ever-growing graphs by only recalculating the most recent portion. Think of this as a placeholder, as we develop the solution this tutorial will be updated to demonstrate how that is achieved.</p></blockquote><h2><a class="nav-anchor" id="Example-Code-1" href="#Example-Code-1">Example Code</a></h2><p>The complete code for this example can be found in the fixed-lag branch of RoME: <a href="https://github.com/JuliaRobotics/RoME.jl/blob/feature/fixedlag_example/examples/Hexagonal2D_SLAM_FixedLag.jl">Hexagonal Fixed-Lag Example</a>.</p><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>Fixed-lag solving is enabled when creating the factor-graph. Users provide a window - the quasi fixed-lag constant (QFL) - which defines how many of the most-recent variables should be calculated. Any other variables are &#39;frozen&#39;. The objective of this example is to explore providing a near-constant solve time for ever-growing graphs by only recalculating the most recent portion.</p><h2><a class="nav-anchor" id="Example-Overview-1" href="#Example-Overview-1">Example Overview</a></h2><p>In the example, the basic Hexagonal 2D is grown to solve 200 variables. The original example is remains the same, i.e. a vehicle is driving around in a hexagon and seeing the same bearing+range landmark as it crosses the starting point. At every 20th variable, a solve is invoked. Rather than use <code>batchSolve()</code>, the solve is performed in parts (construction of Bayes tree, solving the graph) to get performance statistics as the graph grows.</p><pre><code class="language-julia">numVariables = 200
solveEveryNVariables = 20
lagLength = 30

# Standard Hexagonal example for totalIterations - solve every iterationsPerSolve iterations.
function runHexagonalExample(fg::G, totalIterations::Int, iterationsPerSolve::Int)::DataFrame where {G &lt;: AbstractDFG}
    # Add the first pose :x0
    addVariable!(fg, :x0, Pose2)

    # Add at a fixed location PriorPose2 to pin :x0 to a starting location
    addFactor!(fg, [:x0], PriorPose2(MvNormal(zeros(3), 0.01*Matrix{Float64}(LinearAlgebra.I, 3,3))))

    # Add a landmark l1
    addVariable!(fg, :l1, Point2, labels=[:LANDMARK])

    # Drive around in a hexagon a number of times
    solveTimes = DataFrame(GraphSize = [], TimeBuildBayesTree = [], TimeSolveGraph = [])
    for i in 0:totalIterations
        psym = Symbol(&quot;x$i&quot;)
        nsym = Symbol(&quot;x$(i+1)&quot;)
        @info &quot;Adding pose $nsym...&quot;
        addVariable!(fg, nsym, Pose2)
        pp = Pose2Pose2(MvNormal([10.0;0;pi/3], Matrix(Diagonal( [0.1;0.1;0.1].^2 ) )))
        @info &quot;Adding odometry factor between $psym -&gt; $nsym...&quot;
        addFactor!(fg, [psym;nsym], pp )

        if i % 6 == 0
            @info &quot;Creating factor between $psym and l1...&quot;
            p2br = Pose2Point2BearingRange(Normal(0,0.1),Normal(20.0,1.0))
            addFactor!(fg, [psym; :l1], p2br)
        end
        if i % iterationsPerSolve == 0 &amp;&amp; i != 0
            @info &quot;Performing inference!&quot;
            if getSolverParams(fg).isfixedlag
                @info &quot;Quasi fixed-lag is enabled (a feature currently in testing)!&quot;
                fifoFreeze!(fg)
            end
            tBuild = @timed tree = wipeBuildNewTree!(fg)
            tInfer = @timed inferOverTree!(fg, tree, N=100)
            graphSize = length([ls(fg)[1]..., ls(fg)[2]...])
            push!(solveTimes, (graphSize, tBuild[2], tInfer[2]))
        end
    end
    return solveTimes
end</code></pre><p>Two cases are set up:</p><ul><li>One solving the full graph every time a solve is performed:</li></ul><pre><code class="language-julia"># start with an empty factor graph object
fg = initfg()
# DO NOT enable fixed-lag operation
solverTimesForBatch = runHexagonalExample(fg, numVariables, solveEveryNVariables)</code></pre><ul><li>The other enabling fixed-lag with a window of 20 variables:</li></ul><pre><code class="language-julia">fgFixedLag = initfg()
fgFixedLag.solverParams.isfixedlag = true
fgFixedLag.solverParams.qfl = lagLength

solverTimesFixedLag = runHexagonalExample(fgFixedLag, numVariables, solveEveryNVariables)</code></pre><p>The resultant path of the robot can be seen by using RoMEPlotting and is drawn if the visualization lines are uncommented:</p><pre><code class="language-julia">#### Visualization

# Plot the many iterations to see that it succeeded.
# Batch
# drawPosesLandms(fg)

# Fixed lag
# drawPosesLandms(fgFixedLag)</code></pre><p>Lastly, the timing results of both scenarios are merged into a single DataFrame table, exported to CSV, and a summary graph is shown using GadFly.</p><pre><code class="language-julia">using Gadfly
using Colors
using CSV

# Make a clean dataset
rename!(solverTimesForBatch, :TimeBuildBayesTree =&gt; :Batch_BayedBuild, :TimeSolveGraph =&gt; :Batch_SolveGraph);
rename!(solverTimesFixedLag, :TimeBuildBayesTree =&gt; :FixedLag_BayedBuild, :TimeSolveGraph =&gt; :FixedLag_SolveGraph);
timingMerged = DataFrames.join(solverTimesForBatch, solverTimesFixedLag, on=:GraphSize)
CSV.write(&quot;timing_comparison.csv&quot;, timingMerged)

PP = []
push!(PP, Gadfly.layer(x=timingMerged[:GraphSize], y=timingMerged[:FixedLag_SolveGraph], Geom.path, Theme(default_color=colorant&quot;green&quot;))[1]);
push!(PP, Gadfly.layer(x=timingMerged[:GraphSize], y=timingMerged[:Batch_SolveGraph], Geom.path, Theme(default_color=colorant&quot;magenta&quot;))[1]);

plt = Gadfly.plot(PP...,
    Guide.title(&quot;Solving Time vs. Iteration for Fixed-Lag Operation&quot;),
    Guide.xlabel(&quot;Solving Iteration&quot;),
    Guide.ylabel(&quot;Solving Time (seconds)&quot;),
    Guide.manual_color_key(&quot;Legend&quot;, [&quot;fixed&quot;, &quot;batch&quot;], [&quot;green&quot;, &quot;magenta&quot;]))
Gadfly.draw(PNG(&quot;results_comparison.png&quot;, 12cm, 15cm), plt)</code></pre><h2><a class="nav-anchor" id="Results-1" href="#Results-1">Results</a></h2><p>Preliminary results for the comparison can be seen below. However, this is just a start and we need to perform more testing. At the moment we are working on providing consistent results and further improving performance/flattening the fixed-lag time. It should be noted that the below graph is not to demonstrate the absolute solve time, but rather the relative behavior of full-graph solve vs. fixed-lag.</p><p><img src="../images/fixed_lag_timing.png" alt="Timing comparison of full solve vs. fixed-lag"/></p><blockquote><p><strong>NOTE</strong> Work is underway (aka <a href="https://github.com/JuliaRobotics/IncrementalInference.jl/projects/2">&quot;Project Tree House&quot;</a>) to reduce overhead computations that result in poorer fixed-lag solving times.  We expect the fixed-lag performance to improve in the coming months (Written Nov 2018).  Please file issues if a deeper discussion is required.</p></blockquote><h2><a class="nav-anchor" id="Additional-Example-1" href="#Additional-Example-1">Additional Example</a></h2><blockquote><p>Work In Progress, but In the mean time see the following examples:</p></blockquote><p>https://github.com/JuliaRobotics/Caesar.jl/blob/master/examples/wheeled/racecar/apriltag<em>and</em>zed_slam.jl</p><footer><hr/><a class="previous" href="../basic_hexagonal2d/"><span class="direction">Previous</span><span class="title">Hexagonal 2D SLAM</span></a><a class="next" href="../../principles/multiplyingDensities/"><span class="direction">Next</span><span class="title">Multiplying Functions (.py)</span></a></footer></article></body></html>
