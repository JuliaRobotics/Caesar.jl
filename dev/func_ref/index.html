<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Caesar&#39;s Reference · Caesar.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Caesar.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Getting Started</span><ul><li><a class="toctext" href="../installation_environment/">Installation</a></li><li><a class="toctext" href="../faq/">FAQ</a></li></ul></li><li><span class="toctext">Initial Concepts</span><ul><li><a class="toctext" href="../concepts/concepts/">Caesar Concepts</a></li><li><a class="toctext" href="../concepts/building_graphs/">Building Factor Graphs</a></li><li><a class="toctext" href="../concepts/available_varfacs/">Available Variables/Factors</a></li><li><a class="toctext" href="../concepts/interacting_fgs/">Interacting w/ Factor Graphs</a></li><li><a class="toctext" href="../concepts/mmisam_alg/">Multimodal iSAM Algorithm</a></li><li><a class="toctext" href="../concepts/multilang/">Multi-Language Support</a></li><li><a class="toctext" href="../concepts/arena_visualizations/">Arena Visualization</a></li><li><a class="toctext" href="../concepts/database_interactions/">Cloud Server/Database</a></li><li><a class="toctext" href="../concepts/multisession/">Multi/Cross Session Solving</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/examples/">Caesar Examples</a></li><li><a class="toctext" href="../examples/basic_continuousscalar/">ContinuousScalar as 1D Example</a></li><li><a class="toctext" href="../examples/basic_slamedonut/">Under-defined Trilateration SLAM 2D</a></li><li><a class="toctext" href="../examples/basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="toctext" href="../examples/interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li></ul></li><li><span class="toctext">Principles</span><ul><li><a class="toctext" href="../principles/multiplyingDensities/">Multiplying Functions (.py)</a></li></ul></li><li><span class="toctext">How to Expand?</span><ul><li><a class="toctext" href="../concepts/adding_variables_factors/">Custom Variables and Factors</a></li><li><a class="toctext" href="../examples/basic_definingfactors/">Creating Variables and Factors</a></li><li><a class="toctext" href="../examples/interm_dynpose/">Creating DynPose Factor</a></li></ul></li><li><span class="toctext">Developer Zone</span><ul><li><a class="toctext" href="../dev/wiki/">Wiki Pointer</a></li></ul></li><li><span class="toctext">Literature</span><ul><li><a class="toctext" href="../refs/literature/">References</a></li></ul></li><li><span class="toctext">Function Reference</span><ul><li class="current"><a class="toctext" href>Caesar&#39;s Reference</a><ul class="internal"><li><a class="toctext" href="#Function-Reference-1">Function Reference</a></li></ul></li><li><a class="toctext" href="../vis_func_ref/">Visualization Reference</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Function Reference</li><li><a href>Caesar&#39;s Reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/func_ref.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Caesar&#39;s Reference</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="Function-Reference-1" href="#Function-Reference-1">Function Reference</a></h2><ul><ul><li><a href="#Function-Reference-1">Function Reference</a></li><ul><li><a href="#Caesar-1">Caesar</a></li><li><a href="#RoME-1">RoME</a></li><li><a href="#IncrementalInference-1">IncrementalInference</a></li></ul></ul></ul><p><strong>WORK IN PROGRESS</strong>  Not all functions have been added to this directory yet.</p><h3><a class="nav-anchor" id="Caesar-1" href="#Caesar-1">Caesar</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.appendvertbigdata!" href="#Caesar.appendvertbigdata!"><code>Caesar.appendvertbigdata!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">appendvertbigdata!(cloudGraph::CloudGraphs.CloudGraph, cv::CloudGraphs.CloudVertex, description::Any, data::Array{UInt8,1})
</code></pre><p>Append big data element into current blob store and update associated global vertex information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L906-L911">source</a><div><div><pre><code class="language-julia">appendvertbigdata!(fgl::G&lt;:AbstractDFG, vert::G&lt;:AbstractDFG, description::G&lt;:AbstractDFG, data::G&lt;:AbstractDFG)
</code></pre><p>Append big data element into current blob store and update associated global vertex information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L923-L928">source</a><div><div><pre><code class="language-none">appendvertbigdata!(fg, sym, descr, data)</code></pre><p>Append big data element into current blob store using parent appendvertbigdata!, but here specified by symbol of variable node in the FactorGraph. Note the default data layer api definition. User must define dlapi to refetching the  vertex from the data layer. localapi avoids repeated network database fetches.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L941-L948">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.consoleaskuserfordb" href="#Caesar.consoleaskuserfordb"><code>Caesar.consoleaskuserfordb</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">consoleaskuserfordb(; nparticles, drawdepth, clearslamindb, multisession, drawedges) -&gt; Dict{AbstractString,Any}
</code></pre><p>Obtain database addresses and login credientials from STDIN, as well as a few case dependent options.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L783-L787">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.db2jld" href="#Caesar.db2jld"><code>Caesar.db2jld</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">db2jld(cgl::CloudGraph, session::AbstractString, filename::AbstractString)</code></pre><p>Fetch and save a FactorGraph session to a jld, using CloudGraph object and session definition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L1152-L1156">source</a><div><div><pre><code class="language-none">db2jld(filename::AbstractString; addrdict::NothingUnion{Dict{AbstractString, AbstractString}}=nothing )</code></pre><p>Fetch and save a FactorGraph session to a jld, using or asking STDIN for credentials in the addrdict field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L1164-L1168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.executeQuery" href="#Caesar.executeQuery"><code>Caesar.executeQuery</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">executeQuery(connection::AS&lt;:AbstractString, query::AS&lt;:AbstractString)
</code></pre><p>Run Neo4j Cypher queries on the cloudGraph database, and return Tuple with the unparsed (results, loadresponse). Throws an error if the query fails.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L45-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.fetchrobotdatafirstpose" href="#Caesar.fetchrobotdatafirstpose"><code>Caesar.fetchrobotdatafirstpose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fetchrobotdatafirstpose(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString)</code></pre><p>Return dict of JSON parsed &quot;robot_description&quot; field as was inserted by counterpart <code>insertrobotdatafirstpose!</code> function. Used for storing general robot specific data in easily accessible manner.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L1115-L1121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.fetchsubgraph!" href="#Caesar.fetchsubgraph!"><code>Caesar.fetchsubgraph!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fetchsubgraph!(fgl::G&lt;:AbstractDFG, cvs::G&lt;:AbstractDFG; numneighbors)
</code></pre><p>Fetch and insert list of CloudVertices into FactorGraph object, up to neighbor depth.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L961-L965">source</a><div><div><pre><code class="language-julia">fetchsubgraph!(fgl, neoids; numneighbors)
</code></pre><p>Fetch and insert list of Neo4j IDs into FactorGraph object, up to neighbor depth.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L995-L999">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.findExistingMSConstraints" href="#Caesar.findExistingMSConstraints"><code>Caesar.findExistingMSConstraints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return Dict{Symbol, Int} of vertex symbol to Neo4j node ID of MULTISESSION constraints in this <code>fgl.sessionname</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/MultisessionUtils.jl#L151-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.getAllLandmarkNeoIDs" href="#Caesar.getAllLandmarkNeoIDs"><code>Caesar.getAllLandmarkNeoIDs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getAllLandmarkNeoIDs(lm2others, slm)
</code></pre><p>Return Vector{Int} of Neo4j vertex IDs relating to symbol, as listed in lm2others.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/MultisessionUtils.jl#L106-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.getBigDataElement" href="#Caesar.getBigDataElement"><code>Caesar.getBigDataElement</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getBigDataElement(vertex::CloudGraphs.CloudVertex, description::AbstractString) -&gt; Union{Nothing, BigDataElement}
</code></pre><p>Walk through vertex bigDataElements and return the last matching description.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L877-L881">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.getExVertexNeoIDs" href="#Caesar.getExVertexNeoIDs"><code>Caesar.getExVertexNeoIDs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getExVertexNeoIDs(conn::Neo4j.Connection; label, ready, backendset, session, robot, user, reqbackendset) -&gt; Array{Tuple{Int64,Int64,Symbol},1}
</code></pre><p>Return array of tuples with ExVertex IDs and Neo4j IDs for vertices with label in session.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L499-L503">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.getLandmOtherSessNeoIDs" href="#Caesar.getLandmOtherSessNeoIDs"><code>Caesar.getLandmOtherSessNeoIDs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getLandmOtherSessNeoIDs{T &lt;: AbstractString}(::CloudGraph, session::T=&quot;&quot;, robot::T=&quot;&quot;, user::T=&quot;&quot;, multisessions=Vector{T}())</code></pre><p>Return dict of dict of Neo4j vertex IDs by session and landmark symbols.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/MultisessionUtils.jl#L47-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.getLocalSubGraphMultisession" href="#Caesar.getLocalSubGraphMultisession"><code>Caesar.getLocalSubGraphMultisession</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getLocalSubGraphMultisession(cg, lm2others; session, robot, user, numneighbors)
</code></pre><p>Return subgraph copy of type FactorGraph contaning values from session in lm2others, and Vector{Symbol} of primary key symbols used for graph exstraction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/MultisessionUtils.jl#L122-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.getPoseExVertexNeoIDs" href="#Caesar.getPoseExVertexNeoIDs"><code>Caesar.getPoseExVertexNeoIDs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getPoseExVertexNeoIDs(conn::Neo4j.Connection; ready, backendset, session, reqbackendset)
</code></pre><p>Return array of tuples with ExVertex IDs and Neo4j IDs for all poses.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L534-L538">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.getVertNeoIDs!" href="#Caesar.getVertNeoIDs!"><code>Caesar.getVertNeoIDs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getVertNeoIDs!(::CloudGraph, res::Dict{Symbol, Int}; session::AbstractString=&quot;NA&quot;, robot::AbstractString=&quot;NA&quot;, user::AbstractString=&quot;NA&quot;)</code></pre><p>Insert into and return dict <code>res</code> with Neo4j IDs of ExVertex labels as stored per session in Neo4j database.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L1015-L1019">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.getfirstpose" href="#Caesar.getfirstpose"><code>Caesar.getfirstpose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getfirstpose(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString)</code></pre><p>Return Tuple{Symbol, Int} of first pose symbol and Neo4j node ID.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L1059-L1063">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.getnewvertdict" href="#Caesar.getnewvertdict"><code>Caesar.getnewvertdict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getnewvertdict(conn, session::AbstractString, robot::AbstractString, user::AbstractString)</code></pre><p>Return a dictionary with frtend and mongo_keys json string information for :NEWDATA elements in Neo4j database.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/ConvertGeneralSlaminDB.jl#L22-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.getprpt2kde" href="#Caesar.getprpt2kde"><code>Caesar.getprpt2kde</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getprp2kde(::CloudGraph, neoids::Vector{Int}; N::Int=100)</code></pre><p>Return PriorPoint2DensityNH with N points based on beliefs of neoids, and equal share null hypothesis between length(neoids)+1 beliefs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/MultisessionUtils.jl#L74-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.hasBigDataElement" href="#Caesar.hasBigDataElement"><code>Caesar.hasBigDataElement</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hasBigDataElement(vertex::CloudGraphs.CloudVertex, description::AbstractString) -&gt; Bool
</code></pre><p>Return true if vertex has bigDataElements with matching description.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L892-L896">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.insertrobotdatafirstpose!" href="#Caesar.insertrobotdatafirstpose!"><code>Caesar.insertrobotdatafirstpose!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">insertrobotdatafirstpose!(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString, robotdict::Dict)</code></pre><p>Saves robotdict via JSON to first pose in a SESSION in the database. Used for storing general robot specific data in easily accessible manner. Can fetch later retrieve same dict with counterpart <code>fetchrobotdatafirstpose</code> function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L1087-L1093">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.removeNeo4jID" href="#Caesar.removeNeo4jID"><code>Caesar.removeNeo4jID</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">removeNeo4jID(cg::CloudGraph, neoid=-1)</code></pre><p>Remove node from Neo4j according to Neo4j Node ID. Big data elements that may be associated with this node are not removed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L1040-L1045">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.resetentireremotesession" href="#Caesar.resetentireremotesession"><code>Caesar.resetentireremotesession</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resetentireremotesession(conn, session, robot, user; segment)
</code></pre><p>match (n:session) remove n.backendset, n.ready, n.data, n.bigData, n.label, n.packedType, n.exVertexId, n.shape, n.width set n :NEWDATA return n</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/ConvertGeneralSlaminDB.jl#L372-L379">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.rmInstMultisessionPriors!" href="#Caesar.rmInstMultisessionPriors!"><code>Caesar.rmInstMultisessionPriors!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rmInstMultisessionPriors!(::CloudGraph; session&lt;:AbstractString=, multisessions::Vector{&lt;:AbstractString}= )</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/MultisessionUtils.jl#L195-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.standardcloudgraphsetup" href="#Caesar.standardcloudgraphsetup"><code>Caesar.standardcloudgraphsetup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">standardcloudgraphsetup(; addrdict, nparticles, drawdepth, drawedges, clearslamindb, multisession) -&gt; Tuple{CloudGraphs.CloudGraph,Dict{AbstractString,Any}}
</code></pre><p>Connect to databases via network according to addrdict, or ask user for credentials and return active cloudGraph object, as well as addrdict.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L845-L850">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.updatenewverts!" href="#Caesar.updatenewverts!"><code>Caesar.updatenewverts!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert vertices of session in Neo4j DB with Caesar.jl&#39;s required data elements in preparation for MM-iSAMCloudSolve process.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/ConvertGeneralSlaminDB.jl#L357-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.whosNear2D" href="#Caesar.whosNear2D"><code>Caesar.whosNear2D</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">whosNear2D(cg::CloudGraphs.CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString; x, y, yaw, dist, angle)
</code></pre><p>Find vertices near the point specified and return dictionary of symbol to Neo4j ID pairs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/FoveationUtils.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Caesar.whosNear3D" href="#Caesar.whosNear3D"><code>Caesar.whosNear3D</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">whosNear3D(cg::CloudGraphs.CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString; x, y, z, roll, pitch, yaw, dist, angle)
</code></pre><p>Find vertices near the point specified and return dictionary of symbol to Neo4j ID pairs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/FoveationUtils.jl#L43-L47">source</a></section><h3><a class="nav-anchor" id="RoME-1" href="#RoME-1">RoME</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RoME.getRangeKDEMax2D" href="#RoME.getRangeKDEMax2D"><code>RoME.getRangeKDEMax2D</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getRangeKDEMax2D(cgl::CloudGraph, session::AbstractString, vsym1::Symbol, vsym2::Symbol)</code></pre><p>Calculate the cartesian distange between two vertices in the graph, by session and symbol names, and by maximum belief point.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L1132-L1137">source</a><div><div><pre><code class="language-julia">getRangeKDEMax2D(fgl, vsym1, vsym2)
</code></pre><p>Calculate the cartesian distance between two vertices in the graph using their symbol name, and by maximum belief point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RoME.initFactorGraph!" href="#RoME.initFactorGraph!"><code>RoME.initFactorGraph!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Initialize a factor graph object as Pose2, Pose3, or neither and returns variable and factor symbols as array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RoME.addOdoFG!" href="#RoME.addOdoFG!"><code>RoME.addOdoFG!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">addOdoFG!(fg, n, DX, cov; N, ready, labels)
</code></pre><p>Create a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x&lt;k+1&gt; for new node new node and constraint factor are returned as a tuple.</p></div></div><div><div><pre><code class="language-julia">addOdoFG!(fgl, odo; N, ready, labels)
</code></pre><p>Create a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x&lt;k+1&gt; for new node new node and constraint factor are returned as a tuple.</p></div></div></section><h3><a class="nav-anchor" id="IncrementalInference-1" href="#IncrementalInference-1">IncrementalInference</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DistributedFactorGraphs.addVariable!" href="#DistributedFactorGraphs.addVariable!"><code>DistributedFactorGraphs.addVariable!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">addVariable!(dfg, lbl, softtype; N, autoinit, ready, dontmargin, labels, smalldata, checkduplicates)
</code></pre><p>Add a variable node <code>lbl::Symbol</code> to <code>fg::FactorGraph</code>, as <code>softtype&lt;:InferenceVariable</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">fg = initfg()
addVariable!(fg, :x0, Pose2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DistributedFactorGraphs.addFactor!" href="#DistributedFactorGraphs.addFactor!"><code>DistributedFactorGraphs.addFactor!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">addFactor!(dfg, Xi, usrfnc; multihypo, ready, labels, autoinit, threadmodel)
</code></pre><p>Add factor with user defined type &lt;: FunctorInferenceType to the factor graph object. Define whether the automatic initialization of variables should be performed.  Use order sensitive <code>multihypo</code> keyword argument to define if any variables are related to data association uncertainty.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>allnums</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.approxCliqMarginalUp!" href="#IncrementalInference.approxCliqMarginalUp!"><code>IncrementalInference.approxCliqMarginalUp!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">approxCliqMarginalUp!(fgl, treel, csym)
approxCliqMarginalUp!(fgl, treel, csym, onduplicate; N, dbg, iters, drawpdf, multiproc)
</code></pre><p>Approximate Chapman-Kolmogorov transit integral and return separator marginals as messages to pass up the Bayes (Junction) tree, along with additional clique operation values for debugging.</p><p>Notes</p><ul><li><code>onduplicate=true</code> by default internally uses deepcopy of factor graph and Bayes tree, and does <strong>not</strong> update the given objects.  Set false to update <code>fgl</code> and <code>treel</code> during compute.</li></ul><p>Future</p><ul><li>TODO: function internally is too long and needs to be refactored for maintainability.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.approxConv" href="#IncrementalInference.approxConv"><code>IncrementalInference.approxConv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">approxConv(dfg, fct, towards; N)
</code></pre><p>Draw samples from the approximate convolution of <code>towards</code> symbol using factor <code>fct</code> relative to the other variables.  In addition the <code>api</code> can be adjusted to recover the data from elsewhere (likely to be replaced/removed in the future).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.areCliqChildrenNeedDownMsg" href="#IncrementalInference.areCliqChildrenNeedDownMsg"><code>IncrementalInference.areCliqChildrenNeedDownMsg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">areCliqChildrenNeedDownMsg(children)
</code></pre><p>Return <code>true</code> if any of the children cliques have status <code>:needdownmsg</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.areCliqVariablesAllMarginalized" href="#IncrementalInference.areCliqVariablesAllMarginalized"><code>IncrementalInference.areCliqVariablesAllMarginalized</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">areCliqVariablesAllMarginalized(subfg, cliq)
</code></pre><p>Return true if all variables in clique are considered marginalized (and initialized).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.batchSolve!" href="#IncrementalInference.batchSolve!"><code>IncrementalInference.batchSolve!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">batchSolve!(dfg)
batchSolve!(dfg, oldtree; upsolve, downsolve, drawpdf, show, N, recursive, dbg, treeinit, incremental, limititers, skipcliqids, recordcliqs, returntasks)
</code></pre><p>Perform multimodal incremental smoothing and mapping (mm-iSAM) computations over given factor graph <code>fgl::FactorGraph</code> on the local computer.  A pdf of the Bayes (Junction) tree will be generated in the working folder with <code>drawpdf=true</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.blockCliqUntilChildrenHaveUpStatus" href="#IncrementalInference.blockCliqUntilChildrenHaveUpStatus"><code>IncrementalInference.blockCliqUntilChildrenHaveUpStatus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">blockCliqUntilChildrenHaveUpStatus(tree, prnt)
</code></pre><p>Block the thread until child cliques of <code>prnt::Graphs.ExVertex</code> have finished attempting upward initialization – i.e. have status result. Return <code>::Dict{Symbol}</code> indicating whether next action that should be taken for each child clique.</p><p>Notes:</p><ul><li>See status options at <code>getCliqStatusUp(..)</code>.</li><li>Can be called multiple times</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.buildSubgraphFromLabels" href="#IncrementalInference.buildSubgraphFromLabels"><code>IncrementalInference.buildSubgraphFromLabels</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">buildSubgraphFromLabels(dfg, syms)
</code></pre><p>Construct a new factor graph object as a subgraph of <code>fgl::FactorGraph</code> based on the variable labels <code>syms::Vector{Symbols}</code>.</p><p>Notes</p><ul><li>Slighly messy internals, but gets the job done – some room for performance improvement.</li></ul><p>Related</p><p>getVariableIds</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.buildTreeFromOrdering!" href="#IncrementalInference.buildTreeFromOrdering!"><code>IncrementalInference.buildTreeFromOrdering!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Build Bayes/Junction/Elimination tree from a given variable ordering.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.buildCliqSubgraphDown" href="#IncrementalInference.buildCliqSubgraphDown"><code>IncrementalInference.buildCliqSubgraphDown</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">buildCliqSubgraphDown(fgl, treel, cliqsym)
buildCliqSubgraphDown(fgl, treel, cliqsym, varsym)
</code></pre><p>Build a new subgraph from <code>fgl::FactorGraph</code> containing all variables and factors associated with <code>cliq</code>.  Additionally add the upward message prior factors as needed for belief propagation (inference).</p><p>Notes</p><ul><li><code>cliqsym::Symbol</code> defines the cliq where variable appears as a frontal variable.</li><li><code>varsym::Symbol</code> defaults to the cliq frontal variable definition but can in case a separator variable is required instead.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.buildCliqSubgraphUp" href="#IncrementalInference.buildCliqSubgraphUp"><code>IncrementalInference.buildCliqSubgraphUp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">buildCliqSubgraphUp(fgl, treel, cliqsym)
buildCliqSubgraphUp(fgl, treel, cliqsym, varsym)
</code></pre><p>Build a new subgraph from <code>fgl::FactorGraph</code> containing all variables and factors associated with <code>cliq</code>.  Additionally add the upward message prior factors as needed for belief propagation (inference).</p><p>Notes</p><ul><li><code>cliqsym::Symbol</code> defines the cliq where variable appears as a frontal variable.</li><li><code>varsym::Symbol</code> defaults to the cliq frontal variable definition but can in case a separator variable is required instead.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.childCliqs" href="#IncrementalInference.childCliqs"><code>IncrementalInference.childCliqs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">childCliqs(treel, cliq)
</code></pre><p>Return a vector of child cliques to <code>cliq</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.cliqGibbs" href="#IncrementalInference.cliqGibbs"><code>IncrementalInference.cliqGibbs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cliqGibbs(fg, cliq, vsym, inmsgs, N, dbg, manis)
</code></pre><p>Perform one step of the minibatch clique Gibbs operation for solving the Chapman-Kolmogov trasit integral – here involving separate approximate functional convolution and product operations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.cliqHistFilterTransitions" href="#IncrementalInference.cliqHistFilterTransitions"><code>IncrementalInference.cliqHistFilterTransitions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cliqHistFilterTransitions(hist, nextfnc)
</code></pre><p>Return state machine transition steps from history such that the <code>nextfnc::Function</code>.</p><p>Related:</p><p>getCliqSolveHistory, printCliqHistorySummary, filterHistAllToArray, sandboxCliqResolveStep</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>cliqInitSolveUp!</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.compareAllVariables" href="#IncrementalInference.compareAllVariables"><code>IncrementalInference.compareAllVariables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compareAllVariables(fgA, fgB; show, skipsamples)
</code></pre><p>Compare all variables in both <code>::FactorGraph</code>s A and B.</p><p>Notes</p><ul><li>A and B should all the same variables and factors.</li></ul><p>Related:</p><p><code>compareFactorGraphs</code>, <code>compareSimilarVariables</code>, <code>compareVariable</code>, <code>ls</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.compareFactorGraphs" href="#IncrementalInference.compareFactorGraphs"><code>IncrementalInference.compareFactorGraphs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compare and return if two factor graph objects are the same, by comparing similar variables and factors.</p><p>Notes:</p><ul><li>Default items to skip with <code>skipsamples</code>, <code>skipcompute</code>.</li><li>User defined fields to skip can be specified with <code>skip::Vector{Symbol}</code>.</li></ul><p>Related:</p><p><code>compareSimilarVariables</code>, <code>compareSimilarFactors</code>, <code>compareAllVariables</code>, <code>ls</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.compareSimilarFactors" href="#IncrementalInference.compareSimilarFactors"><code>IncrementalInference.compareSimilarFactors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compare similar factors between <code>::FactorGraph</code>s A and B.</p><p>Related:</p><p><code>compareFactorGraphs</code>, <code>compareSimilarVariables</code>, <code>compareAllVariables</code>, <code>ls</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.compareSimilarVariables" href="#IncrementalInference.compareSimilarVariables"><code>IncrementalInference.compareSimilarVariables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Compare similar labels between <code>::FactorGraph</code>s A and B.</p><p>Notes</p><ul><li>At least one variable label should exist in both A and B.</li></ul><p>Related:</p><p><code>compareFactorGraphs</code>, <code>compareAllVariables</code>, <code>compareSimilarFactors</code>, <code>compareVariable</code>, <code>ls</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.compareSubsetFactorGraph" href="#IncrementalInference.compareSubsetFactorGraph"><code>IncrementalInference.compareSubsetFactorGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compareSubsetFactorGraph(fgS, fgA; api)
</code></pre><p>Determine if and compare <code>fgS::FactorGraph</code> is a subset with similar content to <code>fgA</code>.</p><p>Notes</p><ul><li><code>fgS</code> ⊆ <code>fgA</code>.</li></ul><p>Related:</p><p><code>compareFactorGraphs</code>, <code>compareSimilarVariables</code>, <code>compareSimilarFactors</code>, <code>ls</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.compareVariable" href="#IncrementalInference.compareVariable"><code>IncrementalInference.compareVariable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compareVariable(A, B; show, skipsamples)
</code></pre><p>Compare that all fields are the same in a <code>::FactorGraph</code> variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.convert2packedfunctionnode" href="#IncrementalInference.convert2packedfunctionnode"><code>IncrementalInference.convert2packedfunctionnode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Encode complicated function node type to related &#39;Packed&lt;type&gt;&#39; format assuming a user supplied convert function .</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.cycleInitByVarOrder!" href="#IncrementalInference.cycleInitByVarOrder!"><code>IncrementalInference.cycleInitByVarOrder!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Cycle through var order and initialize variables as possible in <code>subfg::FactorGraph</code>. Return true if something was updated.</p><p>Notes:</p><ul><li>assumed <code>subfg</code> is a subgraph containing only the factors that can be used.<ul><li>including the required up or down messages</li></ul></li><li>intended for both up and down initialization operations.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.decodefg" href="#IncrementalInference.decodefg"><code>IncrementalInference.decodefg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">decodefg(fgs; api)
</code></pre><p>Unpack PackedFunctionNodeData formats back to regular FunctonNodeData.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>deleteFactor!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>deleteVariable!</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.doautoinit!" href="#IncrementalInference.doautoinit!"><code>IncrementalInference.doautoinit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">doautoinit!(dfg, xi; singles, N)
</code></pre><p>EXPERIMENTAL: initialize target variable <code>xi</code> based on connected factors in the factor graph <code>fgl</code>.  Possibly called from <code>addFactor!</code>, or <code>doCliqAutoInitUp!</code>.</p><p>Development Notes:</p><blockquote><p>Target factor is first (singletons) or second (dim 2 pairwise) variable vertex in <code>xi</code>.</p></blockquote><ul><li>TODO use DFG properly with local operations and DB update at end.</li><li>TODO get faster version of <code>isInitialized</code> for database version.</li><li>TODO: Persist this back if we want to here.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.doCliqAutoInitUp!" href="#IncrementalInference.doCliqAutoInitUp!"><code>IncrementalInference.doCliqAutoInitUp!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">doCliqAutoInitUp!(subfg, tree, cliq; up_solve_if_able, multiprocess)
</code></pre><p>Perform cliq initalization calculation based on current state of the tree and factor graph, using upward message passing logic.</p><blockquote><p>NOTE WORK IN PROGRESS</p></blockquote><p>Notes</p><ul><li>Return either of (:initialized, :upsolved, :needdownmsg, :badinit)</li><li>must use factors in cliq only, ensured by using subgraph – TODO general case.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.doCliqUpSolve!" href="#IncrementalInference.doCliqUpSolve!"><code>IncrementalInference.doCliqUpSolve!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Update <code>subfg&lt;:AbstractDFG</code> according to internal computations for a full upsolve.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>downGibbsCliqueDensity</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.downMsgPassingRecursive" href="#IncrementalInference.downMsgPassingRecursive"><code>IncrementalInference.downMsgPassingRecursive</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Pass NBPMessages back down the tree – pre order tree traversal.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.drawCliqSubgraphUp" href="#IncrementalInference.drawCliqSubgraphUp"><code>IncrementalInference.drawCliqSubgraphUp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">drawCliqSubgraphUp(fgl, treel, frontalSym; show, filepath, engine, viewerapp)
</code></pre><p>Construct and draw the subgraph associated with clique <code>frontalSym::Symbol</code>.</p><p>Notes</p><ul><li>See <code>writeGraphPdf</code> for details on keyword options.</li></ul><p>Related</p><p>writeGraphPdf, buildCliqSubgraphUp, buildSubgraphFromLabels, spyCliqMat, drawTree</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.dwnMsg" href="#IncrementalInference.dwnMsg"><code>IncrementalInference.dwnMsg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dwnMsg(cliq)
</code></pre><p>Return the last down message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.encodefg" href="#IncrementalInference.encodefg"><code>IncrementalInference.encodefg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Make a full memory copy of the graph and encode all composite function node types – assuming that convert methods for &#39;Packed&lt;type&gt;&#39; formats exist.  The same converters are used for database persistence with CloudGraphs.jl.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.fifoFreeze!" href="#IncrementalInference.fifoFreeze!"><code>IncrementalInference.fifoFreeze!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Freeze nodes that are older than the quasi fixed-lag length defined by <code>fg.qfl</code>, according to <code>fg.fifo</code> ordering.</p><p>Future:</p><ul><li>Allow different freezing strategies beyond fifo.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.filterHistAllToArray" href="#IncrementalInference.filterHistAllToArray"><code>IncrementalInference.filterHistAllToArray</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">filterHistAllToArray(tree, frontals, nextfnc)
</code></pre><p>Return state machine transition steps from all cliq histories with transition <code>nextfnc::Function</code>.</p><p>Related:</p><p>getCliqSolveHistory, printCliqHistorySummary, cliqHistFilterTransitions, sandboxCliqResolveStep</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.findRelatedFromPotential" href="#IncrementalInference.findRelatedFromPotential"><code>IncrementalInference.findRelatedFromPotential</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">findRelatedFromPotential(dfg, idfct, vertlabel, N)
findRelatedFromPotential(dfg, idfct, vertlabel, N, dbg)
</code></pre><p>Compute proposal belief on <code>vertid</code> through <code>idfct</code> representing some constraint in factor graph. Always full dimension variable node – partial constraints will only influence subset of variable dimensions. The remaining dimensions will keep pre-existing variable values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.fmcmc!" href="#IncrementalInference.fmcmc!"><code>IncrementalInference.fmcmc!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter)
fmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter, dbg)
fmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter, dbg, api)
</code></pre><p>Iterate successive approximations of clique marginal beliefs by means of the stipulated proposal convolutions and products of the functional objects for tree clique <code>cliq</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliq" href="#IncrementalInference.getCliq"><code>IncrementalInference.getCliq</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliq(bt, frt)
</code></pre><p>Return the Graphs.ExVertex node object that represents a clique in the Bayes (Junction) tree, as defined by one of the frontal variables <code>frt::Symbol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqChildMsgsUp" href="#IncrementalInference.getCliqChildMsgsUp"><code>IncrementalInference.getCliqChildMsgsUp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqChildMsgsUp(fg_, treel, cliq, ?)
</code></pre><p>Get and return upward belief messages as stored in child cliques from <code>treel::BayesTree</code>.</p><p>Notes</p><ul><li>Use last parameter to select the return format.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqDownMsgsAfterDownSolve" href="#IncrementalInference.getCliqDownMsgsAfterDownSolve"><code>IncrementalInference.getCliqDownMsgsAfterDownSolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return dictionary of down messages consisting of all frontal and separator beliefs of this clique.</p><p>Notes:</p><ul><li>Fetches numerical results from <code>subdfg</code> as dictated in <code>cliq</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqMsgsDown" href="#IncrementalInference.getCliqMsgsDown"><code>IncrementalInference.getCliqMsgsDown</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqMsgsDown(cliql)
</code></pre><p>Return the last down message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqMsgsUp" href="#IncrementalInference.getCliqMsgsUp"><code>IncrementalInference.getCliqMsgsUp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqMsgsUp(cliql)
</code></pre><p>Return the last up message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqParentMsgDown" href="#IncrementalInference.getCliqParentMsgDown"><code>IncrementalInference.getCliqParentMsgDown</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqParentMsgDown(treel, cliq)
</code></pre><p>Get the latest down message from the parent node (without calculating anything).</p><p>Notes</p><ul><li>Different from down initialization messages that do calculate new values – see <code>prepCliqInitMsgsDown!</code>.</li><li>Basically converts function <code>getDwnMsgs</code> from <code>Dict{Symbol,BallTreeDensity}</code> to <code>Dict{Symbol,Vector{BallTreeDensity}}</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqSiblings" href="#IncrementalInference.getCliqSiblings"><code>IncrementalInference.getCliqSiblings</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqSiblings(treel, cliq)
getCliqSiblings(treel, cliq, inclusive)
</code></pre><p>Return a vector of all siblings to a clique, which defaults to not <code>inclusive</code> the calling <code>cliq</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqSolveHistory" href="#IncrementalInference.getCliqSolveHistory"><code>IncrementalInference.getCliqSolveHistory</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqSolveHistory(cliq)
</code></pre><p>Return clique state machine history from <code>tree</code> if it was solved with <code>recordcliqs</code>.</p><p>Notes</p><ul><li>Cliques are identified by front variable <code>::Symbol</code> which are always unique across the cliques.</li></ul></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>getCliq</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqOrderUpSolve" href="#IncrementalInference.getCliqOrderUpSolve"><code>IncrementalInference.getCliqOrderUpSolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqOrderUpSolve(treel)
getCliqOrderUpSolve(treel, startcliq)
</code></pre><p>Return clique pointers for the given order in which they will be solved (sequentially).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqAllVarIds" href="#IncrementalInference.getCliqAllVarIds"><code>IncrementalInference.getCliqAllVarIds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqAllVarIds(cliq)
</code></pre><p>Get all <code>cliq</code> variable ids<code>::Int</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqAllVarSyms" href="#IncrementalInference.getCliqAllVarSyms"><code>IncrementalInference.getCliqAllVarSyms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Get all <code>cliq</code> variable labels as <code>::Symbol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqAssocMat" href="#IncrementalInference.getCliqAssocMat"><code>IncrementalInference.getCliqAssocMat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqAssocMat(cliq)
</code></pre><p>Return boolean matrix of factor by variable (row by column) associations within clique, corresponds to order presented by <code>getCliqFactorIds</code> and <code>getCliqAllVarIds</code>.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>getCliqChildMsgsUp</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqFrontalVarIds" href="#IncrementalInference.getCliqFrontalVarIds"><code>IncrementalInference.getCliqFrontalVarIds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqFrontalVarIds(cliqdata)
</code></pre><p>Get the frontal variable IDs <code>::Int</code> for a given clique in a Bayes (Junction) tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqInitVarOrderUp" href="#IncrementalInference.getCliqInitVarOrderUp"><code>IncrementalInference.getCliqInitVarOrderUp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqInitVarOrderUp(cliq)
</code></pre><p>Return the most likely  ordering for initializing factor (assuming up solve sequence).</p><p>Notes:</p><ul><li>sorts id for increasing number of connected factors.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqMat" href="#IncrementalInference.getCliqMat"><code>IncrementalInference.getCliqMat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqMat(cliq; showmsg)
</code></pre><p>Return boolean matrix of factor variable associations for a clique, optionally including (<code>showmsg::Bool=true</code>) the upward message singletons.  Variable order corresponds to <code>getCliqAllVarIds</code>.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>getCliqOrderUpSolve</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqSeparatorVarIds" href="#IncrementalInference.getCliqSeparatorVarIds"><code>IncrementalInference.getCliqSeparatorVarIds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqSeparatorVarIds(cliqdata)
</code></pre><p>Get <code>cliq</code> separator (a.k.a. conditional) variable ids<code>::Symbol</code>.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>getCliqStatusUp</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqVarIdsPriors" href="#IncrementalInference.getCliqVarIdsPriors"><code>IncrementalInference.getCliqVarIdsPriors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqVarIdsPriors(cliq)
getCliqVarIdsPriors(cliq, allids)
getCliqVarIdsPriors(cliq, allids, partials)
</code></pre><p>Get variable ids<code>::Int</code> with prior factors associated with this <code>cliq</code>.</p><p>Notes:</p><ul><li>does not include any singleton messages from upward or downward message passing.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqVars" href="#IncrementalInference.getCliqVars"><code>IncrementalInference.getCliqVars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqVars(subfg, cliq)
</code></pre><p>Return array of all variable vertices in a clique.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCliqVarSingletons" href="#IncrementalInference.getCliqVarSingletons"><code>IncrementalInference.getCliqVarSingletons</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCliqVarSingletons(cliq)
getCliqVarSingletons(cliq, allids)
getCliqVarSingletons(cliq, allids, partials)
</code></pre><p>Get <code>cliq</code> variable IDs with singleton factors – i.e. both in clique priors and up messages.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCurrentWorkspaceFactors" href="#IncrementalInference.getCurrentWorkspaceFactors"><code>IncrementalInference.getCurrentWorkspaceFactors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCurrentWorkspaceFactors()
</code></pre><p>Return all factors currently registered in the workspace.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getCurrentWorkspaceVariables" href="#IncrementalInference.getCurrentWorkspaceVariables"><code>IncrementalInference.getCurrentWorkspaceVariables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getCurrentWorkspaceVariables()
</code></pre><p>Return all variables currently registered in the workspace.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getData" href="#IncrementalInference.getData"><code>IncrementalInference.getData</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getData(v)
</code></pre><p>Retrieve data structure stored in a node.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>getFactor</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getKDE" href="#IncrementalInference.getKDE"><code>IncrementalInference.getKDE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getKDE(v)
</code></pre><p>Get KernelDensityEstimate kde estimate stored in variable node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getManifolds" href="#IncrementalInference.getManifolds"><code>IncrementalInference.getManifolds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getManifolds(v; solveKey)
</code></pre><p>Return the manifolds on which variable <code>sym::Symbol</code> is defined.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>getMaxVertId</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getParent" href="#IncrementalInference.getParent"><code>IncrementalInference.getParent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getParent(treel, afrontal)
</code></pre><p>Return <code>cliq</code>&#39;s parent clique.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getSofttype" href="#IncrementalInference.getSofttype"><code>IncrementalInference.getSofttype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getSofttype(vnd)
</code></pre><p>Variable nodes softtype information holding a variety of meta data associated with the type of variable stored in that node of the factor graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getTreeAllFrontalSyms" href="#IncrementalInference.getTreeAllFrontalSyms"><code>IncrementalInference.getTreeAllFrontalSyms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getTreeAllFrontalSyms(fgl, tree)
</code></pre><p>Return one symbol (a frontal variable) from each clique in the <code>::BayesTree</code>.</p><p>Notes</p><ul><li>Frontal variables only occur once in a clique per tree, therefore is a unique identifier.</li></ul><p>Related:</p><p>whichCliq, printCliqHistorySummary</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getTreeCliqSolveOrderUp" href="#IncrementalInference.getTreeCliqSolveOrderUp"><code>IncrementalInference.getTreeCliqSolveOrderUp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getTreeCliqSolveOrderUp(treel)
getTreeCliqSolveOrderUp(treel, startcliq)
</code></pre><p>Return clique pointers for the given order in which they will be solved (sequentially).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getVal" href="#IncrementalInference.getVal"><code>IncrementalInference.getVal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getVal(v; solveKey)
</code></pre><p>Convenience function to get point values sampled i.i.d from marginal of <code>lbl</code> variable in the current factor graph.</p></div></div><div><div><pre><code class="language-julia">getVal(vA)
getVal(vA, solveKey)
</code></pre><p>Fetch the variable marginal sample points without the KDE bandwidth parameter.  Use getVertKDE to retrieve the full KDE object.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>getVariable</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getVertKDE" href="#IncrementalInference.getVertKDE"><code>IncrementalInference.getVertKDE</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getVertKDE(v)
</code></pre><p>Get KernelDensityEstimate kde estimate stored in variable node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getUpMsgs" href="#IncrementalInference.getUpMsgs"><code>IncrementalInference.getUpMsgs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getUpMsgs(cliql)
</code></pre><p>Return the last up message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.getDwnMsgs" href="#IncrementalInference.getDwnMsgs"><code>IncrementalInference.getDwnMsgs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getDwnMsgs(cliql)
</code></pre><p>Return the last down message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DistributedFactorGraphs.hasOrphans" href="#DistributedFactorGraphs.hasOrphans"><code>DistributedFactorGraphs.hasOrphans</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hasOrphans(fg)
</code></pre><p>Return <code>::Bool</code> on whether <code>fg::FactorGraph</code> has orphaned nodes or graph fragments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.inferOverTree!" href="#IncrementalInference.inferOverTree!"><code>IncrementalInference.inferOverTree!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Perform up and down message passing (multi-process) algorithm for full sum-product solution of all continuous marginal beliefs.</p><p>Notes</p><ul><li>For legacy versions of tree traversal, see <code>inferOverTreeIterative!</code> instead.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.inferOverTreeR!" href="#IncrementalInference.inferOverTreeR!"><code>IncrementalInference.inferOverTreeR!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Perform up and down message passing (single process, recursive) algorithm for full sum-product solution of all continuous marginal beliefs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.initfg" href="#IncrementalInference.initfg"><code>IncrementalInference.initfg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">initfg()
initfg(dfg; sessionname, robotname, username, cloudgraph)
</code></pre><p>Initialize an empty in-memory DistributedFactorGraph <code>::DistributedFactorGraph</code> object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.initInferTreeUp!" href="#IncrementalInference.initInferTreeUp!"><code>IncrementalInference.initInferTreeUp!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Perform tree based initialization of all variables not yet initialized in factor graph.</p><p>Related</p><p>asyncTreeInferUp!</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>initOnTree!</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.isCliqMarginalizedFromVars" href="#IncrementalInference.isCliqMarginalizedFromVars"><code>IncrementalInference.isCliqMarginalizedFromVars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isCliqMarginalizedFromVars(subfg, cliq)
</code></pre><p>Return <code>::Bool</code> on whether all variables in this <code>cliq</code> are marginalzed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.isCliqReadyInferenceUp" href="#IncrementalInference.isCliqReadyInferenceUp"><code>IncrementalInference.isCliqReadyInferenceUp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isCliqReadyInferenceUp(fgl, tree, cliq)
</code></pre><p>Determine if this <code>cliq</code> has been fully initialized and child cliques have completed their full upward inference.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.isFactor" href="#IncrementalInference.isFactor"><code>IncrementalInference.isFactor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return whether <code>sym::Symbol</code> represents a factor vertex in the graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DistributedFactorGraphs.isInitialized" href="#DistributedFactorGraphs.isInitialized"><code>DistributedFactorGraphs.isInitialized</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isInitialized(vert)
</code></pre><p>Returns state of vertex data <code>.initialized</code> flag.</p><p>Notes:</p><ul><li>used by Bayes tree clique logic.</li><li>similar method in DFG</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.isMarginalized" href="#IncrementalInference.isMarginalized"><code>IncrementalInference.isMarginalized</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isMarginalized(vert)
</code></pre><p>Return <code>::Bool</code> on whether this variable has been marginalized.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.isTreeSolved" href="#IncrementalInference.isTreeSolved"><code>IncrementalInference.isTreeSolved</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isTreeSolved(treel; skipinitialized)
</code></pre><p>Return true or false depending on whether the tree has been fully initialized/solved/marginalized.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.isPartial" href="#IncrementalInference.isPartial"><code>IncrementalInference.isPartial</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isPartial(fcf)
</code></pre><p>Return <code>::Bool</code> on whether factor is a partial constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.isVariable" href="#IncrementalInference.isVariable"><code>IncrementalInference.isVariable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return whether <code>sym::Symbol</code> represents a variable vertex in the graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.landmarks" href="#IncrementalInference.landmarks"><code>IncrementalInference.landmarks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">landmarks(fgl, vsym)
</code></pre><p>Return <code>Vector{Symbol}</code> of landmarks attached to vertex vsym in <code>fgl::FactorGraph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.loadjld" href="#IncrementalInference.loadjld"><code>IncrementalInference.loadjld</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">loadjld(; file)
</code></pre><p>Opposite of savejld(fg, gt=gt, file=&quot;tempfg.jl&quot;) to load data from file. This function uses the unpacking converters for converting all PackedInferenceType to FunctorInferenceType.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.localProduct" href="#IncrementalInference.localProduct"><code>IncrementalInference.localProduct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Using factor graph object <code>dfg</code>, project belief through connected factors (convolution with conditional) to variable <code>sym</code> followed by a approximate functional product.</p><p>Return: product belief, full proposals, partial dimension proposals, labels</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DistributedFactorGraphs.ls" href="#DistributedFactorGraphs.ls"><code>DistributedFactorGraphs.ls</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ls(cgl::CloudGraphs.CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString; sym, neoid, exvid) -&gt; Dict{Symbol,Tuple{Int64,Int64,Array{Symbol,1}}}
</code></pre><p>List neighbors to node in cgl::CloudGraph by returning Dict{Sym}=(exvid, neoid, Symbol[labels]), and can take any of the three as input node identifier. Not specifying an identifier will result in all Variable nodes being returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/1668310a781deda174ce06933cdd465f901259af/src/cloudgraphs/CloudGraphIntegration.jl#L145-L151">source</a><div><div><pre><code class="language-julia">ls(fgl, lbl; api, ring)
</code></pre><p>Return all elements <code>ls(fg)</code> as tuples, or nodes connected to the a specific element, eg. `ls(fg, :x1)</p></div></div><div><div><pre><code class="language-julia">ls(fgl, lbls; api, ring)
</code></pre><p>Experimental union of elements version of ls(::FactorGraph, ::Symbol).  Not mean&#39;t to replace broadcasting <code>ls.(fg, [:x1;:x2])</code></p></div></div><div><div><pre><code class="language-julia">ls(fgl; key1, key2)
</code></pre><p>List the nodes in a factor graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">ls(fg)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DistributedFactorGraphs.lsf" href="#DistributedFactorGraphs.lsf"><code>DistributedFactorGraphs.lsf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lsf(fgl, lbl; api)
</code></pre><p>List factors in a factor graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">lsf(fg, :x1)</code></pre></div></div><div><div><pre><code class="language-julia">lsf(fgl, lbl)
</code></pre><p>List factors in a factor graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">lsf(fg)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.lsRear" href="#IncrementalInference.lsRear"><code>IncrementalInference.lsRear</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lsRear(fgl)
lsRear(fgl, n)
</code></pre><p>Return array of all variable nodes connected to the last <code>n</code> many poses (<code>:x*</code>).</p><p>Example:</p><pre><code class="language-julia"># Shallow copy the tail end of poses from a factor graph `fg1`
vars = lsRear(fg1, 5)
fg1_r5 = subgraphFromVerts(fg1, vars)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.manualinit!" href="#IncrementalInference.manualinit!"><code>IncrementalInference.manualinit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">manualinit!(dfg, vert, pX)
</code></pre><p>Workaround function when first-version (factor graph based) auto initialization fails.  Usually occurs when using factors that have high connectivity to multiple variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.parentCliq" href="#IncrementalInference.parentCliq"><code>IncrementalInference.parentCliq</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">parentCliq(treel, cliq)
</code></pre><p>Return <code>cliq</code>&#39;s parent clique.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.packFromLocalPotentials!" href="#IncrementalInference.packFromLocalPotentials!"><code>IncrementalInference.packFromLocalPotentials!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">packFromLocalPotentials!(dfg, dens, wfac, cliq, vsym, N)
packFromLocalPotentials!(dfg, dens, wfac, cliq, vsym, N, dbg)
</code></pre><p>Add all potentials associated with this clique and vertid to dens.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.prepBatchTree!" href="#IncrementalInference.prepBatchTree!"><code>IncrementalInference.prepBatchTree!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Build Bayes/Junction/Elimination tree.</p><p>Notes</p><ul><li>Default to free qr factorization for variable elimination order.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.prepCliqInitMsgsDown!" href="#IncrementalInference.prepCliqInitMsgsDown!"><code>IncrementalInference.prepCliqInitMsgsDown!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Initialization downward message passing is different from regular inference since it is possible that none of the child cliq variables have been initialized.</p><p>Notes</p><ul><li>init msgs from child upward passes are individually stored in this <code>cliq</code>.</li><li>fresh product of overlapping beliefs are calculated on each function call.</li></ul></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>prepCliqInitMsgsUp!</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.printCliqHistorySummary" href="#IncrementalInference.printCliqHistorySummary"><code>IncrementalInference.printCliqHistorySummary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">printCliqHistorySummary(fid, hist)
</code></pre><p>Print a short summary of state machine history for a clique solve.</p><p>Related:</p><p>getTreeAllFrontalSyms, getCliqSolveHistory, animateCliqStateMachines</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.printgraphmax" href="#IncrementalInference.printgraphmax"><code>IncrementalInference.printgraphmax</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">printgraphmax(fgl)
</code></pre><p>Print the maximum point values form all variables approximate marginals in the factor graph. The full marginal can be recovered for example <code>X0 = getVertKDE(fg, :x0)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.productpartials!" href="#IncrementalInference.productpartials!"><code>IncrementalInference.productpartials!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">productpartials!(pGM, dummy, partials, manis)
</code></pre><p>Multiply different dimensions from partial constraints individually.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.prodmultiplefullpartials" href="#IncrementalInference.prodmultiplefullpartials"><code>IncrementalInference.prodmultiplefullpartials</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">prodmultiplefullpartials(dens, partials, Ndims, N, manis)
</code></pre><p>Multiply various full and partial dimension constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.prodmultipleonefullpartials" href="#IncrementalInference.prodmultipleonefullpartials"><code>IncrementalInference.prodmultipleonefullpartials</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Multiply a single full and several partial dimension constraints.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.resetBuildTreeFromOrder!" href="#IncrementalInference.resetBuildTreeFromOrder!"><code>IncrementalInference.resetBuildTreeFromOrder!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resetBuildTreeFromOrder!(fgl, p)
</code></pre><p>Reset factor graph and build a new tree from the provided variable ordering <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.resetData!" href="#IncrementalInference.resetData!"><code>IncrementalInference.resetData!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resetData!(vdata)
</code></pre><p>Partial reset of basic data fields in <code>::VariableNodeData</code> of <code>::FunctionNode</code> structures.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.resetTreeCliquesForUpSolve!" href="#IncrementalInference.resetTreeCliquesForUpSolve!"><code>IncrementalInference.resetTreeCliquesForUpSolve!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resetTreeCliquesForUpSolve!(treel)
</code></pre><p>Reset the Bayes (Junction) tree so that a new upsolve can be performed.</p><p>Notes</p><ul><li>Will change previous clique status from <code>:downsolved</code> to <code>:initialized</code> only.</li><li>Sets the color of tree clique to <code>lightgreen</code>.</li></ul></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>sandboxStateMachineStep</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.sandboxCliqResolveStep" href="#IncrementalInference.sandboxCliqResolveStep"><code>IncrementalInference.sandboxCliqResolveStep</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sandboxCliqResolveStep(tree, frontal, step)
</code></pre><p>Repeat a solver state machine step without changing history or primary values.</p><p>printCliqHistorySummary, getCliqSolveHistory, cliqHistFilterTransitions</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.savejld" href="#IncrementalInference.savejld"><code>IncrementalInference.savejld</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Save mostly complete Factor Graph type by converting complicated FunctionNodeData types to &#39;Packed&#39; types using user supplied converters. Ground truth can also be saved and recovered by the associated loadjld(file=&quot;tempfg.jld2&quot;) method.</p><p>Notes:</p><ul><li>Must use <code>.jld2</code> since Julia 1.0 (previous version was deprecated).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.setCliqAsMarginalized!" href="#IncrementalInference.setCliqAsMarginalized!"><code>IncrementalInference.setCliqAsMarginalized!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setCliqAsMarginalized!(cliq, status)
</code></pre><p>Set the marginalized status of a clique.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.setCliqStatus!" href="#IncrementalInference.setCliqStatus!"><code>IncrementalInference.setCliqStatus!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setCliqStatus!(cliq, status)
</code></pre><p>Set up initialization or solve status of this <code>cliq</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.setDwnMsg!" href="#IncrementalInference.setDwnMsg!"><code>IncrementalInference.setDwnMsg!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setDwnMsg!(cliql, msgs)
</code></pre><p>Set the downward passing message for Bayes (Junction) tree clique <code>cliql</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.setfreeze!" href="#IncrementalInference.setfreeze!"><code>IncrementalInference.setfreeze!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Set variable(s) <code>sym</code> of factor graph to be marginalized – i.e. not be updated by inference computation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.setTreeCliquesMarginalized!" href="#IncrementalInference.setTreeCliquesMarginalized!"><code>IncrementalInference.setTreeCliquesMarginalized!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Set all Bayes (Junction) tree cliques that have all marginalized and initialized variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.setValKDE!" href="#IncrementalInference.setValKDE!"><code>IncrementalInference.setValKDE!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setValKDE!(v, val)
setValKDE!(v, val, setinit)
setValKDE!(v, val, setinit, partialinit; solveKey)
</code></pre><p>Set the point centers and bandwidth parameters of a variable node, also set <code>isInitialized=true</code> if <code>setinit::Bool=true</code> (as per default).</p><p>Notes</p><ul><li><code>initialized</code> is used for initial solve of factor graph where variables are not yet initialized.</li><li><code>partialinit</code> is used to identify if the initialized was only partial.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.setUpMsg!" href="#IncrementalInference.setUpMsg!"><code>IncrementalInference.setUpMsg!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setUpMsg!(cliql, msgs)
</code></pre><p>Set the upward passing message for Bayes (Junction) tree clique <code>cliql</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.showVariable" href="#IncrementalInference.showVariable"><code>IncrementalInference.showVariable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Display the content of <code>VariableNodeData</code> to console for a given factor graph and variable tag<code>::Symbol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.solveCliqWithStateMachine!" href="#IncrementalInference.solveCliqWithStateMachine!"><code>IncrementalInference.solveCliqWithStateMachine!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solveCliqWithStateMachine!(dfg, tree, frontal; iters, downsolve, recordhistory, verbose, nextfnc, prevcsmc)
</code></pre><p>Standalone state machine solution for a single clique.</p><p>Related:</p><p>initInferTreeUp!</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>subgraphFromVerts</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.transferUpdateSubGraph!" href="#IncrementalInference.transferUpdateSubGraph!"><code>IncrementalInference.transferUpdateSubGraph!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">transferUpdateSubGraph!(dest, src)
transferUpdateSubGraph!(dest, src, syms)
</code></pre><p>Transfer contents of <code>src::FactorGraph</code> variables <code>syms::Vector{Symbol}</code> to <code>dest::FactorGraph</code>.</p><p>Notes</p><ul><li>Approximately like <code>dest</code> = <code>src</code>, for all <code>syms</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.treeProductDwn" href="#IncrementalInference.treeProductDwn"><code>IncrementalInference.treeProductDwn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">treeProductDwn(fg, tree, cliq, sym; N, dbg)
</code></pre><p>Calculate a fresh–-single step–-approximation to the variable <code>sym</code> in clique <code>cliq</code> as though during the downward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variable based on the structure of variables, factors, and incoming messages to this clique. Which clique to be used is defined by frontal variable symbols (<code>cliq</code> in this case) – see <code>whichCliq(...)</code> for more details.  The <code>sym</code> symbol indicates which symbol of this clique to be calculated.  <strong>Note</strong> that the <code>sym</code> variable must appear in the clique where <code>cliq</code> is a frontal variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.treeProductUp" href="#IncrementalInference.treeProductUp"><code>IncrementalInference.treeProductUp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">treeProductUp(fg, tree, cliq, sym; N, dbg)
</code></pre><p>Calculate a fresh (single step) approximation to the variable <code>sym</code> in clique <code>cliq</code> as though during the upward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variables based on the structure of the clique, factors, and incoming messages. Which clique to be used is defined by frontal variable symbols (<code>cliq</code> in this case) – see <code>whichCliq(...)</code> for more details.  The <code>sym</code> symbol indicates which symbol of this clique to be calculated.  <strong>Note</strong> that the <code>sym</code> variable must appear in the clique where <code>cliq</code> is a frontal variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.unfreezeVariablesAll!" href="#IncrementalInference.unfreezeVariablesAll!"><code>IncrementalInference.unfreezeVariablesAll!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unfreezeVariablesAll!(fgl)
</code></pre><p>Free all variables from marginalization.</p><p>Related</p><p>unmarginalizeVariablesAll!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.unmarginalizeVariablesAll!" href="#IncrementalInference.unmarginalizeVariablesAll!"><code>IncrementalInference.unmarginalizeVariablesAll!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unmarginalizeVariablesAll!(fgl)
</code></pre><p>Free all variables from marginalization.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.updateFGBT!" href="#IncrementalInference.updateFGBT!"><code>IncrementalInference.updateFGBT!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">updateFGBT!(fg, bt, cliqID, drt; dbg, fillcolor)
</code></pre><p>Update cliq <code>cliqID</code> in Bayes (Juction) tree <code>bt</code> according to contents of <code>ddt</code> – intended use is to update main clique after a downward belief propagation computation has been completed per clique.</p></div></div><div><div><pre><code class="language-julia">updateFGBT!(fg, cliq, urt; dbg, fillcolor)
</code></pre><p>Update cliq <code>cliqID</code> in Bayes (Juction) tree <code>bt</code> according to contents of <code>urt</code> – intended use is to update main clique after a upward belief propagation computation has been completed per clique.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.updateTreeCliquesAsMarginalizedFromVars!" href="#IncrementalInference.updateTreeCliquesAsMarginalizedFromVars!"><code>IncrementalInference.updateTreeCliquesAsMarginalizedFromVars!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">updateTreeCliquesAsMarginalizedFromVars!(fgl, tree)
</code></pre><p>Run through entire tree and set cliques as marginalized if all clique variables are marginalized.</p><p>Notes:</p><ul><li>TODO can be made fully parallel, consider converting for use with <code>@threads</code> <code>for</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.upGibbsCliqueDensity" href="#IncrementalInference.upGibbsCliqueDensity"><code>IncrementalInference.upGibbsCliqueDensity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">upGibbsCliqueDensity(inp)
upGibbsCliqueDensity(inp, N)
upGibbsCliqueDensity(inp, N, dbg)
upGibbsCliqueDensity(inp, N, dbg, iters)
</code></pre><p>Perform computations required for the upward message passing during belief propation on the Bayes (Junction) tree. This function is usually called as via remote_call for multiprocess dispatch.</p><p>Example</p><pre><code class="language-julia">inp = ExploreTreeType(fg,tree,cliq,parent,childmsgs)
urt = upGibbsCliqueDensity(inp)</code></pre><ul><li><code>fg</code> factor graph,</li><li><code>tree</code> Bayes tree,</li><li><code>cliq</code> which cliq to perform the computation on,</li><li><code>parent</code> the parent clique to where the upward message will be sent,</li><li><code>childmsgs</code> is for any incoming messages from child cliques.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.upMsg" href="#IncrementalInference.upMsg"><code>IncrementalInference.upMsg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">upMsg(cliq)
</code></pre><p>Return the last up message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.wipeBuildNewTree!" href="#IncrementalInference.wipeBuildNewTree!"><code>IncrementalInference.wipeBuildNewTree!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Build a completely new Bayes (Junction) tree, after first wiping clean all temporary state in fg from a possibly pre-existing tree.</p><p>Related:</p><p>buildTreeFromOrdering!</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.writeGraphPdf" href="#IncrementalInference.writeGraphPdf"><code>IncrementalInference.writeGraphPdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">writeGraphPdf(fgl; viewerapp, filepath, engine, show)
</code></pre><p>Draw and show the factor graph <code>&lt;:AbstractDFG</code> via system graphviz and pdf app.</p><p>Notes</p><ul><li>Should not be calling outside programs.</li><li>Need long term solution</li><li>DFG&#39;s <code>toDotFile</code> a better solution – view with <code>xdot</code> application.</li><li>also try <code>engine={&quot;sfdp&quot;,&quot;fdp&quot;,&quot;dot&quot;,&quot;twopi&quot;,&quot;circo&quot;,&quot;neato&quot;}</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.resetVariableAllInitializations!" href="#IncrementalInference.resetVariableAllInitializations!"><code>IncrementalInference.resetVariableAllInitializations!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resetVariableAllInitializations!(fgl)
</code></pre><p>Reset initialization flag on all variables in <code>::FactorGraphs</code>.</p><p>Notes</p><ul><li>Numerical values remain, but inference will overwrite since init flags are now <code>false</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.showFactor" href="#IncrementalInference.showFactor"><code>IncrementalInference.showFactor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Display and return to console the user factor identified by tag name.</p></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>showVariable</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IncrementalInference.solveTree!" href="#IncrementalInference.solveTree!"><code>IncrementalInference.solveTree!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Perform inference over the Bayes tree according to <code>opt::SolverParams</code>.</p></div></div></section><footer><hr/><a class="previous" href="../refs/literature/"><span class="direction">Previous</span><span class="title">References</span></a><a class="next" href="../vis_func_ref/"><span class="direction">Next</span><span class="title">Visualization Reference</span></a></footer></article></body></html>
