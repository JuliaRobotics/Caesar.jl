<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>More Functions · Caesar.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Caesar.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Welcome</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../concepts/why_nongaussian/">Gaussian vs. Non-Gaussian</a></li><li><a class="tocitem" href="../installation_environment/">Installation</a></li><li><a class="tocitem" href="../concepts/using_julia/">Using Julia</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../concepts/concepts/">Initial Concepts</a></li><li><a class="tocitem" href="../concepts/building_graphs/">Building Graphs</a></li><li><a class="tocitem" href="../concepts/solving_graphs/">Solving Graphs</a></li><li><a class="tocitem" href="../concepts/interacting_fgs/">Interact w Graphs</a></li><li><a class="tocitem" href="../concepts/dataassociation/">Multi-Modal/Hypothesis</a></li><li><a class="tocitem" href="../concepts/parallel_processing/">Parallel Processing</a></li><li><a class="tocitem" href="../examples/parametric_solve/">[DEV] Parametric Solve</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/examples/">Caesar Examples</a></li><li><a class="tocitem" href="../examples/basic_continuousscalar/">Canonical 1D Example</a></li><li><a class="tocitem" href="../examples/basic_slamedonut/">Underconstrained Range-only</a></li><li><a class="tocitem" href="../examples/basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="tocitem" href="../examples/interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li><li><a class="tocitem" href="../examples/deadreckontether/">Dead Reckon Tether</a></li></ul></li><li><span class="tocitem">Graph Library</span><ul><li><a class="tocitem" href="../examples/canonical_graphs/">Canonical Generators</a></li><li><a class="tocitem" href="../concepts/available_varfacs/">Variables/Factors</a></li><li><a class="tocitem" href="../concepts/entry_data/">Entry=&gt;Data Blob</a></li><li><a class="tocitem" href="../examples/using_images/">Images and AprilTags</a></li><li><a class="tocitem" href="../examples/using_pcl/">Pointclouds and PCL</a></li><li><a class="tocitem" href="../concepts/using_manifolds/">Using Manifolds.jl</a></li><li><a class="tocitem" href="../concepts/flux_factors/">Flux (NN) Factors</a></li></ul></li><li><span class="tocitem">Visualization</span><ul><li><a class="tocitem" href="../install_viz/">Installing Viz</a></li><li><a class="tocitem" href="../concepts/2d_plotting/">Plotting (2D)</a></li><li><a class="tocitem" href="../concepts/arena_visualizations/">Visualization (3D)</a></li></ul></li><li><span class="tocitem">Middlewares</span><ul><li><a class="tocitem" href="../examples/using_ros/">ROS Middleware</a></li><li><a class="tocitem" href="../concepts/compile_binary/">Compile Binaries</a></li><li><a class="tocitem" href="../concepts/zero_install/">Zero Install Solution</a></li><li><a class="tocitem" href="../concepts/multisession/">Multi-session/agent Solving</a></li><li><a class="tocitem" href="../concepts/multilang/">Multi-Language Support</a></li></ul></li><li><span class="tocitem">How to Expand?</span><ul><li><a class="tocitem" href="../caesar_framework/">Pkg Framework</a></li><li><a class="tocitem" href="../examples/custom_variables/">Custom Variables</a></li><li><a class="tocitem" href="../examples/basic_definingfactors/">Custom Prior Factor</a></li><li><a class="tocitem" href="../examples/custom_relative_factors/">Custom Relative Factor</a></li><li><a class="tocitem" href="../concepts/stash_and_cache/">Caching and Stashing</a></li><li><a class="tocitem" href="../examples/custom_factor_features/">Important Factor Features</a></li><li><a class="tocitem" href="../examples/adding_variables_factors/">Variable/Factor Considerations</a></li><li class="is-active"><a class="tocitem" href>More Functions</a><ul class="internal"><li><a class="tocitem" href="#RoME"><span>RoME</span></a></li><li><a class="tocitem" href="#IncrementalInference"><span>IncrementalInference</span></a></li></ul></li></ul></li><li><span class="tocitem">Principles</span><ul><li><a class="tocitem" href="../principles/filterCorrespondence/">Filters vs. Graphs</a></li><li><a class="tocitem" href="../principles/approxConvDensities/">Generic Convolutions</a></li><li><a class="tocitem" href="../principles/multiplyingDensities/">Multiplying Functions (.py)</a></li><li><a class="tocitem" href="../principles/bayestreePrinciples/">Bayes (Junction) tree</a></li><li><a class="tocitem" href="../principles/initializingOnBayesTree/">Advanced Bayes Tree Topics</a></li><li><a class="tocitem" href="../concepts/mmisam_alg/">Non-Gaussian Algorithm</a></li></ul></li><li><span class="tocitem">Developer Zone</span><ul><li><a class="tocitem" href="../dev/wiki/">Wiki Pointers</a></li><li><a class="tocitem" href="../examples/legacy_deffactors/">Legacy Factors</a></li><li><a class="tocitem" href="../principles/interm_dynpose/">Creating DynPose Factor</a></li><li><a class="tocitem" href="../dev/known_issues/">Known Issue List</a></li><li><a class="tocitem" href="../dev/internal_fncs/">Internal Functions</a></li></ul></li><li><span class="tocitem">Literature</span><ul><li><a class="tocitem" href="../refs/literature/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to Expand?</a></li><li class="is-active"><a href>More Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>More Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/func_ref.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Additional-Function-Reference"><a class="docs-heading-anchor" href="#Additional-Function-Reference">Additional Function Reference</a><a id="Additional-Function-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Function-Reference" title="Permalink"></a></h1><ul><li><a href="#Additional-Function-Reference">Additional Function Reference</a></li><li class="no-marker"><ul><li><a href="#RoME">RoME</a></li><li><a href="#IncrementalInference">IncrementalInference</a></li></ul></li></ul><h2 id="RoME"><a class="docs-heading-anchor" href="#RoME">RoME</a><a id="RoME-1"></a><a class="docs-heading-anchor-permalink" href="#RoME" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RoME.getRangeKDEMax2D" href="#RoME.getRangeKDEMax2D"><code>RoME.getRangeKDEMax2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getRangeKDEMax2D(fgl, vsym1, vsym2)
</code></pre><p>Calculate the cartesian distance between two vertices in the graph using their symbol name, and by maximum belief point.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RoME.initFactorGraph!" href="#RoME.initFactorGraph!"><code>RoME.initFactorGraph!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initFactorGraph!(fg; P0, init, N, lbl, solvable, firstPoseType, labels)
</code></pre><p>Initialize a factor graph object as Pose2, Pose3, or neither and returns variable and factor symbols as array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RoME.addOdoFG!" href="#RoME.addOdoFG!"><code>RoME.addOdoFG!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addOdoFG!(fg, n, DX, cov; N, solvable, labels)
</code></pre><p>Create a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x&lt;k+1&gt; for new node new node and constraint factor are returned as a tuple.</p></div></section><section><div><pre><code class="language-julia hljs">addOdoFG!(fgl, odo; N, solvable, labels)
</code></pre><p>Create a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x&lt;k+1&gt; for new node new node and constraint factor are returned as a tuple.</p></div></section></article><h2 id="IncrementalInference"><a class="docs-heading-anchor" href="#IncrementalInference">IncrementalInference</a><a id="IncrementalInference-1"></a><a class="docs-heading-anchor-permalink" href="#IncrementalInference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.approxCliqMarginalUp!" href="#IncrementalInference.approxCliqMarginalUp!"><code>IncrementalInference.approxCliqMarginalUp!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">approxCliqMarginalUp!(csmc)
approxCliqMarginalUp!(csmc, childmsgs; N, dbg, multiproc, logger, iters, drawpdf)
</code></pre><p>Approximate Chapman-Kolmogorov transit integral and return separator marginals as messages to pass up the Bayes (Junction) tree, along with additional clique operation values for debugging.</p><p>Notes</p><ul><li><code>onduplicate=true</code> by default internally uses deepcopy of factor graph and Bayes tree, and does <strong>not</strong> update the given objects.  Set false to update <code>fgl</code> and <code>treel</code> during compute.</li></ul><p>Future</p><ul><li>TODO: internal function chain is too long and needs to be refactored for maintainability.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.areCliqVariablesAllMarginalized" href="#IncrementalInference.areCliqVariablesAllMarginalized"><code>IncrementalInference.areCliqVariablesAllMarginalized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">areCliqVariablesAllMarginalized(subfg, cliq)
</code></pre><p>Return true if all variables in clique are considered marginalized (and initialized).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.attemptTreeSimilarClique" href="#IncrementalInference.attemptTreeSimilarClique"><code>IncrementalInference.attemptTreeSimilarClique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">attemptTreeSimilarClique(othertree, seeksSimilar)
</code></pre><p>Special internal function to try return the clique data if succesfully identified in <code>othertree::AbstractBayesTree</code>, based on contents of <code>seeksSimilar::BayesTreeNodeData</code>.</p><p>Notes</p><ul><li>Used to identify and skip similar cliques (i.e. recycle computations)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.childCliqs" href="#IncrementalInference.childCliqs"><code>IncrementalInference.childCliqs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">childCliqs(treel, cliq)
</code></pre><p>Return a vector of child cliques to <code>cliq</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.cliqHistFilterTransitions" href="#IncrementalInference.cliqHistFilterTransitions"><code>IncrementalInference.cliqHistFilterTransitions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cliqHistFilterTransitions(hist, nextfnc)
</code></pre><p>Return state machine transition steps from history such that the <code>nextfnc::Function</code>.</p><p>Related:</p><p>printCliqHistorySummary, filterHistAllToArray, sandboxCliqResolveStep</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>csmAnimate</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.cycleInitByVarOrder!" href="#IncrementalInference.cycleInitByVarOrder!"><code>IncrementalInference.cycleInitByVarOrder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cycleInitByVarOrder!(subfg, varorder; solveKey, logger)
</code></pre><p>Cycle through var order and initialize variables as possible in <code>subfg::AbstractDFG</code>. Return true if something was updated.</p><p>Notes:</p><ul><li>assumed <code>subfg</code> is a subgraph containing only the factors that can be used.<ul><li>including the required up or down messages</li></ul></li><li>intended for both up and down initialization operations.</li></ul><p>Dev Notes</p><ul><li>Should monitor updates based on the number of inferred &amp; solvable dimensions</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.doautoinit!" href="#IncrementalInference.doautoinit!"><code>IncrementalInference.doautoinit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">doautoinit!(dfg, xi; solveKey, singles, N, logger)
</code></pre><p>EXPERIMENTAL: initialize target variable <code>xi</code> based on connected factors in the factor graph <code>fgl</code>.  Possibly called from <code>addFactor!</code>, or <code>doCliqAutoInitUp!</code> (?).</p><p>Notes:</p><ul><li>Special carve out for multihypo cases, see issue 427.</li></ul><p>Development Notes:</p><blockquote><p>Target factor is first (singletons) or second (dim 2 pairwise) variable vertex in <code>xi</code>.</p></blockquote><ul><li>TODO use DFG properly with local operations and DB update at end.</li><li>TODO get faster version of <code>isInitialized</code> for database version.</li><li>TODO: Persist this back if we want to here.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.drawCliqSubgraphUpMocking" href="#IncrementalInference.drawCliqSubgraphUpMocking"><code>IncrementalInference.drawCliqSubgraphUpMocking</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">drawCliqSubgraphUpMocking(fgl, treel, frontalSym; show, filepath, engine, viewerapp)
</code></pre><p>Construct (new) subgraph and draw the subgraph associated with clique <code>frontalSym::Symbol</code>.</p><p>Notes</p><ul><li>See <code>drawGraphCliq</code>/<code>writeGraphPdf</code> for details on keyword options.</li></ul><p>Related</p><p>drawGraphCliq, spyCliqMat, drawTree, buildCliqSubgraphUp, buildSubgraphFromLabels!</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.fifoFreeze!" href="#IncrementalInference.fifoFreeze!"><code>IncrementalInference.fifoFreeze!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fifoFreeze!(dfg)
</code></pre><p>Freeze nodes that are older than the quasi fixed-lag length defined by <code>fg.qfl</code>, according to <code>fg.fifo</code> ordering.</p><p>Future:</p><ul><li>Allow different freezing strategies beyond fifo.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.filterHistAllToArray" href="#IncrementalInference.filterHistAllToArray"><code>IncrementalInference.filterHistAllToArray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filterHistAllToArray(tree, hists, frontals, nextfnc)
</code></pre><p>Return state machine transition steps from all cliq histories with transition <code>nextfnc::Function</code>.</p><p>Related:</p><p>printCliqHistorySummary, cliqHistFilterTransitions, sandboxCliqResolveStep</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>findRelatedFromPotential</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.fmcmc!" href="#IncrementalInference.fmcmc!"><code>IncrementalInference.fmcmc!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fmcmc!(fgl, cliq, fmsgs, lbls, solveKey, N, MCMCIter)
fmcmc!(fgl, cliq, fmsgs, lbls, solveKey, N, MCMCIter, dbg)
fmcmc!(fgl, cliq, fmsgs, lbls, solveKey, N, MCMCIter, dbg, logger)
fmcmc!(fgl, cliq, fmsgs, lbls, solveKey, N, MCMCIter, dbg, logger, multithreaded)
</code></pre><p>Iterate successive approximations of clique marginal beliefs by means of the stipulated proposal convolutions and products of the functional objects for tree clique <code>cliq</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getClique" href="#IncrementalInference.getClique"><code>IncrementalInference.getClique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getClique(tree, cId)
</code></pre><p>Return the TreeClique node object that represents a clique in the Bayes (Junction) tree, as defined by one of the frontal variables <code>frt&lt;:AbstractString</code>.</p><p>Notes</p><ul><li>Frontal variables only occur once in a clique per tree, therefore is a unique identifier.</li></ul><p>Related:</p><p>getCliq, getTreeAllFrontalSyms</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqAllVarIds" href="#IncrementalInference.getCliqAllVarIds"><code>IncrementalInference.getCliqAllVarIds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCliqAllVarIds(cliq)
</code></pre><p>Get all <code>cliq</code> variable ids<code>::Symbol</code>.</p><p>Related</p><p>getCliqVarIdsAll, getCliqFactorIdsAll, getCliqVarsWithFrontalNeighbors</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>getCliqAllVarSyms</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqAssocMat" href="#IncrementalInference.getCliqAssocMat"><code>IncrementalInference.getCliqAssocMat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCliqAssocMat(cliq)
</code></pre><p>Return boolean matrix of factor by variable (row by column) associations within clique, corresponds to order presented by <code>getCliqFactorIds</code> and <code>getCliqAllVarIds</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqDepth" href="#IncrementalInference.getCliqDepth"><code>IncrementalInference.getCliqDepth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCliqDepth(tree, cliq)
</code></pre><p>Return depth in tree as <code>::Int</code>, with root as depth=0.</p><p>Related</p><p>getCliq</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqDownMsgsAfterDownSolve" href="#IncrementalInference.getCliqDownMsgsAfterDownSolve"><code>IncrementalInference.getCliqDownMsgsAfterDownSolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCliqDownMsgsAfterDownSolve(subdfg, cliq, solveKey; status, sender)
</code></pre><p>Return dictionary of down messages consisting of all frontal and separator beliefs of this clique.</p><p>Notes:</p><ul><li>Fetches numerical results from <code>subdfg</code> as dictated in <code>cliq</code>.</li><li>return LikelihoodMessage</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqFrontalVarIds" href="#IncrementalInference.getCliqFrontalVarIds"><code>IncrementalInference.getCliqFrontalVarIds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCliqFrontalVarIds(cliqdata)
</code></pre><p>Get the frontal variable IDs <code>::Int</code> for a given clique in a Bayes (Junction) tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqVarInitOrderUp" href="#IncrementalInference.getCliqVarInitOrderUp"><code>IncrementalInference.getCliqVarInitOrderUp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCliqVarInitOrderUp(subfg)
</code></pre><p>Return the most likely  ordering for initializing factor (assuming up solve sequence).</p><p>Notes:</p><ul><li>sorts id (label) for increasing number of connected factors using the clique subfg with messages already included.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqMat" href="#IncrementalInference.getCliqMat"><code>IncrementalInference.getCliqMat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCliqMat(cliq; showmsg)
</code></pre><p>Return boolean matrix of factor variable associations for a clique, optionally including (<code>showmsg::Bool=true</code>) the upward message singletons.  Variable order corresponds to <code>getCliqAllVarIds</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqSeparatorVarIds" href="#IncrementalInference.getCliqSeparatorVarIds"><code>IncrementalInference.getCliqSeparatorVarIds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCliqSeparatorVarIds(cliqdata)
</code></pre><p>Get <code>cliq</code> separator (a.k.a. conditional) variable ids<code>::Symbol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqSiblings" href="#IncrementalInference.getCliqSiblings"><code>IncrementalInference.getCliqSiblings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCliqSiblings(treel, cliq)
getCliqSiblings(treel, cliq, inclusive)
</code></pre><p>Return a vector of all siblings to a clique, which defaults to not <code>inclusive</code> the calling <code>cliq</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqVarIdsPriors" href="#IncrementalInference.getCliqVarIdsPriors"><code>IncrementalInference.getCliqVarIdsPriors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCliqVarIdsPriors(cliq)
getCliqVarIdsPriors(cliq, allids)
getCliqVarIdsPriors(cliq, allids, partials)
</code></pre><p>Get variable ids<code>::Int</code> with prior factors associated with this <code>cliq</code>.</p><p>Notes:</p><ul><li>does not include any singleton messages from upward or downward message passing.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqVarSingletons" href="#IncrementalInference.getCliqVarSingletons"><code>IncrementalInference.getCliqVarSingletons</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCliqVarSingletons(cliq)
getCliqVarSingletons(cliq, allids)
getCliqVarSingletons(cliq, allids, partials)
</code></pre><p>Get <code>cliq</code> variable IDs with singleton factors – i.e. both in clique priors and up messages.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getParent" href="#IncrementalInference.getParent"><code>IncrementalInference.getParent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getParent(treel, afrontal)
</code></pre><p>Return <code>cliq</code>&#39;s parent clique.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getTreeAllFrontalSyms" href="#IncrementalInference.getTreeAllFrontalSyms"><code>IncrementalInference.getTreeAllFrontalSyms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getTreeAllFrontalSyms(_, tree)
</code></pre><p>Return one symbol (a frontal variable) from each clique in the <code>::BayesTree</code>.</p><p>Notes</p><ul><li>Frontal variables only occur once in a clique per tree, therefore is a unique identifier.</li></ul><p>Related:</p><p>whichCliq, printCliqHistorySummary</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>getVariableDim</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>getVariableInferredDim</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.hasClique" href="#IncrementalInference.hasClique"><code>IncrementalInference.hasClique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hasClique(bt, frt)
</code></pre><p>Return boolean on whether the frontal variable <code>frt::Symbol</code> exists somewhere in the <code>::BayesTree</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.isInitialized" href="#DistributedFactorGraphs.isInitialized"><code>DistributedFactorGraphs.isInitialized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isInitialized(cliq)
</code></pre><p>Returns state of Bayes tree clique <code>.initialized</code> flag.</p><p>Notes:</p><ul><li>used by Bayes tree clique logic.</li><li>similar method in DFG</li></ul></div></section><section><div><pre><code class="language-julia hljs">isInitialized(var)
isInitialized(var, key)
</code></pre><p>Returns state of variable data <code>.initialized</code> flag.</p><p>Notes:</p><ul><li>used by both factor graph variable and Bayes tree clique logic.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.isMarginalized" href="#DistributedFactorGraphs.isMarginalized"><code>DistributedFactorGraphs.isMarginalized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isMarginalized(vert)
isMarginalized(vert, solveKey)
</code></pre><p>Return <code>::Bool</code> on whether this variable has been marginalized.</p><p>Notes:</p><ul><li>VariableNodeData default <code>solveKey=:default</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.isTreeSolved" href="#IncrementalInference.isTreeSolved"><code>IncrementalInference.isTreeSolved</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isTreeSolved(treel; skipinitialized)
</code></pre><p>Return true or false depending on whether the tree has been fully initialized/solved/marginalized.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ApproxManifoldProducts.isPartial" href="#ApproxManifoldProducts.isPartial"><code>ApproxManifoldProducts.isPartial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isPartial(fcf)
</code></pre><p>Return <code>::Bool</code> on whether factor is a partial constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.localProduct" href="#IncrementalInference.localProduct"><code>IncrementalInference.localProduct</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localProduct(dfg, sym; solveKey, N, dbg, logger)
</code></pre><p>Using factor graph object <code>dfg</code>, project belief through connected factors (convolution with likelihood) to variable <code>sym</code> followed by a approximate functional product.</p><p>Return: product belief, full proposals, partial dimension proposals, labels</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.makeCsmMovie" href="#IncrementalInference.makeCsmMovie"><code>IncrementalInference.makeCsmMovie</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makeCsmMovie(fg, tree)
makeCsmMovie(fg, tree, cliqs; assignhist, show, filename, frames)
</code></pre><p>Convenience function to assign and make video of CSM state machine for <code>cliqs</code>.</p><p>Notes</p><ul><li>Probably several teething issues still (lower priority).</li><li>Use <code>assignhist</code> if solver params async was true, or errored.</li></ul><p>Related</p><p>csmAnimate, printCliqHistorySummary</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.parentCliq" href="#IncrementalInference.parentCliq"><code>IncrementalInference.parentCliq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parentCliq(treel, cliq)
</code></pre><p>Return <code>cliq</code>&#39;s parent clique.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RoME.predictVariableByFactor" href="#RoME.predictVariableByFactor"><code>RoME.predictVariableByFactor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predictVariableByFactor(dfg, targetsym, fct, prevars)
</code></pre><p>Method to compare current and predicted estimate on a variable, developed for testing a new factor before adding to the factor graph.</p><p>Notes</p><ul><li><code>fct</code> does not have to be in the factor graph – likely used to test beforehand.</li><li>function is useful for detecting if <code>multihypo</code> should be used.</li><li><code>approxConv</code> will project the full belief estimate through some factor but must already be in factor graph.</li></ul><p>Example</p><pre><code class="language-julia hljs"># fg already exists containing :x7 and :l3
pp = Pose2Point2BearingRange(Normal(0,0.1),Normal(10,1.0))
# possible new measurement from :x7 to :l3
curr, pred = predictVariableByFactor(fg, :l3, pp, [:x7; :l3])
# example of naive user defined test on fit score
fitscore = minkld(curr, pred)
# `multihypo` can be used as option between existing or new variables</code></pre><p>Related</p><p>approxConv</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.printCliqHistorySummary" href="#IncrementalInference.printCliqHistorySummary"><code>IncrementalInference.printCliqHistorySummary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">printCliqHistorySummary(fid, hist)
printCliqHistorySummary(fid, hist, cliqid)
</code></pre><p>Print a short summary of state machine history for a clique solve.</p><p>Related:</p><p>getTreeAllFrontalSyms, animateCliqStateMachines, printHistoryLine, printCliqHistorySequential</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>prodmultiplefullpartials</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>prodmultipleonefullpartials</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>resetBuildTreeFromOrder!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.resetCliqSolve!" href="#IncrementalInference.resetCliqSolve!"><code>IncrementalInference.resetCliqSolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resetCliqSolve!(dfg, treel, cliq; solveKey)
</code></pre><p>Reset the state of all variables in a clique to not initialized.</p><p>Notes</p><ul><li>resets numberical values to zeros.</li></ul><p>Dev Notes</p><ul><li>TODO not all kde manifolds will initialize to zero.</li><li>FIXME channels need to be consolidated</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.resetData!" href="#IncrementalInference.resetData!"><code>IncrementalInference.resetData!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resetData!(vdata)
</code></pre><p>Partial reset of basic data fields in <code>::VariableNodeData</code> of <code>::FunctionNode</code> structures.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.resetTreeCliquesForUpSolve!" href="#IncrementalInference.resetTreeCliquesForUpSolve!"><code>IncrementalInference.resetTreeCliquesForUpSolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resetTreeCliquesForUpSolve!(treel)
</code></pre><p>Reset the Bayes (Junction) tree so that a new upsolve can be performed.</p><p>Notes</p><ul><li>Will change previous clique status from <code>DOWNSOLVED</code> to <code>INITIALIZED</code> only.</li><li>Sets the color of tree clique to <code>lightgreen</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.resetVariable!" href="#IncrementalInference.resetVariable!"><code>IncrementalInference.resetVariable!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resetVariable!(varid; solveKey)
</code></pre><p>Reset the solve state of a variable to uninitialized/unsolved state.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>sandboxCliqResolveStep</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setfreeze!" href="#IncrementalInference.setfreeze!"><code>IncrementalInference.setfreeze!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setfreeze!(dfg, sym)
</code></pre><p>Set variable(s) <code>sym</code> of factor graph to be marginalized – i.e. not be updated by inference computation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setValKDE!" href="#IncrementalInference.setValKDE!"><code>IncrementalInference.setValKDE!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setValKDE!(vd, pts, bws)
setValKDE!(vd, pts, bws, setinit)
setValKDE!(vd, pts, bws, setinit, ipc)
</code></pre><p>Set the point centers and bandwidth parameters of a variable node, also set <code>isInitialized=true</code> if <code>setinit::Bool=true</code> (as per default).</p><p>Notes</p><ul><li><code>initialized</code> is used for initial solve of factor graph where variables are not yet initialized.</li><li><code>inferdim</code> is used to identify if the initialized was only partial.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setVariableInitialized!" href="#IncrementalInference.setVariableInitialized!"><code>IncrementalInference.setVariableInitialized!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setVariableInitialized!(varid, status)
</code></pre><p>Set variable initialized status.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>setVariableInferDim!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>solveCliq!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.solveCliqWithStateMachine!" href="#IncrementalInference.solveCliqWithStateMachine!"><code>IncrementalInference.solveCliqWithStateMachine!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solveCliqWithStateMachine!(dfg, tree, frontal; iters, downsolve, recordhistory, verbose, nextfnc, prevcsmc)
</code></pre><p>Standalone state machine solution for a single clique.</p><p>Related:</p><p>initInferTreeUp!</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.transferUpdateSubGraph!" href="#IncrementalInference.transferUpdateSubGraph!"><code>IncrementalInference.transferUpdateSubGraph!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transferUpdateSubGraph!(dest, src)
transferUpdateSubGraph!(dest, src, syms)
transferUpdateSubGraph!(dest, src, syms, logger; updatePPE, solveKey)
</code></pre><p>Transfer contents of <code>src::AbstractDFG</code> variables <code>syms::Vector{Symbol}</code> to <code>dest::AbstractDFG</code>. Notes</p><ul><li>Reads, <code>dest</code> := <code>src</code>, for all <code>syms</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.treeProductDwn" href="#IncrementalInference.treeProductDwn"><code>IncrementalInference.treeProductDwn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">treeProductDwn(fg, tree, cliq, sym; N, dbg)
</code></pre><p>Calculate a fresh–-single step–-approximation to the variable <code>sym</code> in clique <code>cliq</code> as though during the downward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variable based on the structure of variables, factors, and incoming messages to this clique. Which clique to be used is defined by frontal variable symbols (<code>cliq</code> in this case) – see <code>getClique(...)</code> for more details.  The <code>sym</code> symbol indicates which symbol of this clique to be calculated.  <strong>Note</strong> that the <code>sym</code> variable must appear in the clique where <code>cliq</code> is a frontal variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.treeProductUp" href="#IncrementalInference.treeProductUp"><code>IncrementalInference.treeProductUp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">treeProductUp(fg, tree, cliq, sym; N, dbg)
</code></pre><p>Calculate a fresh (single step) approximation to the variable <code>sym</code> in clique <code>cliq</code> as though during the upward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variables based on the structure of the clique, factors, and incoming messages. Which clique to be used is defined by frontal variable symbols (<code>cliq</code> in this case) – see <code>getClique(...)</code> for more details.  The <code>sym</code> symbol indicates which symbol of this clique to be calculated.  <strong>Note</strong> that the <code>sym</code> variable must appear in the clique where <code>cliq</code> is a frontal variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.unfreezeVariablesAll!" href="#IncrementalInference.unfreezeVariablesAll!"><code>IncrementalInference.unfreezeVariablesAll!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unfreezeVariablesAll!(fgl)
</code></pre><p>Free all variables from marginalization.</p><p>Related</p><p>dontMarginalizeVariablesAll!</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.dontMarginalizeVariablesAll!" href="#IncrementalInference.dontMarginalizeVariablesAll!"><code>IncrementalInference.dontMarginalizeVariablesAll!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dontMarginalizeVariablesAll!(fgl)
</code></pre><p>Free all variables from marginalization.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.updateFGBT!" href="#IncrementalInference.updateFGBT!"><code>IncrementalInference.updateFGBT!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">updateFGBT!(fg, cliq, IDvals; dbg, fillcolor, logger)
</code></pre><p>Update cliq <code>cliqID</code> in Bayes (Juction) tree <code>bt</code> according to contents of <code>urt</code> – intended use is to update main clique after a upward belief propagation computation has been completed per clique.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.upGibbsCliqueDensity" href="#IncrementalInference.upGibbsCliqueDensity"><code>IncrementalInference.upGibbsCliqueDensity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">upGibbsCliqueDensity(dfg, cliq, solveKey, inmsgs)
upGibbsCliqueDensity(dfg, cliq, solveKey, inmsgs, N)
upGibbsCliqueDensity(dfg, cliq, solveKey, inmsgs, N, dbg)
upGibbsCliqueDensity(dfg, cliq, solveKey, inmsgs, N, dbg, iters)
upGibbsCliqueDensity(dfg, cliq, solveKey, inmsgs, N, dbg, iters, logger)
</code></pre><p>Perform computations required for the upward message passing during belief propation on the Bayes (Junction) tree. This function is usually called as via remote_call for multiprocess dispatch.</p><p>Notes</p><ul><li><code>fg</code> factor graph,</li><li><code>tree</code> Bayes tree,</li><li><code>cliq</code> which cliq to perform the computation on,</li><li><code>parent</code> the parent clique to where the upward message will be sent,</li><li><code>childmsgs</code> is for any incoming messages from child cliques.</li></ul><p>DevNotes</p><ul><li>FIXME total rewrite with AMP #41 and RoME #244 in mind</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.resetVariableAllInitializations!" href="#IncrementalInference.resetVariableAllInitializations!"><code>IncrementalInference.resetVariableAllInitializations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resetVariableAllInitializations!(fgl)
</code></pre><p>Reset initialization flag on all variables in <code>::AbstractDFG</code>.</p><p>Notes</p><ul><li>Numerical values remain, but inference will overwrite since init flags are now <code>false</code>.</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/adding_variables_factors/">« Variable/Factor Considerations</a><a class="docs-footer-nextpage" href="../principles/filterCorrespondence/">Filters vs. Graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 26 December 2022 13:00">Monday 26 December 2022</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
