<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Caesar&#39;s Reference · Caesar.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Caesar.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../installation_environment/">Installation</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul></li><li><span class="tocitem">Initial Concepts</span><ul><li><a class="tocitem" href="../concepts/concepts/">Caesar Concepts</a></li><li><a class="tocitem" href="../concepts/building_graphs/">Building Factor Graphs</a></li><li><a class="tocitem" href="../concepts/available_varfacs/">Available Variables/Factors</a></li><li><a class="tocitem" href="../concepts/interacting_fgs/">Interacting w/ Factor Graphs</a></li><li><a class="tocitem" href="../concepts/multilang/">Multi-Language Support</a></li><li><a class="tocitem" href="../concepts/arena_visualizations/">Arena Visualization</a></li><li><a class="tocitem" href="../concepts/database_interactions/">Cloud Server/Database</a></li><li><a class="tocitem" href="../concepts/multisession/">Multi/Cross Session Solving</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/examples/">Caesar Examples</a></li><li><a class="tocitem" href="../examples/basic_continuousscalar/">ContinuousScalar as 1D Example</a></li><li><a class="tocitem" href="../examples/basic_slamedonut/">Under-defined Trilateration SLAM 2D</a></li><li><a class="tocitem" href="../examples/basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="tocitem" href="../examples/interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li></ul></li><li><span class="tocitem">Principles</span><ul><li><a class="tocitem" href="../principles/filterCorrespondence/">Filters vs. Graphs</a></li><li><a class="tocitem" href="../principles/approxConvDensities/">Generic Convolutions</a></li><li><a class="tocitem" href="../principles/multiplyingDensities/">Multiplying Functions (.py)</a></li><li><a class="tocitem" href="../principles/bayestreePrinciples/">Bayes (Junction) tree</a></li><li><a class="tocitem" href="../principles/initializingOnBayesTree/">Advanced Bayes Tree Topics</a></li><li><a class="tocitem" href="../concepts/mmisam_alg/">Multimodal iSAM Algorithm</a></li></ul></li><li><span class="tocitem">How to Expand?</span><ul><li><a class="tocitem" href="../concepts/adding_variables_factors/">Custom Variables and Factors</a></li><li><a class="tocitem" href="../examples/basic_definingfactors/">Creating Variables and Factors</a></li><li><a class="tocitem" href="../examples/interm_dynpose/">Creating DynPose Factor</a></li></ul></li><li><span class="tocitem">Developer Zone</span><ul><li><a class="tocitem" href="../dev/wiki/">Wiki Pointer</a></li></ul></li><li><span class="tocitem">Literature</span><ul><li><a class="tocitem" href="../refs/literature/">References</a></li></ul></li><li><span class="tocitem">Function Reference</span><ul><li class="is-active"><a class="tocitem" href>Caesar&#39;s Reference</a><ul class="internal"><li><a class="tocitem" href="#Function-Reference-1"><span>Function Reference</span></a></li></ul></li><li><a class="tocitem" href="../vis_func_ref/">Visualization Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Function Reference</a></li><li class="is-active"><a href>Caesar&#39;s Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Caesar&#39;s Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/func_ref.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Function-Reference-1"><a class="docs-heading-anchor" href="#Function-Reference-1">Function Reference</a><a class="docs-heading-anchor-permalink" href="#Function-Reference-1" title="Permalink"></a></h2><ul><ul><li><a href="#Function-Reference-1">Function Reference</a></li><ul><li><a href="#Caesar-1">Caesar</a></li><li><a href="#RoME-1">RoME</a></li><li><a href="#IncrementalInference-1">IncrementalInference</a></li></ul></ul></ul><p><strong>WORK IN PROGRESS</strong>  Not all functions have been added to this directory yet.</p><h3 id="Caesar-1"><a class="docs-heading-anchor" href="#Caesar-1">Caesar</a><a class="docs-heading-anchor-permalink" href="#Caesar-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Caesar.appendvertbigdata!" href="#Caesar.appendvertbigdata!"><code>Caesar.appendvertbigdata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">appendvertbigdata!(cloudGraph, cv, description, data)
</code></pre><p>Append big data element into current blob store and update associated global vertex information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L906-L911">source</a></section><section><div><pre><code class="language-julia">appendvertbigdata!(fgl, vert, description, data)
</code></pre><p>Append big data element into current blob store and update associated global vertex information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L923-L928">source</a></section><section><div><pre><code class="language-none">appendvertbigdata!(fg, sym, descr, data)</code></pre><p>Append big data element into current blob store using parent appendvertbigdata!, but here specified by symbol of variable node in the FactorGraph. Note the default data layer api definition. User must define dlapi to refetching the  vertex from the data layer. localapi avoids repeated network database fetches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L941-L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.consoleaskuserfordb" href="#Caesar.consoleaskuserfordb"><code>Caesar.consoleaskuserfordb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">consoleaskuserfordb(; nparticles, drawdepth, clearslamindb, multisession, drawedges)
</code></pre><p>Obtain database addresses and login credientials from STDIN, as well as a few case dependent options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L783-L787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.db2jld" href="#Caesar.db2jld"><code>Caesar.db2jld</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">db2jld(cgl::CloudGraph, session::AbstractString, filename::AbstractString)</code></pre><p>Fetch and save a FactorGraph session to a jld, using CloudGraph object and session definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L1152-L1156">source</a></section><section><div><pre><code class="language-none">db2jld(filename::AbstractString; addrdict::NothingUnion{Dict{AbstractString, AbstractString}}=nothing )</code></pre><p>Fetch and save a FactorGraph session to a jld, using or asking STDIN for credentials in the addrdict field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L1164-L1168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.executeQuery" href="#Caesar.executeQuery"><code>Caesar.executeQuery</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">executeQuery(connection, query)
</code></pre><p>Run Neo4j Cypher queries on the cloudGraph database, and return Tuple with the unparsed (results, loadresponse). Throws an error if the query fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.fetchrobotdatafirstpose" href="#Caesar.fetchrobotdatafirstpose"><code>Caesar.fetchrobotdatafirstpose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fetchrobotdatafirstpose(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString)</code></pre><p>Return dict of JSON parsed &quot;robot_description&quot; field as was inserted by counterpart <code>insertrobotdatafirstpose!</code> function. Used for storing general robot specific data in easily accessible manner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L1115-L1121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.fetchsubgraph!" href="#Caesar.fetchsubgraph!"><code>Caesar.fetchsubgraph!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fetchsubgraph!(fgl, cvs; numneighbors)
</code></pre><p>Fetch and insert list of CloudVertices into FactorGraph object, up to neighbor depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L961-L965">source</a></section><section><div><pre><code class="language-julia">fetchsubgraph!(fgl, neoids; numneighbors)
</code></pre><p>Fetch and insert list of Neo4j IDs into FactorGraph object, up to neighbor depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L995-L999">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.findExistingMSConstraints" href="#Caesar.findExistingMSConstraints"><code>Caesar.findExistingMSConstraints</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return Dict{Symbol, Int} of vertex symbol to Neo4j node ID of MULTISESSION constraints in this <code>fgl.sessionname</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/MultisessionUtils.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.getAllLandmarkNeoIDs" href="#Caesar.getAllLandmarkNeoIDs"><code>Caesar.getAllLandmarkNeoIDs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getAllLandmarkNeoIDs(lm2others, slm)
</code></pre><p>Return Vector{Int} of Neo4j vertex IDs relating to symbol, as listed in lm2others.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/MultisessionUtils.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.getBigDataElement" href="#Caesar.getBigDataElement"><code>Caesar.getBigDataElement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getBigDataElement(vertex, description)
</code></pre><p>Walk through vertex bigDataElements and return the last matching description.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L877-L881">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.getExVertexNeoIDs" href="#Caesar.getExVertexNeoIDs"><code>Caesar.getExVertexNeoIDs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getExVertexNeoIDs(conn; label, solvable, backendset, session, robot, user, reqbackendset)
</code></pre><p>Return array of tuples with ExVertex IDs and Neo4j IDs for vertices with label in session.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L499-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.getLandmOtherSessNeoIDs" href="#Caesar.getLandmOtherSessNeoIDs"><code>Caesar.getLandmOtherSessNeoIDs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getLandmOtherSessNeoIDs{T &lt;: AbstractString}(::CloudGraph, session::T=&quot;&quot;, robot::T=&quot;&quot;, user::T=&quot;&quot;, multisessions=Vector{T}())</code></pre><p>Return dict of dict of Neo4j vertex IDs by session and landmark symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/MultisessionUtils.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.getLocalSubGraphMultisession" href="#Caesar.getLocalSubGraphMultisession"><code>Caesar.getLocalSubGraphMultisession</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getLocalSubGraphMultisession(cg, lm2others; session, robot, user, numneighbors)
</code></pre><p>Return subgraph copy of type FactorGraph contaning values from session in lm2others, and Vector{Symbol} of primary key symbols used for graph exstraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/MultisessionUtils.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.getPoseExVertexNeoIDs" href="#Caesar.getPoseExVertexNeoIDs"><code>Caesar.getPoseExVertexNeoIDs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getPoseExVertexNeoIDs(conn; solvable, backendset, session, reqbackendset)
</code></pre><p>Return array of tuples with ExVertex IDs and Neo4j IDs for all poses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L534-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.getVertNeoIDs!" href="#Caesar.getVertNeoIDs!"><code>Caesar.getVertNeoIDs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getVertNeoIDs!(::CloudGraph, res::Dict{Symbol, Int}; session::AbstractString=&quot;NA&quot;, robot::AbstractString=&quot;NA&quot;, user::AbstractString=&quot;NA&quot;)</code></pre><p>Insert into and return dict <code>res</code> with Neo4j IDs of ExVertex labels as stored per session in Neo4j database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L1015-L1019">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.getfirstpose" href="#Caesar.getfirstpose"><code>Caesar.getfirstpose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getfirstpose(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString)</code></pre><p>Return Tuple{Symbol, Int} of first pose symbol and Neo4j node ID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L1059-L1063">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.getnewvertdict" href="#Caesar.getnewvertdict"><code>Caesar.getnewvertdict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getnewvertdict(conn, session::AbstractString, robot::AbstractString, user::AbstractString)</code></pre><p>Return a dictionary with frtend and mongo_keys json string information for :NEWDATA elements in Neo4j database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/ConvertGeneralSlaminDB.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.getprpt2kde" href="#Caesar.getprpt2kde"><code>Caesar.getprpt2kde</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getprp2kde(::CloudGraph, neoids::Vector{Int}; N::Int=100)</code></pre><p>Return PriorPoint2DensityNH with N points based on beliefs of neoids, and equal share null hypothesis between length(neoids)+1 beliefs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/MultisessionUtils.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.hasBigDataElement" href="#Caesar.hasBigDataElement"><code>Caesar.hasBigDataElement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hasBigDataElement(vertex, description)
</code></pre><p>Return true if vertex has bigDataElements with matching description.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L892-L896">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.insertrobotdatafirstpose!" href="#Caesar.insertrobotdatafirstpose!"><code>Caesar.insertrobotdatafirstpose!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insertrobotdatafirstpose!(cg::CloudGraph, session::AbstractString, robot::AbstractString, user::AbstractString, robotdict::Dict)</code></pre><p>Saves robotdict via JSON to first pose in a SESSION in the database. Used for storing general robot specific data in easily accessible manner. Can fetch later retrieve same dict with counterpart <code>fetchrobotdatafirstpose</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L1087-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.removeNeo4jID" href="#Caesar.removeNeo4jID"><code>Caesar.removeNeo4jID</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">removeNeo4jID(cg::CloudGraph, neoid=-1)</code></pre><p>Remove node from Neo4j according to Neo4j Node ID. Big data elements that may be associated with this node are not removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L1040-L1045">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.resetentireremotesession" href="#Caesar.resetentireremotesession"><code>Caesar.resetentireremotesession</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resetentireremotesession(conn, session, robot, user; segment)
</code></pre><p>match (n:session) remove n.backendset, n.solvable, n.data, n.bigData, n.label, n.packedType, n.exVertexId, n.shape, n.width set n :NEWDATA return n</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/ConvertGeneralSlaminDB.jl#L371-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.rmInstMultisessionPriors!" href="#Caesar.rmInstMultisessionPriors!"><code>Caesar.rmInstMultisessionPriors!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rmInstMultisessionPriors!(::CloudGraph; session&lt;:AbstractString=, multisessions::Vector{&lt;:AbstractString}= )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/MultisessionUtils.jl#L195-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.standardcloudgraphsetup" href="#Caesar.standardcloudgraphsetup"><code>Caesar.standardcloudgraphsetup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">standardcloudgraphsetup(; addrdict, nparticles, drawdepth, drawedges, clearslamindb, multisession)
</code></pre><p>Connect to databases via network according to addrdict, or ask user for credentials and return active cloudGraph object, as well as addrdict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L845-L850">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.updatenewverts!" href="#Caesar.updatenewverts!"><code>Caesar.updatenewverts!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Convert vertices of session in Neo4j DB with Caesar.jl&#39;s required data elements in preparation for MM-iSAMCloudSolve process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/ConvertGeneralSlaminDB.jl#L356-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.whosNear2D" href="#Caesar.whosNear2D"><code>Caesar.whosNear2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">whosNear2D(cg, session, robot, user; x, y, yaw, dist, angle)
</code></pre><p>Find vertices near the point specified and return dictionary of symbol to Neo4j ID pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/FoveationUtils.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Caesar.whosNear3D" href="#Caesar.whosNear3D"><code>Caesar.whosNear3D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">whosNear3D(cg, session, robot, user; x, y, z, roll, pitch, yaw, dist, angle)
</code></pre><p>Find vertices near the point specified and return dictionary of symbol to Neo4j ID pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/FoveationUtils.jl#L43-L47">source</a></section></article><h3 id="RoME-1"><a class="docs-heading-anchor" href="#RoME-1">RoME</a><a class="docs-heading-anchor-permalink" href="#RoME-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RoME.getRangeKDEMax2D" href="#RoME.getRangeKDEMax2D"><code>RoME.getRangeKDEMax2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getRangeKDEMax2D(cgl::CloudGraph, session::AbstractString, vsym1::Symbol, vsym2::Symbol)</code></pre><p>Calculate the cartesian distange between two vertices in the graph, by session and symbol names, and by maximum belief point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L1132-L1137">source</a></section><section><div><pre><code class="language-julia">getRangeKDEMax2D(fgl, vsym1, vsym2)
</code></pre><p>Calculate the cartesian distance between two vertices in the graph using their symbol name, and by maximum belief point.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RoME.initFactorGraph!" href="#RoME.initFactorGraph!"><code>RoME.initFactorGraph!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Initialize a factor graph object as Pose2, Pose3, or neither and returns variable and factor symbols as array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RoME.addOdoFG!" href="#RoME.addOdoFG!"><code>RoME.addOdoFG!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">addOdoFG!(fg, n, DX, cov; N, solvable, labels)
</code></pre><p>Create a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x&lt;k+1&gt; for new node new node and constraint factor are returned as a tuple.</p></div></section><section><div><pre><code class="language-julia">addOdoFG!(fgl, odo; N, solvable, labels)
</code></pre><p>Create a new variable node and insert odometry constraint factor between which will automatically increment latest pose symbol x&lt;k+1&gt; for new node new node and constraint factor are returned as a tuple.</p></div></section></article><h3 id="IncrementalInference-1"><a class="docs-heading-anchor" href="#IncrementalInference-1">IncrementalInference</a><a class="docs-heading-anchor-permalink" href="#IncrementalInference-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.addVariable!" href="#DistributedFactorGraphs.addVariable!"><code>DistributedFactorGraphs.addVariable!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">addVariable!(dfg, lbl, softtype; N, autoinit, solvable, dontmargin, labels, smalldata, checkduplicates)
</code></pre><p>Add a variable node <code>lbl::Symbol</code> to <code>fg::FactorGraph</code>, as <code>softtype&lt;:InferenceVariable</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">fg = initfg()
addVariable!(fg, :x0, Pose2)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.addFactor!" href="#DistributedFactorGraphs.addFactor!"><code>DistributedFactorGraphs.addFactor!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">addFactor!(dfg, Xi, usrfnc; multihypo, solvable, labels, autoinit, threadmodel, maxparallel)
</code></pre><p>Add factor with user defined type &lt;: FunctorInferenceType to the factor graph object. Define whether the automatic initialization of variables should be performed.  Use order sensitive <code>multihypo</code> keyword argument to define if any variables are related to data association uncertainty.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.approxCliqMarginalUp!" href="#IncrementalInference.approxCliqMarginalUp!"><code>IncrementalInference.approxCliqMarginalUp!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">approxCliqMarginalUp!(fgl, treel, csym)
approxCliqMarginalUp!(fgl, treel, csym, onduplicate; N, dbg, iters, drawpdf, multiproc, logger)
</code></pre><p>Approximate Chapman-Kolmogorov transit integral and return separator marginals as messages to pass up the Bayes (Junction) tree, along with additional clique operation values for debugging.</p><p>Notes</p><ul><li><code>onduplicate=true</code> by default internally uses deepcopy of factor graph and Bayes tree, and does <strong>not</strong> update the given objects.  Set false to update <code>fgl</code> and <code>treel</code> during compute.</li></ul><p>Future</p><ul><li>TODO: internal function chain is too long and needs to be refactored for maintainability.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.approxConv" href="#IncrementalInference.approxConv"><code>IncrementalInference.approxConv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">approxConv(dfg, fc, towards)
approxConv(dfg, fc, towards, measurement; N)
</code></pre><p>Draw samples from the approximate convolution of <code>towards</code> symbol using factor <code>fct</code> relative to the other variables.  In addition the <code>api</code> can be adjusted to recover the data from elsewhere (likely to be replaced/removed in the future).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.areCliqChildrenNeedDownMsg" href="#IncrementalInference.areCliqChildrenNeedDownMsg"><code>IncrementalInference.areCliqChildrenNeedDownMsg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">areCliqChildrenNeedDownMsg(children)
</code></pre><p>Return <code>true</code> if any of the children cliques have status <code>:needdownmsg</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.areCliqVariablesAllMarginalized" href="#IncrementalInference.areCliqVariablesAllMarginalized"><code>IncrementalInference.areCliqVariablesAllMarginalized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">areCliqVariablesAllMarginalized(subfg, cliq)
</code></pre><p>Return true if all variables in clique are considered marginalized (and initialized).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.assignTreeHistory!" href="#IncrementalInference.assignTreeHistory!"><code>IncrementalInference.assignTreeHistory!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assignTreeHistory!(treel, cliqHistories)
</code></pre><p>After solving, clique histories can be inserted back into the tree for later reference. This function helps do the required assigment task.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.asyncTreeInferUp!" href="#IncrementalInference.asyncTreeInferUp!"><code>IncrementalInference.asyncTreeInferUp!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Perform tree based initialization of all variables not yet initialized in factor graph as non-blocking method.</p><p>Notes:</p><ul><li>To simplify debugging, this method does not include the usual <code>@ sync</code> around all the state machine async processes.</li><li>Extract the error stack with a <code>fetch</code> on the failed process return by this function.</li></ul><p>Related</p><p>initInferTreeUp!</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.attemptTreeSimilarClique" href="#IncrementalInference.attemptTreeSimilarClique"><code>IncrementalInference.attemptTreeSimilarClique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">attemptTreeSimilarClique(othertree, seeksSimilar)
</code></pre><p>Special internal function to try return the clique data if succesfully identified in <code>othertree::BayesTree</code>, based on contents of <code>seeksSimilar::BayesTreeNodeData</code>.</p><p>Notes</p><ul><li>Used to identify and skip similar cliques (i.e. recycle computations)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.batchSolve!" href="#IncrementalInference.batchSolve!"><code>IncrementalInference.batchSolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Perform multimodal incremental smoothing and mapping (mm-iSAM) computations over given factor graph <code>fgl::FactorGraph</code> on the local computer.  A pdf of the Bayes (Junction) tree will be generated in the working folder with <code>drawpdf=true</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.blockCliqUntilChildrenHaveUpStatus" href="#IncrementalInference.blockCliqUntilChildrenHaveUpStatus"><code>IncrementalInference.blockCliqUntilChildrenHaveUpStatus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">blockCliqUntilChildrenHaveUpStatus(tree, prnt)
blockCliqUntilChildrenHaveUpStatus(tree, prnt, logger)
</code></pre><p>Block the thread until child cliques of <code>prnt::Graphs.ExVertex</code> have finished attempting upward initialization – i.e. have status result. Return <code>::Dict{Symbol}</code> indicating whether next action that should be taken for each child clique.</p><p>Notes:</p><ul><li>See status options at <code>getCliqStatusUp(..)</code>.</li><li>Can be called multiple times</li></ul></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>buildSubgraphFromLabels</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.buildTreeFromOrdering!" href="#IncrementalInference.buildTreeFromOrdering!"><code>IncrementalInference.buildTreeFromOrdering!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">buildTreeFromOrdering!(dfg, p; drawbayesnet, maxparallel, solvable)
</code></pre><p>Build Bayes/Junction/Elimination tree from a given variable ordering.</p></div></section><section><div><pre><code class="language-julia">buildTreeFromOrdering!(dfg, p; drawbayesnet, maxparallel)
</code></pre><p>Build Bayes/Junction/Elimination tree from a given variable ordering.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>buildCliqSubgraphDown</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>buildCliqSubgraphUp</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.childCliqs" href="#IncrementalInference.childCliqs"><code>IncrementalInference.childCliqs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">childCliqs(treel, cliq)
</code></pre><p>Return a vector of child cliques to <code>cliq</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.cliqGibbs" href="#IncrementalInference.cliqGibbs"><code>IncrementalInference.cliqGibbs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cliqGibbs(fg, cliq, vsym, inmsgs, N, dbg, manis)
cliqGibbs(fg, cliq, vsym, inmsgs, N, dbg, manis, logger)
</code></pre><p>Perform one step of the minibatch clique Gibbs operation for solving the Chapman-Kolmogov trasit integral – here involving separate approximate functional convolution and product operations.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.cliqHistFilterTransitions" href="#IncrementalInference.cliqHistFilterTransitions"><code>IncrementalInference.cliqHistFilterTransitions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cliqHistFilterTransitions(hist, nextfnc)
</code></pre><p>Return state machine transition steps from history such that the <code>nextfnc::Function</code>.</p><p>Related:</p><p>getCliqSolveHistory, printCliqHistorySummary, filterHistAllToArray, sandboxCliqResolveStep</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.cliqInitSolveUpByStateMachine!" href="#IncrementalInference.cliqInitSolveUpByStateMachine!"><code>IncrementalInference.cliqInitSolveUpByStateMachine!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cliqInitSolveUpByStateMachine!(dfg, tree, cliq; N, oldcliqdata, drawtree, show, incremental, limititers, upsolve, downsolve, recordhistory, delay, logger)
</code></pre><p>EXPERIMENTAL: perform upward inference using a state machine solution approach.</p><p>Notes:</p><ul><li>will call on values from children or parent cliques</li><li>can be called multiple times</li><li>Assumes all cliques in tree are being solved simultaneously and in similar manner.</li><li>State machine rev.1 – copied from first TreeBasedInitialization.jl.</li><li>Doesn&#39;t do partial initialized state properly yet.</li></ul></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>compareAllVariables</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>compareFactorGraphs</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>compareSimilarFactors</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>compareSimilarVariables</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>compareSubsetFactorGraph</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>compareVariable</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>convert2packedfunctionnode</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.csmAnimate" href="#IncrementalInference.csmAnimate"><code>IncrementalInference.csmAnimate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">csmAnimate(fg, tree, cliqsyms; frames, rmfirst)
</code></pre><p>Animate multiple clique state machines on the same graphviz visualization.  Renders according to linear time for all provided histories.</p><p>Example:</p><pre><code class="language-julia">using Caesar

# build a factor graph
fg = initfg()
# addVariable!(...)
# addFactor!(...)
# ...

fsy = getTreeAllFrontalSyms(fg, tree) # for later use
# perform inference to find the factor graph marginal posterior estimates
tree, smt, hist = solveTree!(fg, recordcliqs=fsy)

# generate frames in standard location /tmp/caesar/csmCompound/
#  requires: sudo apt-get install graphviz
csmAnimate(fg, tree, fsy, frames=500)

# to render and show from default location (might require)
#  sudo apt-get install ffmpeg vlc

# .ogv [Totem Ubuntu default]
Base.rm(&quot;/tmp/caesar/csmCompound/out.ogv&quot;)
run(`ffmpeg -r 10 -i /tmp/caesar/csmCompound/csm_%d.png -c:v libtheora -vf fps=25 -pix_fmt yuv420p -vf &quot;scale=trunc(iw/2)*2:trunc(ih/2)*2&quot; -q 10 /tmp/caesar/csmCompound/out.ogv`)
run(`totem /tmp/caesar/csmCompound/out.ogv`)

# h.264 [VLC not default]
Base.rm(&quot;/tmp/caesar/csmCompound/out.mp4&quot;)
run(`ffmpeg -r 10 -i /tmp/caesar/csmCompound/csm_%d.png -c:v libx264 -vf fps=25 -pix_fmt yuv420p -vf &quot;scale=trunc(iw/2)*2:trunc(ih/2)*2&quot; /tmp/caesar/csmCompound/out.mp4`)
run(`vlc /tmp/caesar/csmCompound/out.mp4`)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.cycleInitByVarOrder!" href="#IncrementalInference.cycleInitByVarOrder!"><code>IncrementalInference.cycleInitByVarOrder!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Cycle through var order and initialize variables as possible in <code>subfg::FactorGraph</code>. Return true if something was updated.</p><p>Notes:</p><ul><li>assumed <code>subfg</code> is a subgraph containing only the factors that can be used.<ul><li>including the required up or down messages</li></ul></li><li>intended for both up and down initialization operations.</li></ul><p>Dev Notes</p><ul><li>Should monitor updates based on the number of inferred &amp; solvable dimensions</li></ul></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>decodefg</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>deleteFactor!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>deleteVariable!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.doautoinit!" href="#IncrementalInference.doautoinit!"><code>IncrementalInference.doautoinit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">doautoinit!(dfg, xi; singles, N, logger)
</code></pre><p>EXPERIMENTAL: initialize target variable <code>xi</code> based on connected factors in the factor graph <code>fgl</code>.  Possibly called from <code>addFactor!</code>, or <code>doCliqAutoInitUp!</code> (?).</p><p>Notes:</p><ul><li>Special carve out for multihypo cases, see issue 427.</li></ul><p>Development Notes:</p><blockquote><p>Target factor is first (singletons) or second (dim 2 pairwise) variable vertex in <code>xi</code>.</p></blockquote><ul><li>TODO use DFG properly with local operations and DB update at end.</li><li>TODO get faster version of <code>isInitialized</code> for database version.</li><li>TODO: Persist this back if we want to here.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.doCliqUpSolve!" href="#IncrementalInference.doCliqUpSolve!"><code>IncrementalInference.doCliqUpSolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Update <code>subfg&lt;:AbstractDFG</code> according to internal computations for a full upsolve.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.downGibbsCliqueDensity" href="#IncrementalInference.downGibbsCliqueDensity"><code>IncrementalInference.downGibbsCliqueDensity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">downGibbsCliqueDensity(fg, cliq, dwnMsgs)
downGibbsCliqueDensity(fg, cliq, dwnMsgs, N)
downGibbsCliqueDensity(fg, cliq, dwnMsgs, N, MCMCIter)
downGibbsCliqueDensity(fg, cliq, dwnMsgs, N, MCMCIter, dbg)
downGibbsCliqueDensity(fg, cliq, dwnMsgs, N, MCMCIter, dbg, usemsgpriors)
downGibbsCliqueDensity(fg, cliq, dwnMsgs, N, MCMCIter, dbg, usemsgpriors, logger)
</code></pre><p>Perform Chapman-Kolmogorov transit integral approximation for <code>cliq</code> in downward pass direction.</p><p>Notes</p><ul><li>Only update frontal variables of the clique.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.downMsgPassingRecursive" href="#IncrementalInference.downMsgPassingRecursive"><code>IncrementalInference.downMsgPassingRecursive</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Pass NBPMessages back down the tree – pre order tree traversal.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.drawCliqSubgraphUpMocking" href="#IncrementalInference.drawCliqSubgraphUpMocking"><code>IncrementalInference.drawCliqSubgraphUpMocking</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drawCliqSubgraphUpMocking(fgl, treel, frontalSym; show, filepath, engine, viewerapp)
</code></pre><p>Construct (new) subgraph and draw the subgraph associated with clique <code>frontalSym::Symbol</code>.</p><p>Notes</p><ul><li>See <code>drawGraphCliq</code>/<code>writeGraphPdf</code> for details on keyword options.</li></ul><p>Related</p><p>drawGraphCliq, spyCliqMat, drawTree, buildCliqSubgraphUp, buildSubgraphFromLabels!</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.dwnMsg" href="#IncrementalInference.dwnMsg"><code>IncrementalInference.dwnMsg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dwnMsg(cliq)
</code></pre><p>Return the last down message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>encodefg</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.fifoFreeze!" href="#IncrementalInference.fifoFreeze!"><code>IncrementalInference.fifoFreeze!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Freeze nodes that are older than the quasi fixed-lag length defined by <code>fg.qfl</code>, according to <code>fg.fifo</code> ordering.</p><p>Future:</p><ul><li>Allow different freezing strategies beyond fifo.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.filterHistAllToArray" href="#IncrementalInference.filterHistAllToArray"><code>IncrementalInference.filterHistAllToArray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filterHistAllToArray(tree, frontals, nextfnc)
</code></pre><p>Return state machine transition steps from all cliq histories with transition <code>nextfnc::Function</code>.</p><p>Related:</p><p>getCliqSolveHistory, printCliqHistorySummary, cliqHistFilterTransitions, sandboxCliqResolveStep</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.findRelatedFromPotential" href="#IncrementalInference.findRelatedFromPotential"><code>IncrementalInference.findRelatedFromPotential</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findRelatedFromPotential(dfg, fct, varid, N)
findRelatedFromPotential(dfg, fct, varid, N, dbg)
</code></pre><p>Compute proposal belief on <code>vertid</code> through <code>fct</code> representing some constraint in factor graph. Always full dimension variable node – partial constraints will only influence subset of variable dimensions. The remaining dimensions will keep pre-existing variable values.</p><p>Notes</p><ul><li>fulldim is true when &quot;rank-deficient&quot; – TODO swap to false (or even float)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.fmcmc!" href="#IncrementalInference.fmcmc!"><code>IncrementalInference.fmcmc!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter)
fmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter, dbg)
fmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter, dbg, logger)
fmcmc!(fgl, cliq, fmsgs, lbls, N, MCMCIter, dbg, logger, multithreaded)
</code></pre><p>Iterate successive approximations of clique marginal beliefs by means of the stipulated proposal convolutions and products of the functional objects for tree clique <code>cliq</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliq" href="#IncrementalInference.getCliq"><code>IncrementalInference.getCliq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliq(bt, frt)
</code></pre><p>Return the Graphs.ExVertex node object that represents a clique in the Bayes (Junction) tree, as defined by one of the frontal variables <code>frt&lt;:AbstractString</code>.</p><p>Notes</p><ul><li>Frontal variables only occur once in a clique per tree, therefore is a unique identifier.</li></ul><p>Related:</p><p>getCliq, getTreeAllFrontalSyms</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqAllVarIds" href="#IncrementalInference.getCliqAllVarIds"><code>IncrementalInference.getCliqAllVarIds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqAllVarIds(cliq)
</code></pre><p>Get all <code>cliq</code> variable ids<code>::Symbol</code>.</p><p>Related</p><p>getCliqVarIdsAll, getCliqAllFactIds, getCliqVarsWithFrontalNeighbors</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqAllVarSyms" href="#IncrementalInference.getCliqAllVarSyms"><code>IncrementalInference.getCliqAllVarSyms</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get all <code>cliq</code> variable labels as <code>::Symbol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqAssocMat" href="#IncrementalInference.getCliqAssocMat"><code>IncrementalInference.getCliqAssocMat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqAssocMat(cliq)
</code></pre><p>Return boolean matrix of factor by variable (row by column) associations within clique, corresponds to order presented by <code>getCliqFactorIds</code> and <code>getCliqAllVarIds</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqChildMsgsUp" href="#IncrementalInference.getCliqChildMsgsUp"><code>IncrementalInference.getCliqChildMsgsUp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqChildMsgsUp(fg_, treel, cliq, ?)
</code></pre><p>Get and return upward belief messages as stored in child cliques from <code>treel::BayesTree</code>.</p><p>Notes</p><ul><li>Use last parameter to select the return format.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqDepth" href="#IncrementalInference.getCliqDepth"><code>IncrementalInference.getCliqDepth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqDepth(tree, cliq)
</code></pre><p>Return depth in tree as <code>::Int</code>, with root as depth=0.</p><p>Related</p><p>getCliq</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqDownMsgsAfterDownSolve" href="#IncrementalInference.getCliqDownMsgsAfterDownSolve"><code>IncrementalInference.getCliqDownMsgsAfterDownSolve</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return dictionary of down messages consisting of all frontal and separator beliefs of this clique.</p><p>Notes:</p><ul><li>Fetches numerical results from <code>subdfg</code> as dictated in <code>cliq</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqFrontalVarIds" href="#IncrementalInference.getCliqFrontalVarIds"><code>IncrementalInference.getCliqFrontalVarIds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqFrontalVarIds(cliqdata)
</code></pre><p>Get the frontal variable IDs <code>::Int</code> for a given clique in a Bayes (Junction) tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqVarInitOrderUp" href="#IncrementalInference.getCliqVarInitOrderUp"><code>IncrementalInference.getCliqVarInitOrderUp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqVarInitOrderUp(cliq)
</code></pre><p>Return the most likely  ordering for initializing factor (assuming up solve sequence).</p><p>Notes:</p><ul><li>sorts id for increasing number of connected factors.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqMat" href="#IncrementalInference.getCliqMat"><code>IncrementalInference.getCliqMat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqMat(cliq; showmsg)
</code></pre><p>Return boolean matrix of factor variable associations for a clique, optionally including (<code>showmsg::Bool=true</code>) the upward message singletons.  Variable order corresponds to <code>getCliqAllVarIds</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqMsgsDown" href="#IncrementalInference.getCliqMsgsDown"><code>IncrementalInference.getCliqMsgsDown</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqMsgsDown(cliql)
</code></pre><p>Return the last down message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqMsgsUp" href="#IncrementalInference.getCliqMsgsUp"><code>IncrementalInference.getCliqMsgsUp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqMsgsUp(cliql)
</code></pre><p>Return the last up message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqOrderUpSolve" href="#IncrementalInference.getCliqOrderUpSolve"><code>IncrementalInference.getCliqOrderUpSolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqOrderUpSolve(treel)
getCliqOrderUpSolve(treel, startcliq)
</code></pre><p>Return clique pointers for the given order in which they will be solved (sequentially).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqParentMsgDown" href="#IncrementalInference.getCliqParentMsgDown"><code>IncrementalInference.getCliqParentMsgDown</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqParentMsgDown(treel, cliq)
</code></pre><p>Get the latest down message from the parent node (without calculating anything).</p><p>Notes</p><ul><li>Different from down initialization messages that do calculate new values – see <code>prepCliqInitMsgsDown!</code>.</li><li>Basically converts function <code>getDwnMsgs</code> from <code>Dict{Symbol,BallTreeDensity}</code> to <code>Dict{Symbol,Vector{BallTreeDensity}}</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqSeparatorVarIds" href="#IncrementalInference.getCliqSeparatorVarIds"><code>IncrementalInference.getCliqSeparatorVarIds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqSeparatorVarIds(cliqdata)
</code></pre><p>Get <code>cliq</code> separator (a.k.a. conditional) variable ids<code>::Symbol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqSiblings" href="#IncrementalInference.getCliqSiblings"><code>IncrementalInference.getCliqSiblings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqSiblings(treel, cliq)
getCliqSiblings(treel, cliq, inclusive)
</code></pre><p>Return a vector of all siblings to a clique, which defaults to not <code>inclusive</code> the calling <code>cliq</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqSolveHistory" href="#IncrementalInference.getCliqSolveHistory"><code>IncrementalInference.getCliqSolveHistory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqSolveHistory(cliq)
</code></pre><p>Return clique state machine history from <code>tree</code> if it was solved with <code>recordcliqs</code>.</p><p>Notes</p><ul><li>Cliques are identified by front variable <code>::Symbol</code> which are always unique across the cliques.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqVarIdsPriors" href="#IncrementalInference.getCliqVarIdsPriors"><code>IncrementalInference.getCliqVarIdsPriors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqVarIdsPriors(cliq)
getCliqVarIdsPriors(cliq, allids)
getCliqVarIdsPriors(cliq, allids, partials)
</code></pre><p>Get variable ids<code>::Int</code> with prior factors associated with this <code>cliq</code>.</p><p>Notes:</p><ul><li>does not include any singleton messages from upward or downward message passing.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqVars" href="#IncrementalInference.getCliqVars"><code>IncrementalInference.getCliqVars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqVars(subfg, cliq)
</code></pre><p>Return array of all variable vertices in a clique.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCliqVarSingletons" href="#IncrementalInference.getCliqVarSingletons"><code>IncrementalInference.getCliqVarSingletons</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCliqVarSingletons(cliq)
getCliqVarSingletons(cliq, allids)
getCliqVarSingletons(cliq, allids, partials)
</code></pre><p>Get <code>cliq</code> variable IDs with singleton factors – i.e. both in clique priors and up messages.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCurrentWorkspaceFactors" href="#IncrementalInference.getCurrentWorkspaceFactors"><code>IncrementalInference.getCurrentWorkspaceFactors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCurrentWorkspaceFactors()
</code></pre><p>Return all factors currently registered in the workspace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getCurrentWorkspaceVariables" href="#IncrementalInference.getCurrentWorkspaceVariables"><code>IncrementalInference.getCurrentWorkspaceVariables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCurrentWorkspaceVariables()
</code></pre><p>Return all variables currently registered in the workspace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getKDE" href="#IncrementalInference.getKDE"><code>IncrementalInference.getKDE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getKDE(v)
</code></pre><p>Get KernelDensityEstimate kde estimate stored in variable node.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getLogPath" href="#IncrementalInference.getLogPath"><code>IncrementalInference.getLogPath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getLogPath(dfg)
</code></pre><p>Get the folder location where debug and solver information is recorded for a particular factor graph.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getManifolds" href="#IncrementalInference.getManifolds"><code>IncrementalInference.getManifolds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getManifolds(vd)
</code></pre><p>Return the manifolds on which variable <code>sym::Symbol</code> is defined.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getParent" href="#IncrementalInference.getParent"><code>IncrementalInference.getParent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getParent(treel, afrontal)
</code></pre><p>Return <code>cliq</code>&#39;s parent clique.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getTreeAllFrontalSyms" href="#IncrementalInference.getTreeAllFrontalSyms"><code>IncrementalInference.getTreeAllFrontalSyms</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return one symbol (a frontal variable) from each clique in the <code>::BayesTree</code>.</p><p>Notes</p><ul><li>Frontal variables only occur once in a clique per tree, therefore is a unique identifier.</li></ul><p>Related:</p><p>whichCliq, printCliqHistorySummary</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getTreeCliqSolveOrderUp" href="#IncrementalInference.getTreeCliqSolveOrderUp"><code>IncrementalInference.getTreeCliqSolveOrderUp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getTreeCliqSolveOrderUp(treel)
getTreeCliqSolveOrderUp(treel, startcliq)
</code></pre><p>Return clique pointers for the given order in which they will be solved (sequentially).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getTreeCliqsSolverHistories" href="#IncrementalInference.getTreeCliqsSolverHistories"><code>IncrementalInference.getTreeCliqsSolverHistories</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return dict of all histories in a Bayes Tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getVal" href="#IncrementalInference.getVal"><code>IncrementalInference.getVal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getVal(v; solveKey)
</code></pre><p>Convenience function to get point values sampled i.i.d from marginal of <code>lbl</code> variable in the current factor graph.</p></div></section><section><div><pre><code class="language-julia">getVal(vA)
getVal(vA, solveKey)
</code></pre><p>Fetch the variable marginal sample points without the KDE bandwidth parameter.  Use getVertKDE to retrieve the full KDE object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getVariableDim" href="#IncrementalInference.getVariableDim"><code>IncrementalInference.getVariableDim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getVariableDim(vard)
</code></pre><p>Return the number of dimensions this variable vertex <code>var</code> contains.</p><p>Related</p><p>getVariableInferredDim, getVariableInferredDimFraction</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getVariableInferredDim" href="#IncrementalInference.getVariableInferredDim"><code>IncrementalInference.getVariableInferredDim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getVariableInferredDim(vard)
getVariableInferredDim(vard, saturate)
</code></pre><p>Return the number of projected dimensions into a variable during inference.</p><p>Notes</p><ul><li><code>saturate</code> clamps return value to no greater than variable dimension</li></ul><p>Related</p><p>getVariableDim, getVariableInferredDimFraction, getVariableInferredDim, getVariableDim</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getVertKDE" href="#IncrementalInference.getVertKDE"><code>IncrementalInference.getVertKDE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getVertKDE(v)
</code></pre><p>Get KernelDensityEstimate kde estimate stored in variable node.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getUpMsgs" href="#IncrementalInference.getUpMsgs"><code>IncrementalInference.getUpMsgs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getUpMsgs(cliql)
</code></pre><p>Return the last up message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getDwnMsgs" href="#IncrementalInference.getDwnMsgs"><code>IncrementalInference.getDwnMsgs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getDwnMsgs(cliql)
</code></pre><p>Return the last down message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.hasCliq" href="#IncrementalInference.hasCliq"><code>IncrementalInference.hasCliq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hasCliq(bt, frt)
</code></pre><p>Return boolean on whether the frontal variable <code>frt::Symbol</code> exists somewhere in the <code>::BayesTree</code>.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>hasOrphans</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.initfg" href="#IncrementalInference.initfg"><code>IncrementalInference.initfg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">initfg()
initfg(dfg; sessionname, robotname, username, cloudgraph)
</code></pre><p>Initialize an empty in-memory DistributedFactorGraph <code>::DistributedFactorGraph</code> object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.initInferTreeUp!" href="#IncrementalInference.initInferTreeUp!"><code>IncrementalInference.initInferTreeUp!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Perform tree based initialization of all variables not yet initialized in factor graph.</p><p>Related</p><p>asyncTreeInferUp!</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.isCliqMarginalizedFromVars" href="#IncrementalInference.isCliqMarginalizedFromVars"><code>IncrementalInference.isCliqMarginalizedFromVars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isCliqMarginalizedFromVars(subfg, cliq)
</code></pre><p>Return <code>::Bool</code> on whether all variables in this <code>cliq</code> are marginalzed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.isCliqReadyInferenceUp" href="#IncrementalInference.isCliqReadyInferenceUp"><code>IncrementalInference.isCliqReadyInferenceUp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isCliqReadyInferenceUp(fgl, tree, cliq)
</code></pre><p>Determine if this <code>cliq</code> has been fully initialized and child cliques have completed their full upward inference.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.isInitialized" href="#DistributedFactorGraphs.isInitialized"><code>DistributedFactorGraphs.isInitialized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isInitialized(vert)
</code></pre><p>Returns state of vertex data <code>.initialized</code> flag.</p><p>Notes:</p><ul><li>used by Bayes tree clique logic.</li><li>similar method in DFG</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.isMarginalized" href="#IncrementalInference.isMarginalized"><code>IncrementalInference.isMarginalized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isMarginalized(vert)
</code></pre><p>Return <code>::Bool</code> on whether this variable has been marginalized.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.isTreeSolved" href="#IncrementalInference.isTreeSolved"><code>IncrementalInference.isTreeSolved</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isTreeSolved(treel; skipinitialized)
</code></pre><p>Return true or false depending on whether the tree has been fully initialized/solved/marginalized.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.isPartial" href="#IncrementalInference.isPartial"><code>IncrementalInference.isPartial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isPartial(fcf)
</code></pre><p>Return <code>::Bool</code> on whether factor is a partial constraint.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>isVariable</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.localProduct" href="#IncrementalInference.localProduct"><code>IncrementalInference.localProduct</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Using factor graph object <code>dfg</code>, project belief through connected factors (convolution with conditional) to variable <code>sym</code> followed by a approximate functional product.</p><p>Return: product belief, full proposals, partial dimension proposals, labels</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.ls" href="#DistributedFactorGraphs.ls"><code>DistributedFactorGraphs.ls</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ls(cgl, session, robot, user; sym, neoid, exvid)
</code></pre><p>List neighbors to node in cgl::CloudGraph by returning Dict{Sym}=(exvid, neoid, Symbol[labels]), and can take any of the three as input node identifier. Not specifying an identifier will result in all Variable nodes being returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/Caesar.jl/blob/d441c76fcecce299164ebff89cf617bf2e068dbb/src/cloudgraphs/CloudGraphIntegration.jl#L145-L151">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>lsf</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>lsfPriors</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.lsRear" href="#IncrementalInference.lsRear"><code>IncrementalInference.lsRear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lsRear(fgl)
lsRear(fgl, n)
</code></pre><p>Return array of all variable nodes connected to the last <code>n</code> many poses (<code>:x*</code>).</p><p>Example:</p><pre><code class="language-julia"># Shallow copy the tail end of poses from a factor graph `fg1`
vars = lsRear(fg1, 5)
fg1_r5 = subgraphFromVerts(fg1, vars)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.makeCsmMovie" href="#IncrementalInference.makeCsmMovie"><code>IncrementalInference.makeCsmMovie</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makeCsmMovie(fg, tree)
makeCsmMovie(fg, tree, cliqs; assignhist, show, filename, frames)
</code></pre><p>Convenience function to assign and make video of CSM state machine for <code>cliqs</code>.</p><p>Notes</p><ul><li>Probably several teething issues still (lower priority).</li><li>Use <code>assignhist</code> if solver params async was true, or errored.</li></ul><p>Related</p><p>csmAnimate, printCliqHistorySummary</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.manualinit!" href="#IncrementalInference.manualinit!"><code>IncrementalInference.manualinit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">manualinit!(dfg, vert, pX)
</code></pre><p>Workaround function when first-version (factor graph based) auto initialization fails.  Usually occurs when using factors that have high connectivity to multiple variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.parentCliq" href="#IncrementalInference.parentCliq"><code>IncrementalInference.parentCliq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parentCliq(treel, cliq)
</code></pre><p>Return <code>cliq</code>&#39;s parent clique.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.packFromLocalPotentials!" href="#IncrementalInference.packFromLocalPotentials!"><code>IncrementalInference.packFromLocalPotentials!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">packFromLocalPotentials!(dfg, dens, wfac, cliq, vsym, N)
packFromLocalPotentials!(dfg, dens, wfac, cliq, vsym, N, dbg)
</code></pre><p>Add all potentials associated with this clique and vertid to dens.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RoME.predictVariableByFactor" href="#RoME.predictVariableByFactor"><code>RoME.predictVariableByFactor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">predictVariableByFactor(dfg, targetsym, fct, prevars)
</code></pre><p>Method to compare current and predicted estimate on a variable, developed for testing a new factor before adding to the factor graph.</p><p>Notes</p><ul><li><code>fct</code> does not have to be in the factor graph – likely used to test beforehand.</li><li>function is useful for detecting if <code>multihypo</code> should be used.</li><li><code>approxConv</code> will project the full belief estimate through some factor but must already be in factor graph.</li></ul><p>Example</p><pre><code class="language-julia"># fg already exists containing :x7 and :l3
pp = Pose2Point2BearingRange(Normal(0,0.1),Normal(10,1.0))
# possible new measurement from :x7 to :l3
curr, pred = predictVariableByFactor(fg, :l3, pp, [:x7; :l3])
# example of naive user defined test on fit score
fitscore = minkld(curr, pred)
# `multihypo` can be used as option between existing or new variables</code></pre><p>Related</p><p>approxConv</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.prepBatchTree!" href="#IncrementalInference.prepBatchTree!"><code>IncrementalInference.prepBatchTree!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prepBatchTree!(dfg; ordering, variableOrder, drawpdf, show, filepath, viewerapp, imgs, drawbayesnet, maxparallel)
</code></pre><p>Build Bayes/Junction/Elimination tree.</p><p>Notes</p><ul><li>Default to free qr factorization for variable elimination order.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.prepCliqInitMsgsDown!" href="#IncrementalInference.prepCliqInitMsgsDown!"><code>IncrementalInference.prepCliqInitMsgsDown!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prepCliqInitMsgsDown!(fgl, tree, prnt, cliq; logger, dbgnew)
</code></pre><p>Initialization downward message passing is different from regular inference since it is possible that none of the child cliq variables have been initialized.</p><p>Notes</p><ul><li>init msgs from child upward passes are individually stored in this <code>cliq</code>.</li><li>fresh product of overlapping beliefs are calculated on each function call.</li><li>Assumed that <code>prnt</code> of siblings</li></ul><p>Dev Notes</p><ul><li>This should be the initialization cycle of parent, build up bit by bit...</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.printCliqHistorySummary" href="#IncrementalInference.printCliqHistorySummary"><code>IncrementalInference.printCliqHistorySummary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">printCliqHistorySummary(fid, hist)
</code></pre><p>Print a short summary of state machine history for a clique solve.</p><p>Related:</p><p>getTreeAllFrontalSyms, getCliqSolveHistory, animateCliqStateMachines</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.printgraphmax" href="#IncrementalInference.printgraphmax"><code>IncrementalInference.printgraphmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">printgraphmax(fgl)
</code></pre><p>Print the maximum point values form all variables approximate marginals in the factor graph. The full marginal can be recovered for example <code>X0 = getVertKDE(fg, :x0)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.productpartials!" href="#IncrementalInference.productpartials!"><code>IncrementalInference.productpartials!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">productpartials!(pGM, dummy, partials, manis)
</code></pre><p>Multiply different dimensions from partial constraints individually.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.prodmultiplefullpartials" href="#IncrementalInference.prodmultiplefullpartials"><code>IncrementalInference.prodmultiplefullpartials</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prodmultiplefullpartials(dens, partials, Ndims, N, manis)
</code></pre><p>Multiply various full and partial dimension constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.prodmultipleonefullpartials" href="#IncrementalInference.prodmultipleonefullpartials"><code>IncrementalInference.prodmultipleonefullpartials</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Multiply a single full and several partial dimension constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.resetBuildTreeFromOrder!" href="#IncrementalInference.resetBuildTreeFromOrder!"><code>IncrementalInference.resetBuildTreeFromOrder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resetBuildTreeFromOrder!(fgl, p)
</code></pre><p>Reset factor graph and build a new tree from the provided variable ordering <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.resetCliqSolve!" href="#IncrementalInference.resetCliqSolve!"><code>IncrementalInference.resetCliqSolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resetCliqSolve!(dfg, treel, cliq; solveKey)
</code></pre><p>Reset the state of all variables in a clique to not initialized.</p><p>Notes</p><ul><li>resets numberical values to zeros.</li></ul><p>Dev Notes</p><ul><li>TODO not all kde manifolds will initialize to zero.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.resetData!" href="#IncrementalInference.resetData!"><code>IncrementalInference.resetData!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resetData!(vdata)
</code></pre><p>Partial reset of basic data fields in <code>::VariableNodeData</code> of <code>::FunctionNode</code> structures.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.resetTreeCliquesForUpSolve!" href="#IncrementalInference.resetTreeCliquesForUpSolve!"><code>IncrementalInference.resetTreeCliquesForUpSolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resetTreeCliquesForUpSolve!(treel)
</code></pre><p>Reset the Bayes (Junction) tree so that a new upsolve can be performed.</p><p>Notes</p><ul><li>Will change previous clique status from <code>:downsolved</code> to <code>:initialized</code> only.</li><li>Sets the color of tree clique to <code>lightgreen</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.resetVariable!" href="#IncrementalInference.resetVariable!"><code>IncrementalInference.resetVariable!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resetVariable!(varid; solveKey)
</code></pre><p>Reset the solve state of a variable to uninitialized/unsolved state.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.sandboxCliqResolveStep" href="#IncrementalInference.sandboxCliqResolveStep"><code>IncrementalInference.sandboxCliqResolveStep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sandboxCliqResolveStep(tree, frontal, step)
</code></pre><p>Repeat a solver state machine step without changing history or primary values.</p><p>printCliqSummary, printCliqHistorySummary, getCliqSolveHistory, cliqHistFilterTransitions</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>savejld</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setCliqAsMarginalized!" href="#IncrementalInference.setCliqAsMarginalized!"><code>IncrementalInference.setCliqAsMarginalized!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setCliqAsMarginalized!(cliq, status)
</code></pre><p>Set the marginalized status of a clique.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setCliqStatus!" href="#IncrementalInference.setCliqStatus!"><code>IncrementalInference.setCliqStatus!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setCliqStatus!(cliq, status)
</code></pre><p>Set up initialization or solve status of this <code>cliq</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setDwnMsg!" href="#IncrementalInference.setDwnMsg!"><code>IncrementalInference.setDwnMsg!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setDwnMsg!(cliql, msgs)
</code></pre><p>Set the downward passing message for Bayes (Junction) tree clique <code>cliql</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setfreeze!" href="#IncrementalInference.setfreeze!"><code>IncrementalInference.setfreeze!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setfreeze!(dfg, sym)
</code></pre><p>Set variable(s) <code>sym</code> of factor graph to be marginalized – i.e. not be updated by inference computation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setTreeCliquesMarginalized!" href="#IncrementalInference.setTreeCliquesMarginalized!"><code>IncrementalInference.setTreeCliquesMarginalized!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Set all Bayes (Junction) tree cliques that have all marginalized and initialized variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setUpMsg!" href="#IncrementalInference.setUpMsg!"><code>IncrementalInference.setUpMsg!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setUpMsg!(cliql, msgs)
</code></pre><p>Set the upward passing message for Bayes (Junction) tree clique <code>cliql</code>.</p><p>Dev Notes</p><ul><li>TODO setUpMsg! should also set inferred dimension</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setValKDE!" href="#IncrementalInference.setValKDE!"><code>IncrementalInference.setValKDE!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setValKDE!(vd, pts, bws)
setValKDE!(vd, pts, bws, setinit)
setValKDE!(vd, pts, bws, setinit, inferdim)
</code></pre><p>Set the point centers and bandwidth parameters of a variable node, also set <code>isInitialized=true</code> if <code>setinit::Bool=true</code> (as per default).</p><p>Notes</p><ul><li><code>initialized</code> is used for initial solve of factor graph where variables are not yet initialized.</li><li><code>inferdim</code> is used to identify if the initialized was only partial.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setVariableInitialized!" href="#IncrementalInference.setVariableInitialized!"><code>IncrementalInference.setVariableInitialized!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setVariableInitialized!(varid, status)
</code></pre><p>Set variable initialized status.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.setVariableInferDim!" href="#IncrementalInference.setVariableInferDim!"><code>IncrementalInference.setVariableInferDim!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setVariableInferDim!(varid, val)
</code></pre><p>Set method for the inferred dimension value in a variable.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>showVariable</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.solveCliq!" href="#IncrementalInference.solveCliq!"><code>IncrementalInference.solveCliq!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Perform inference over one clique in the Bayes tree according to <code>opt::SolverParams</code>.</p><p>Example</p><pre><code class="language-julia">tree = wipeBuildNewTree!(fg)
smt, hist = solveCliq!(fg, tree, :x1 [,cliqHistories=hist] )</code></pre><p>Related</p><p>solveTree!, wipeBuildNewTree!</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.solveCliqWithStateMachine!" href="#IncrementalInference.solveCliqWithStateMachine!"><code>IncrementalInference.solveCliqWithStateMachine!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solveCliqWithStateMachine!(dfg, tree, frontal; iters, downsolve, recordhistory, verbose, nextfnc, prevcsmc)
</code></pre><p>Standalone state machine solution for a single clique.</p><p>Related:</p><p>initInferTreeUp!</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.solveTree!" href="#IncrementalInference.solveTree!"><code>IncrementalInference.solveTree!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Perform inference over the Bayes tree according to <code>opt::SolverParams</code>.</p><p>Notes</p><ul><li>Variety of options, including fixed-lag solving – see <code>getSolverParams(fg)</code> for details.</li></ul><p>Example</p><pre><code class="language-julia"># without [or with] compute recycling
tree, smt, hist = solveTree!(fg [,tree])</code></pre><p>Related</p><p>solveCliq!, wipeBuildNewTree!</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.transferUpdateSubGraph!" href="#IncrementalInference.transferUpdateSubGraph!"><code>IncrementalInference.transferUpdateSubGraph!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transferUpdateSubGraph!(dest, src)
transferUpdateSubGraph!(dest, src, syms)
transferUpdateSubGraph!(dest, src, syms, logger)
</code></pre><p>Transfer contents of <code>src::AbstractDFG</code> variables <code>syms::Vector{Symbol}</code> to <code>dest::AbstractDFG</code>.</p><p>Notes</p><ul><li>Reads, <code>dest</code> := <code>src</code>, for all <code>syms</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.treeProductDwn" href="#IncrementalInference.treeProductDwn"><code>IncrementalInference.treeProductDwn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">treeProductDwn(fg, tree, cliq, sym; N, dbg)
</code></pre><p>Calculate a fresh–-single step–-approximation to the variable <code>sym</code> in clique <code>cliq</code> as though during the downward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variable based on the structure of variables, factors, and incoming messages to this clique. Which clique to be used is defined by frontal variable symbols (<code>cliq</code> in this case) – see <code>whichCliq(...)</code> for more details.  The <code>sym</code> symbol indicates which symbol of this clique to be calculated.  <strong>Note</strong> that the <code>sym</code> variable must appear in the clique where <code>cliq</code> is a frontal variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.treeProductUp" href="#IncrementalInference.treeProductUp"><code>IncrementalInference.treeProductUp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">treeProductUp(fg, tree, cliq, sym; N, dbg)
</code></pre><p>Calculate a fresh (single step) approximation to the variable <code>sym</code> in clique <code>cliq</code> as though during the upward message passing.  The full inference algorithm may repeatedly calculate successive apprimxations to the variables based on the structure of the clique, factors, and incoming messages. Which clique to be used is defined by frontal variable symbols (<code>cliq</code> in this case) – see <code>whichCliq(...)</code> for more details.  The <code>sym</code> symbol indicates which symbol of this clique to be calculated.  <strong>Note</strong> that the <code>sym</code> variable must appear in the clique where <code>cliq</code> is a frontal variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.unfreezeVariablesAll!" href="#IncrementalInference.unfreezeVariablesAll!"><code>IncrementalInference.unfreezeVariablesAll!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Free all variables from marginalization.</p><p>Related</p><p>dontMarginalizeVariablesAll!</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.dontMarginalizeVariablesAll!" href="#IncrementalInference.dontMarginalizeVariablesAll!"><code>IncrementalInference.dontMarginalizeVariablesAll!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Free all variables from marginalization.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.updateFGBT!" href="#IncrementalInference.updateFGBT!"><code>IncrementalInference.updateFGBT!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">updateFGBT!(fg, bt, cliqID, drt; dbg, fillcolor, logger)
</code></pre><p>Update cliq <code>cliqID</code> in Bayes (Juction) tree <code>bt</code> according to contents of <code>ddt</code> – intended use is to update main clique after a downward belief propagation computation has been completed per clique.</p></div></section><section><div><pre><code class="language-julia">updateFGBT!(fg, cliq, urt; dbg, fillcolor, logger)
</code></pre><p>Update cliq <code>cliqID</code> in Bayes (Juction) tree <code>bt</code> according to contents of <code>urt</code> – intended use is to update main clique after a upward belief propagation computation has been completed per clique.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.updateTreeCliquesAsMarginalizedFromVars!" href="#IncrementalInference.updateTreeCliquesAsMarginalizedFromVars!"><code>IncrementalInference.updateTreeCliquesAsMarginalizedFromVars!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">updateTreeCliquesAsMarginalizedFromVars!(fgl, tree)
</code></pre><p>Run through entire tree and set cliques as marginalized if all clique variables are marginalized.</p><p>Notes:</p><ul><li>TODO can be made fully parallel, consider converting for use with <code>@threads</code> <code>for</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.upGibbsCliqueDensity" href="#IncrementalInference.upGibbsCliqueDensity"><code>IncrementalInference.upGibbsCliqueDensity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">upGibbsCliqueDensity(inp)
upGibbsCliqueDensity(inp, N)
upGibbsCliqueDensity(inp, N, dbg)
upGibbsCliqueDensity(inp, N, dbg, iters)
upGibbsCliqueDensity(inp, N, dbg, iters, logger)
</code></pre><p>Perform computations required for the upward message passing during belief propation on the Bayes (Junction) tree. This function is usually called as via remote_call for multiprocess dispatch.</p><p>Example</p><pre><code class="language-julia">inp = ExploreTreeType(fg,tree,cliq,parent,childmsgs)
urt = upGibbsCliqueDensity(inp)</code></pre><ul><li><code>fg</code> factor graph,</li><li><code>tree</code> Bayes tree,</li><li><code>cliq</code> which cliq to perform the computation on,</li><li><code>parent</code> the parent clique to where the upward message will be sent,</li><li><code>childmsgs</code> is for any incoming messages from child cliques.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.upMsg" href="#IncrementalInference.upMsg"><code>IncrementalInference.upMsg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">upMsg(cliq)
</code></pre><p>Return the last up message stored in <code>cliq</code> of Bayes (Junction) tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.wipeBuildNewTree!" href="#IncrementalInference.wipeBuildNewTree!"><code>IncrementalInference.wipeBuildNewTree!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Build a completely new Bayes (Junction) tree, after first wiping clean all temporary state in fg from a possibly pre-existing tree.</p><p>Related:</p><p>buildTreeFromOrdering!</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.writeGraphPdf" href="#IncrementalInference.writeGraphPdf"><code>IncrementalInference.writeGraphPdf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">writeGraphPdf(fgl; viewerapp, filepath, engine, show)
</code></pre><p>Draw and show the factor graph <code>&lt;:AbstractDFG</code> via system graphviz and pdf app.</p><p>Notes</p><ul><li>Should not be calling outside programs.</li><li>Need long term solution</li><li>DFG&#39;s <code>toDotFile</code> a better solution – view with <code>xdot</code> application.</li><li>also try <code>engine={&quot;sfdp&quot;,&quot;fdp&quot;,&quot;dot&quot;,&quot;twopi&quot;,&quot;circo&quot;,&quot;neato&quot;}</code></li></ul><p>Future:</p><ul><li>Might be kept with different call strategy since this function so VERY useful!</li><li>Major issue that this function calls an external program such as &quot;evince&quot;, which should be  under user control only.</li><li>Maybe solution is</li><li><code>toDot(fg,file=...); @async run(`xdot file.dot`)</code>, or<ul><li><code>toDot(fg,file=...); exportPdf(...); @async run(`evince ...pdf`)</code>.</li></ul></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.resetVariableAllInitializations!" href="#IncrementalInference.resetVariableAllInitializations!"><code>IncrementalInference.resetVariableAllInitializations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resetVariableAllInitializations!(fgl)
</code></pre><p>Reset initialization flag on all variables in <code>::FactorGraphs</code>.</p><p>Notes</p><ul><li>Numerical values remain, but inference will overwrite since init flags are now <code>false</code>.</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../refs/literature/">« References</a><a class="docs-footer-nextpage" href="../vis_func_ref/">Visualization Reference »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 2 January 2020 07:31">Thursday 2 January 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
