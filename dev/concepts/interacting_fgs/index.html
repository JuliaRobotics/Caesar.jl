<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving and Interacting · Caesar.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Caesar.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Welcome</span><ul><li><a class="tocitem" href="../../installation_environment/">Installation</a></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../concepts/">Initial Concepts</a></li><li><a class="tocitem" href="../building_graphs/">Building Factor Graphs</a></li><li class="is-active"><a class="tocitem" href>Solving and Interacting</a><ul class="internal"><li><a class="tocitem" href="#Saving-and-Loading"><span>Saving and Loading</span></a></li><li><a class="tocitem" href="#Querying-the-FactorGraph"><span>Querying the FactorGraph</span></a></li><li class="toplevel"><a class="tocitem" href="#Solving-Graphs"><span>Solving Graphs</span></a></li><li><a class="tocitem" href="#Using-Incremental-Updates-(Clique-Recycling-I)"><span>Using Incremental Updates (Clique Recycling I)</span></a></li><li><a class="tocitem" href="#Using-Clique-out-marginalization-(Clique-Recycling-II)"><span>Using Clique out-marginalization (Clique Recycling II)</span></a></li><li class="toplevel"><a class="tocitem" href="#Extracting-Belief-Results-(and-PPE)"><span>Extracting Belief Results (and PPE)</span></a></li><li><a class="tocitem" href="#Parametric-Point-Estimates-(PPE)"><span>Parametric Point Estimates (PPE)</span></a></li><li><a class="tocitem" href="#Getting-Many-Marginal-Samples"><span>Getting Many Marginal Samples</span></a></li><li><a class="tocitem" href="#Building-On-Manifold-KDEs"><span>Building On-Manifold KDEs</span></a></li><li><a class="tocitem" href="#Logging-Output-(Unique-Folder)"><span>Logging Output (Unique Folder)</span></a></li><li><a class="tocitem" href="#Other-Useful-Functions"><span>Other Useful Functions</span></a></li></ul></li><li><a class="tocitem" href="../available_varfacs/">Internal Variables/Factors</a></li><li><a class="tocitem" href="../dataassociation/">Multi-Modal/Hypothesis</a></li><li><a class="tocitem" href="../flux_factors/">Flux (NN) Factors</a></li><li><a class="tocitem" href="../2d_plotting/">Plotting (2D)</a></li><li><a class="tocitem" href="../entry_data/">Entry=&gt;Data Blob</a></li><li><a class="tocitem" href="../multilang/">Multi-Language Support</a></li><li><a class="tocitem" href="../database_interactions/">Cloud Server/Database</a></li><li><a class="tocitem" href="../multisession/">Multi-session/agent Solving</a></li><li><a class="tocitem" href="../arena_visualizations/">Visualization (3D)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/examples/">Caesar Examples</a></li><li><a class="tocitem" href="../../examples/basic_continuousscalar/">ContinuousScalar as 1D Example</a></li><li><a class="tocitem" href="../../examples/basic_slamedonut/">Under-defined Trilateration, 2D</a></li><li><a class="tocitem" href="../../examples/basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="tocitem" href="../../examples/interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li><li><a class="tocitem" href="../../examples/using_ros/">ROS Middleware</a></li><li><a class="tocitem" href="../../examples/deadreckontether/">Dead Reckon Tether</a></li></ul></li><li><span class="tocitem">Principles</span><ul><li><a class="tocitem" href="../../principles/filterCorrespondence/">Filters vs. Graphs</a></li><li><a class="tocitem" href="../../principles/approxConvDensities/">Generic Convolutions</a></li><li><a class="tocitem" href="../../principles/multiplyingDensities/">Multiplying Functions (.py)</a></li><li><a class="tocitem" href="../../principles/bayestreePrinciples/">Bayes (Junction) tree</a></li><li><a class="tocitem" href="../../principles/initializingOnBayesTree/">Advanced Bayes Tree Topics</a></li><li><a class="tocitem" href="../mmisam_alg/">Multimodal iSAM Algorithm</a></li></ul></li><li><span class="tocitem">How to Expand?</span><ul><li><a class="tocitem" href="../../examples/adding_variables_factors/">Custom Variables and Factors</a></li><li><a class="tocitem" href="../../examples/custom_variables/">Creating Variables</a></li><li><a class="tocitem" href="../../examples/basic_definingfactors/">Creating Factors</a></li></ul></li><li><span class="tocitem">Developer Zone</span><ul><li><a class="tocitem" href="../../dev/wiki/">Wiki Pointers</a></li><li><a class="tocitem" href="../../principles/interm_dynpose/">Creating DynPose Factor</a></li><li><a class="tocitem" href="../../dev/known_issues/">Known Issue List</a></li></ul></li><li><span class="tocitem">Literature</span><ul><li><a class="tocitem" href="../../refs/literature/">References</a></li></ul></li><li><span class="tocitem">Function Reference</span><ul><li><a class="tocitem" href="../../func_ref/">Caesar&#39;s Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li class="is-active"><a href>Solving and Interacting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solving and Interacting</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/concepts/interacting_fgs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Factor-Graph-as-a-Whole"><a class="docs-heading-anchor" href="#Factor-Graph-as-a-Whole">Factor Graph as a Whole</a><a id="Factor-Graph-as-a-Whole-1"></a><a class="docs-heading-anchor-permalink" href="#Factor-Graph-as-a-Whole" title="Permalink"></a></h1><h2 id="Saving-and-Loading"><a class="docs-heading-anchor" href="#Saving-and-Loading">Saving and Loading</a><a id="Saving-and-Loading-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-and-Loading" title="Permalink"></a></h2><p>Assuming some factor graph object has been constructed by hand or automation, it is often very useful to be able to store that factor graph to file for later loading, solving, analysis etc.  Caesar.jl provides such functionality through easy saving and loading.  To save a factor graph, simply do:</p><pre><code class="language-julia">saveDFG(&quot;/somewhere/myfg&quot;, fg)</code></pre><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.saveDFG" href="#DistributedFactorGraphs.saveDFG"><code>DistributedFactorGraphs.saveDFG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">saveDFG(folder, dfg)
</code></pre><p>Save a DFG to a folder. Will create/overwrite folder if it exists.</p><p>DevNotes:</p><ul><li>TODO remove <code>compress</code> kwarg.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">using DistributedFactorGraphs, IncrementalInference
# Create a DFG - can make one directly, e.g. LightDFG{NoSolverParams}() or use IIF:
dfg = initfg()
# ... Add stuff to graph using either IIF or DFG:
v1 = addVariable!(dfg, :a, ContinuousScalar, tags = [:POSE], solvable=0)
# Now save it:
saveDFG(dfg, &quot;/tmp/saveDFG.tar.gz&quot;)</code></pre></div></section></article><p>Similarly in the same or a new Julia context, you can load a factor graph object</p><pre><code class="language-julia"># using Caesar
fg_ = loadDFG(&quot;/somwhere/myfg&quot;)</code></pre><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.loadDFG" href="#DistributedFactorGraphs.loadDFG"><code>DistributedFactorGraphs.loadDFG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">loadDFG(filename)
</code></pre><p>Convenience wrapper to <code>DFG.loadDFG!</code> taking only one argument, the file name, to load a DFG object in standard format.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.loadDFG!" href="#DistributedFactorGraphs.loadDFG!"><code>DistributedFactorGraphs.loadDFG!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">loadDFG!(dfgLoadInto, dst)
</code></pre><p>Load a DFG from a saved folder. Always provide the IIF module as the second parameter.</p><p><strong>Example</strong></p><pre><code class="language-julia">using DistributedFactorGraphs, IncrementalInference
# Create a DFG - can make one directly, e.g. LightDFG{NoSolverParams}() or use IIF:
dfg = initfg()
# Load the graph
loadDFG!(dfg, &quot;/tmp/savedgraph.tar.gz&quot;)
# Use the DFG as you do normally.
ls(dfg)</code></pre></div></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Julia natively provides a direct in memory <code>deepcopy</code> function for making duplicate objects if you wish to keep a backup of the factor graph, e.g.</p><pre><code class="language-julia">fg2 = deepcopy(fg)</code></pre></div></div><h3 id="Adding-an-EntryData-Blob-store"><a class="docs-heading-anchor" href="#Adding-an-EntryData-Blob-store">Adding an <code>Entry=&gt;Data</code> Blob store</a><a id="Adding-an-EntryData-Blob-store-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-an-EntryData-Blob-store" title="Permalink"></a></h3><p>A later part of the documentation will show <a href="https://juliarobotics.org/Caesar.jl/latest/concepts/entry_data/">how to include a <code>Entry=&gt;Data</code> blob store</a>.</p><h2 id="Querying-the-FactorGraph"><a class="docs-heading-anchor" href="#Querying-the-FactorGraph">Querying the FactorGraph</a><a id="Querying-the-FactorGraph-1"></a><a class="docs-heading-anchor-permalink" href="#Querying-the-FactorGraph" title="Permalink"></a></h2><h3 id="List-Variables:"><a class="docs-heading-anchor" href="#List-Variables:">List Variables:</a><a id="List-Variables:-1"></a><a class="docs-heading-anchor-permalink" href="#List-Variables:" title="Permalink"></a></h3><p>A quick summary of the variables in the factor graph can be retrieved with:</p><pre><code class="language-julia"># List variables
ls(fg)
# List factors attached to x0
ls(fg, :x0)
# TODO: Provide an overview of getVal, getVert, getBW, getBelief, etc.</code></pre><p>It is possible to filter the listing with <code>Regex</code> string:</p><pre><code class="language-julia">ls(fg, r&quot;x\d&quot;)</code></pre><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.ls" href="#DistributedFactorGraphs.ls"><code>DistributedFactorGraphs.ls</code></a> — <span class="docstring-category">Function</span></header><section><div><p>List the DFGVariables in the DFG. Optionally specify a label regular expression to retrieves a subset of the variables. Tags is a list of any tags that a node must have (at least one match).</p><p>Notes:</p><ul><li>Returns <code>Vector{Symbol}</code></li></ul></div></section><section><div><pre><code class="language-julia">ls(dfg)
ls(dfg, node; solvable)
</code></pre><p>Retrieve a list of labels of the immediate neighbors around a given variable or factor.</p></div></section></article><pre><code class="language-julia">unsorted = intersect(ls(fg, r&quot;x&quot;), ls(fg, Pose2))  # by regex

# sorting in most natural way (as defined by DFG)
sorted = sortDFG(unsorted)</code></pre><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.sortDFG" href="#DistributedFactorGraphs.sortDFG"><code>DistributedFactorGraphs.sortDFG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sortDFG(vars; by, kwargs...)
</code></pre><p>Convenience wrapper for <code>Base.sort</code>. Sort variable (factor) lists in a meaningful way (by <code>timestamp</code>, <code>label</code>, etc), for example <code>[:april;:x1_3;:x1_6;]</code> Defaults to sorting by timestamp for variables and factors and using <code>natural_lt</code> for Symbols. See Base.sort for more detail.</p><p>Notes</p><ul><li>Not fool proof, but does better than native sort.</li></ul><p>Example</p><p><code>sortDFG(ls(dfg))</code> <code>sortDFG(ls(dfg), by=getLabel, lt=natural_lt)</code></p><p>Related</p><p>ls, lsf</p></div></section></article><h3 id="List-Factors:"><a class="docs-heading-anchor" href="#List-Factors:">List Factors:</a><a id="List-Factors:-1"></a><a class="docs-heading-anchor-permalink" href="#List-Factors:" title="Permalink"></a></h3><pre><code class="language-julia">unsorted = lsf(fg)
unsorted = ls(fg, Pose2Point2BearingRange)</code></pre><p>or using the <code>tags</code> (works for variables too):</p><pre><code class="language-julia">lsf(fg, tags=[:APRILTAGS;])</code></pre><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.lsf" href="#DistributedFactorGraphs.lsf"><code>DistributedFactorGraphs.lsf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lsf(dfg)
lsf(dfg, regexFilter; tags, solvable)
</code></pre><p>List the DFGFactors in the DFG. Optionally specify a label regular expression to retrieves a subset of the factors.</p><p>Notes</p><ul><li>Return <code>Vector{Symbol}</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.lsfPriors" href="#DistributedFactorGraphs.lsfPriors"><code>DistributedFactorGraphs.lsfPriors</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return vector of prior factor symbol labels in factor graph <code>dfg</code>.</p><p>Notes:</p><ul><li>Returns <code>Vector{Symbol}</code></li></ul></div></section></article><p>There are a variety of functions to query the factor graph, please refer to <a href="../../func_ref/">Function Reference</a> for details and note that many functions still need to be added to this documentation.</p><h3 id="Extracting-a-Subgraph"><a class="docs-heading-anchor" href="#Extracting-a-Subgraph">Extracting a Subgraph</a><a id="Extracting-a-Subgraph-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-a-Subgraph" title="Permalink"></a></h3><p>Sometimes it is useful to make a deepcopy of a segment of the factor graph for some purpose:</p><pre><code class="language-julia">sfg = buildSubgraph(fg, [:x1;:x2;:l7], 1)</code></pre><h1 id="Solving-Graphs"><a class="docs-heading-anchor" href="#Solving-Graphs">Solving Graphs</a><a id="Solving-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-Graphs" title="Permalink"></a></h1><p>When you have built the graph, you can call the solver to perform inference with the following:</p><pre><code class="language-julia"># Perform inference
tree, smt, hist = solveTree!(fg)</code></pre><p>The returned Bayes (Junction) <code>tree</code> object is described in more detail on <a href="https://juliarobotics.org/Caesar.jl/latest/principles/bayestreePrinciples/">a dedicated documentation page</a>, while <code>smt</code> and <code>hist</code> return values most closely relate to development and debug outputs which can be ignored during general use.  Should an error occur during, the exception information is easily accessible in the <code>smt</code> object (as well as file logs which default to <code>/tmp/caesar/</code>).</p><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.solveTree!" href="#IncrementalInference.solveTree!"><code>IncrementalInference.solveTree!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solveTree!(dfgl)
solveTree!(dfgl, oldtree; timeout, storeOld, verbose, verbosefid, delaycliqs, recordcliqs, limititercliqs, injectDelayBefore, skipcliqids, eliminationOrder, variableOrder, eliminationConstraints, variableConstraints, smtasks, dotreedraw, runtaskmonitor, algorithm, multithread)
</code></pre><p>Perform inference over the Bayes tree according to <code>opt::SolverParams</code>.</p><p>Notes</p><ul><li>Variety of options, including fixed-lag solving – see <code>getSolverParams(fg)</code> for details.<ul><li>See online Documentation for more details: https://juliarobotics.org/Caesar.jl/latest/</li></ul></li><li>Latest result always stored in <code>solvekey=:default</code>.</li><li>Experimental <code>storeOld::Bool=true</code> will duplicate the current result as supersolve <code>:default_k</code>.<ul><li>Based on <code>solvable==1</code> assumption.</li></ul></li><li><code>limititercliqs</code> allows user to limit the number of iterations a specific CSM does.</li><li>keywords <code>verbose</code> and <code>verbosefid::IOStream</code> can be used together to to send output to file or default <code>stdout</code>.</li><li>keyword <code>recordcliqs=[:x0; :x7...]</code> identifies by frontals which cliques to record CSM steps.<ul><li>See <a href="concepts/@ref"><code>repeatCSMStep!</code></a>, <a href="concepts/@ref"><code>printCSMHistoryLogical</code></a>, <a href="concepts/@ref"><code>printCSMHistorySequential</code></a></li></ul></li></ul><p>Example</p><pre><code class="language-julia"># pass in old `tree` to enable compute recycling -- see online Documentation for more details
tree, smt, hist = solveTree!(fg [,tree])</code></pre><p>Related</p><p><a href="../../func_ref/#IncrementalInference.solveCliq!"><code>solveCliq!</code></a>, <a href="../../principles/bayestreePrinciples/#IncrementalInference.buildTreeReset!"><code>buildTreeReset!</code></a>, <a href="concepts/@ref"><code>repeatCSMStep</code></a>, <a href="concepts/@ref"><code>printCSMHistoryLogical</code></a></p></div></section></article><h2 id="Using-Incremental-Updates-(Clique-Recycling-I)"><a class="docs-heading-anchor" href="#Using-Incremental-Updates-(Clique-Recycling-I)">Using Incremental Updates (Clique Recycling I)</a><a id="Using-Incremental-Updates-(Clique-Recycling-I)-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Incremental-Updates-(Clique-Recycling-I)" title="Permalink"></a></h2><p>One of the major features of the MM-iSAMv2 algorithm (implemented by <a href="http://www.github.com/JuliaRobotics/IncrementalInference.jl">IncrementalInference.jl</a>) is reducing computational load by recycling and marginalizing different (usually older) parts of the factor graph.  In order to utilize the benefits of recycing, the previous Bayes (Junction) tree should also be provided as input (see fixed-lag examples for more details):</p><pre><code class="language-julia">tree, smt, hist = solveTree!(fg, tree)</code></pre><h2 id="Using-Clique-out-marginalization-(Clique-Recycling-II)"><a class="docs-heading-anchor" href="#Using-Clique-out-marginalization-(Clique-Recycling-II)">Using Clique out-marginalization (Clique Recycling II)</a><a id="Using-Clique-out-marginalization-(Clique-Recycling-II)-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Clique-out-marginalization-(Clique-Recycling-II)" title="Permalink"></a></h2><p>When building sysmtes with limited computation resources, the out-marginalization of cliques on the Bayes tree can be used.  This approach limits the amount of variables that are inferred on each solution of the graph.  This method is also a compliment to the above Incremental Recycling – these two methods can work in tandem.  There is a default setting for a FIFO out-marginalization strategy (with some additional tricks):</p><pre><code class="language-julia">defaultFixedLagOnTree!(fg, 50, limitfixeddown=true)</code></pre><p>This call will keep the latest 50 variables fluid for inference during Bayes tree inference.  The keyword <code>limitfixeddown=true</code> in this case will also prevent downward message passing on the Bayes tree from propagating into the out-marginalized branches on the tree.  A later page in this documentation will discuss how the inference algorithm and Bayes tree aspects are put together.</p><h1 id="Extracting-Belief-Results-(and-PPE)"><a class="docs-heading-anchor" href="#Extracting-Belief-Results-(and-PPE)">Extracting Belief Results (and PPE)</a><a id="Extracting-Belief-Results-(and-PPE)-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-Belief-Results-(and-PPE)" title="Permalink"></a></h1><p>Once you have solved the graph, you can review the full marginal with:</p><pre><code class="language-julia">X0 = getBelief(fg, :x0)
# Evaluate the marginal density function just for fun at [0.0, 0, 0].
X0(zeros(3,1))</code></pre><p>This object is currently a Kernel Density which contains kernels at specific points on the associated manifold.  These kernel locations can be retrieved with:</p><pre><code class="language-julia">X0pts = getPoints(X0)</code></pre><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getBelief" href="#IncrementalInference.getBelief"><code>IncrementalInference.getBelief</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getBelief(vnd)
</code></pre><p>Get KernelDensityEstimate kde estimate stored in variable node.</p></div></section></article><h2 id="Parametric-Point-Estimates-(PPE)"><a class="docs-heading-anchor" href="#Parametric-Point-Estimates-(PPE)">Parametric Point Estimates (PPE)</a><a id="Parametric-Point-Estimates-(PPE)-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Point-Estimates-(PPE)" title="Permalink"></a></h2><p>Since Caesar.jl is build around the each variable state being estimated as a total marginal posterior belief, it is often useful to get the equivalent parametric point estimate from the belief.  Many of these computations are already done by the inference library and avalable via the various <a href="concepts/@ref"><code>getPPE</code></a> methods, e.g.:</p><pre><code class="language-julia">getPPE(fg, :l3)
getPPESuggested(fg, :l5)</code></pre><p>There are values for mean, max, or hybrid combinations.</p><h2 id="Getting-Many-Marginal-Samples"><a class="docs-heading-anchor" href="#Getting-Many-Marginal-Samples">Getting Many Marginal Samples</a><a id="Getting-Many-Marginal-Samples-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Many-Marginal-Samples" title="Permalink"></a></h2><p>It is also possible to sample the above belief objects for more samples:</p><pre><code class="language-julia">pts = rand(X0, 200)</code></pre><h2 id="Building-On-Manifold-KDEs"><a class="docs-heading-anchor" href="#Building-On-Manifold-KDEs">Building On-Manifold KDEs</a><a id="Building-On-Manifold-KDEs-1"></a><a class="docs-heading-anchor-permalink" href="#Building-On-Manifold-KDEs" title="Permalink"></a></h2><p>These kernel density belief objects can be constructed from points as follows:</p><pre><code class="language-julia">X0_ = manikde!(pts, Pose2)</code></pre><h2 id="Logging-Output-(Unique-Folder)"><a class="docs-heading-anchor" href="#Logging-Output-(Unique-Folder)">Logging Output (Unique Folder)</a><a id="Logging-Output-(Unique-Folder)-1"></a><a class="docs-heading-anchor-permalink" href="#Logging-Output-(Unique-Folder)" title="Permalink"></a></h2><p>Each new factor graph is designated a unique folder in <code>/tmp/caesar</code>.  This is usaully used for debugging or large scale test analysis.  Sometimes it may be useful for the user to also use this temporary location.  The location is stored in the <code>SolverParams</code>:</p><pre><code class="language-julia">getSolverParams(fg).logpath</code></pre><p>The functions of interest are:</p><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getLogPath" href="#IncrementalInference.getLogPath"><code>IncrementalInference.getLogPath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getLogPath(opt)
</code></pre><p>Get the folder location where debug and solver information is recorded for a particular factor graph.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.joinLogPath" href="#IncrementalInference.joinLogPath"><code>IncrementalInference.joinLogPath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">joinLogPath(opt, str)
</code></pre><p>Append <code>str</code> onto factor graph log path as convenience function.</p></div></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A useful tip for doing large scale processing might be to reduce amount of write operations to a solid-state drive that will be written to default location <code>/tmp/caesar</code> by simplying adding a symbolic link to a USB drive or SDCard, perhaps similar to:</p><pre><code class="language-bash">cd /tmp
mkdir -p /media/MYFLASHDRIVE/caesar
ln -s /media/MYFLASHDRIVE/caesar caesar</code></pre></div></div><h2 id="Other-Useful-Functions"><a class="docs-heading-anchor" href="#Other-Useful-Functions">Other Useful Functions</a><a id="Other-Useful-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Useful-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getFactorDim" href="#IncrementalInference.getFactorDim"><code>IncrementalInference.getFactorDim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getFactorDim(w::Vararg{Any,N} where N) -&gt; Any
</code></pre><p>Return the number of dimensions this factor vertex <code>fc</code> influences.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.getManifolds" href="#DistributedFactorGraphs.getManifolds"><code>DistributedFactorGraphs.getManifolds</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Interface function to return the <code>variableType</code> manifolds of an InferenceVariable, extend this function for all Types&lt;:InferenceVariable.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../building_graphs/">« Building Factor Graphs</a><a class="docs-footer-nextpage" href="../available_varfacs/">Internal Variables/Factors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 10 January 2021 04:51">Sunday 10 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
