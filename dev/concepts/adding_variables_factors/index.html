<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adding New Variables and Factors · Caesar.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Caesar.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Getting Started</span><ul><li><a class="toctext" href="../../installation_environment/">Installation</a></li></ul></li><li><span class="toctext">Concepts</span><ul><li><a class="toctext" href="../concepts/">Caesar Concepts</a></li><li><a class="toctext" href="../building_graphs/">Building Factor Graphs</a></li><li><a class="toctext" href="../arena_visualizations/">Arena Visualization</a></li><li><a class="toctext" href="../zmq/">Using Caesar&#39;s Multi-Language Support</a></li><li class="current"><a class="toctext" href>Adding New Variables and Factors</a><ul class="internal"><li><a class="toctext" href="#Considerations-1">Considerations</a></li><li><a class="toctext" href="#Getting-Started-1">Getting Started</a></li><li><a class="toctext" href="#Reviewing-the-Existing-Types-1">Reviewing the Existing Types</a></li><li><a class="toctext" href="#Creating-a-Repository-1">Creating a Repository</a></li><li><a class="toctext" href="#Creating-New-Variables-1">Creating New Variables</a></li><li><a class="toctext" href="#Creating-New-Factors-1">Creating New Factors</a></li><li><a class="toctext" href="#Unit-Tests-1">Unit Tests</a></li><li><a class="toctext" href="#Using-your-Types-with-the-Caesar-Solver-1">Using your Types with the Caesar Solver</a></li><li><a class="toctext" href="#Contributing-to-Community-1">Contributing to Community</a></li></ul></li><li><a class="toctext" href="../database_interactions/">Using Caesar Database Operation</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/examples/">Caesar Examples</a></li><li><a class="toctext" href="../../examples/basic_hexagonal2d/">Basics: Hexagonal 2D SLAM</a></li><li><a class="toctext" href="../../examples/basic_slamedonut/">Basics: Singular Ranges-only SLAM</a></li><li><a class="toctext" href="../../examples/basic_continuousscalar/">Basics: ContinuousScalar</a></li><li><a class="toctext" href="../../examples/basic_definingfactors/">Basics: Creating Custom Variables and Factors</a></li><li><a class="toctext" href="../../examples/interm_dynpose/">Intermediate Tutorial: Creating DynPose Factor</a></li><li><a class="toctext" href="../../examples/interm_fixedlag_hexagonal/">Intermediate Tutorial: Fixed-Lag Solving</a></li></ul></li><li><a class="toctext" href="../../func_ref/">Function Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li>Concepts</li><li><a href>Adding New Variables and Factors</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/concepts/adding_variables_factors.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Adding New Variables and Factors</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Creating-New-Variables-and-Factors-1" href="#Creating-New-Variables-and-Factors-1">Creating New Variables and Factors</a></h1><p>In most scenarios, the existing variables and factors should be sufficient for most robotics applications. Caesar however, is extensible and allows you to easily incorporate your own variable and factor types for specialized applications.</p><h2><a class="nav-anchor" id="Considerations-1" href="#Considerations-1">Considerations</a></h2><p>A couple of important points:</p><ul><li>You <strong>do not need</strong> to modify/fork/edit internal Caesar/RoME/IncrementalInference source code to introduce new variable and factor types!</li><li>As long as the factors exist in the working space when the solver is run, the factors are automatically used – this is possible due to Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/methods/index.html">multiple dispatch design</a></li><li>Caesar is designed to allow you to add new variables and factors to your own independent repository and incorporate them at will at compile-time or even run-time</li><li>Residual function definitions for new factors types use a <a href="https://discourse.julialang.org/t/documenting-a-functor-callable-struct/8444">callable struct (a.k.a functor) architecture</a> to simultaneously allow:  <ul><li>Multiple dispatch (i.e. &#39;polymorphic&#39; behavior)</li><li>Meta-data and in-place memory storage for advanced and performant code</li><li>An outside callback implementation style</li></ul></li><li>In most robotics scenarios, there is no need for new variables or factors:<ul><li>Variables have various mechanisms that allow you to attach data to them, e.g. raw sensory data or identified April tags, so you do not need to create a new variable type just to store data</li><li>New variables are required only if you are representing a new state - TODO: Example of needed state</li><li>New factors are needed if:<ul><li>You need to represent a constraint for a variable (known as a singleton) and that constraint type doesn&#39;t exist</li><li>You need to represent a constraint between two variables and that constraint type doesn&#39;t exist</li></ul></li></ul></li></ul><h2><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h2><p>We suggest the following design pattern for developing and building new factors:</p><ol><li>You have reviewed the variable and factor types available in Caesar, RoME, and IncrementalInference and a new type is required - please see <a href="../building_graphs/">Building and Solving Graphs</a> if you want to review what is currently available</li><li>Create a GitHub repository to store the new types</li><li>Create your new variable types</li><li>Create your new factor types</li><li>Implement unit tests to validate the correct operation of the types</li><li>Set up your solver to make use the custom types</li></ol><p>1.1. This is much easier than it sounds</p><ol><li>If the code is public and may be useful to the community, we ask if you could submit an issue against Caesar with information about the new types and the repository. Ideally we&#39;d like to continually improve the core code and fold in community contributions.</li></ol><p>The remainder of this section discusses each of these steps.</p><h2><a class="nav-anchor" id="Reviewing-the-Existing-Types-1" href="#Reviewing-the-Existing-Types-1">Reviewing the Existing Types</a></h2><p>Please see <a href="../building_graphs/">Building and Solving Graphs</a> to review what variables and factors are currently supported.</p><h2><a class="nav-anchor" id="Creating-a-Repository-1" href="#Creating-a-Repository-1">Creating a Repository</a></h2><p>You can fork the following template repository to construct your own <a href="https://github.com/GearsAD/Caesar_VariableFactorExamples.jl.git">Caesar Variable and Factor Examples</a>.</p><p>If this repository is going to be used for development of the new variables/factors as well as for the experiment (i.e. the code that builds the graph and solves it), you should probably start a simple end-to-end test that validates a basic version of your experimental setup (e.g. ):</p><pre><code class="language-julia">#### This example is a basic test of the new variables and factors
#### that are added in this repo. The example is derived from
#### the hexagonal test example.

using Caesar, RoME
using Caesar_VariableFactorExamples # Your new variable/factor repository
# Using plotting for experiment validation
using RoMEPlotting

# 1. Init factor graph
#TODO

# 2. Add variables
#TODO

# 3. Add factors
# 3a. Add a new test prior
#TODO
# 3b. Add new types of odometry factors.
#TODO

# 4. Solve graph
batchSolve!(fg)

# 5. Graph solution - assuming that you have this open in Atom.
drawPoses(fg)</code></pre><h2><a class="nav-anchor" id="Creating-New-Variables-1" href="#Creating-New-Variables-1">Creating New Variables</a></h2><p>All variables have to derive from <code>IncrementalInference.InferenceVariable</code>.</p><p>What you need to build in the variable:</p><ul><li><code>dims</code> - This is used during computation and defines the degrees of freedom (dimensions) for variable</li><li><code>labels</code> - This a required field, although it does not need to be populated. It consists of unique, indexable string identifiers, such as &#39;POSE&#39;, &#39;LANDMARK&#39;. It assists with querying the data efficiently in large systems when using the database layer.  </li></ul><p>You can then also add any additional fields that you would like to use for saving state information in variable. Note that these fields must be serializable as both JSON and Protobufs. Although you don&#39;t need to validate this, please keep the fields fairly simple and avoid complex structures with optional fields. TBD - provide a compatibility check for serialization and a docpage on it.</p><p>In a trivial example of Pose2:</p><ul><li>Our dimensions would then be 3: X, Y, theta</li><li>The labels for Pose2 could be &quot;POSE&quot;</li></ul><h2><a class="nav-anchor" id="Creating-New-Factors-1" href="#Creating-New-Factors-1">Creating New Factors</a></h2><p>All factors inherit from one of the following types, depending on their function:</p><ul><li>FunctorSingleton: FunctorSingletons are priors (unary factors) that provide an absolute constraint for a single variable. A simple example of this is an absolute GPS prior, or equivalently a (0, 0, 0) starting location in a Pose2D scenario.<ul><li>Requires: A getSample function</li></ul></li><li>FunctorPairwiseMinimize: FunctorPairwiseMinimize are relative factors that introduce an algebraic relationship between two or more variables. A simple example of this is an odometry factor between two pose variables, or a range factor indicating the range between a pose and another variable.<ul><li>Requires: A getSample function and a residual function definition</li><li>The minimize suffix specifies that the residual function of this factor will be enforced by numerical minimization (find me the minimum of this function)</li></ul></li><li>FunctorPairwise: FunctorPairwise are relative factors that introduce algebraic relationships between two or more variables. They are the same as FunctorPairwiseMinimize, however they use root finding to find the zero crossings (rather than numerical minimization).<ul><li>Requires: A getSample function and a residual function definition</li></ul></li></ul><p>How do you decide which to use?</p><ul><li>If you are creating factors for world-frame information that will be tied to a single variable, inherit from FunctorSingleton<ul><li>GPS coordinates should be priors</li></ul></li><li>If you are creating factors for local-frame relationships between variables, inherit from FunctorPairwiseMinimize<ul><li>Odometry and bearing deltas should be introduced as pairwise factors and should be local frame</li></ul></li></ul><p>TBD: sUsers <strong>should</strong> start with FunctorPairwiseMinimize, discuss why and when they should promote their factors to FunctorPairwise.</p><blockquote><p>Note: FunctorPairwiseMinimize does not imply that the overall inference algorithm only minimizes an objective function. The Multi-model iSAM algorithm is built around fixed-point analysis. Minimization is used here to locally enforce the residual function.</p></blockquote><p>What you need to build in the new factor:</p><ul><li>A struct for the factor itself</li><li>A sampler function to return measurements from the random ditributions</li><li>If you are building a <code>FunctorPairwiseMinimize</code> or a <code>FunctorPairwise</code> you need to define a residual function to introduce the relative algebraic relationship between the variables<ul><li>Minimization function should be lower-bounded and smooth</li></ul></li><li>A packed type of the factor which must be named Packed[Factor name], and allows the factor to be packed/transmitted/unpacked</li><li>Serialization and deserialization methods<ul><li>These are convert functions that pack and unpack the factor (which may be highly complex) into serialization-compatible formats</li><li>As the factors are mostly comprised of distributions (of type <code>SamplableBelief</code>), functions are provided to pack and unpack the distributions:<ul><li>Packing: To convert from a <code>SamplableBelief</code> to a string, use <code>string(::SamplableBelief)::String</code></li><li>Unpacking: To convert from string back to a <code>SamplableBelief</code>, use <code>extractdistribution(::String)::SamplableBelief</code>  </li></ul></li></ul></li></ul><p>An example of this is the <code>Pose2Point2BearingRange</code>, which provides a bearing+range relationship between a 2D pose and a 2D point.</p><h3><a class="nav-anchor" id="Pose2Point2BearingRange-Struct-1" href="#Pose2Point2BearingRange-Struct-1">Pose2Point2BearingRange Struct</a></h3><pre><code class="language-julia">mutable struct Pose2Point2BearingRange{B &lt;: IIF.SamplableBelief, R &lt;: IIF.SamplableBelief} &lt;: IncrementalInference.FunctorPairwise
    bearing::B
    range::R
    Pose2Point2BearingRange{B,R}() where {B,R} = new{B,R}()
    Pose2Point2BearingRange{B,R}(x1::B,x2::R) where {B &lt;: IIF.SamplableBelief,R &lt;: IIF.SamplableBelief} = new{B,R}(x1,x2)
end
# Convenient constructor
Pose2Point2BearingRange(x1::B,x2::R) where {B &lt;: IIF.SamplableBelief,R &lt;: IIF.SamplableBelief} = Pose2Point2BearingRange{B,R}(x1,x2)</code></pre><h3><a class="nav-anchor" id="Pose2Point2BearingRange-Sampler-1" href="#Pose2Point2BearingRange-Sampler-1">Pose2Point2BearingRange Sampler</a></h3><pre><code class="language-julia"># Return N samples from the two distributions
function getSample(pp2br::Pose2Point2BearingRange, N::Int=1)
  smpls = zeros(2, N)
  smpls[1,:] = rand(pp2br.bearing, N)[:]
  smpls[2,:] = rand(pp2br.range, N)[:]
  return (smpls,)
end</code></pre><h3><a class="nav-anchor" id="Pose2Point2BearingRange-Residual-Function-(Functor)-1" href="#Pose2Point2BearingRange-Residual-Function-(Functor)-1">Pose2Point2BearingRange Residual Function (Functor)</a></h3><pre><code class="language-julia"># define the conditional probability constraint
function (pp2br::Pose2Point2BearingRange)(res::Array{Float64},
        userdata::FactorMetadata,
        idx::Int,
        meas::Tuple{Array{Float64,2}},
        xi::Array{Float64,2},
        lm::Array{Float64,2} )
  #
  res[1] = lm[1,idx] - (meas[1][2,idx]*cos(meas[1][1,idx]+xi[3,idx]) + xi[1,idx])
  res[2] = lm[2,idx] - (meas[1][2,idx]*sin(meas[1][1,idx]+xi[3,idx]) + xi[2,idx])
  nothing
end</code></pre><h3><a class="nav-anchor" id="Pose2Point2BearingRange-Packing-and-Unpacking-1" href="#Pose2Point2BearingRange-Packing-and-Unpacking-1">Pose2Point2BearingRange Packing and Unpacking</a></h3><p>The packing structure:</p><pre><code class="language-julia">mutable struct PackedPose2Point2BearingRange &lt;: IncrementalInference.PackedInferenceType
    bearstr::String
    rangstr::String
    PackedPose2Point2BearingRange() = new()
    PackedPose2Point2BearingRange(s1::AS, s2::AS) where {AS &lt;: AbstractString} = new(string(s1),string(s2))
end</code></pre><p>The packing and unpacking converters (note the use of <code>string</code> and <code>extractdistribution</code>):</p><pre><code class="language-julia">function convert(::Type{PackedPose2Point2BearingRange}, d::Pose2Point2BearingRange{B, R}) where {B &lt;: IIF.SamplableBelief, R &lt;: IIF.SamplableBelief}
  return PackedPose2Point2BearingRange(string(d.bearing), string(d.range))
end

function convert(::Type{Pose2Point2BearingRange}, d::PackedPose2Point2BearingRange)
 # where {B &lt;: IIF.SamplableBelief, R &lt;: IIF.SamplableBelief}
  Pose2Point2BearingRange(extractdistribution(d.bearstr), extractdistribution(d.rangstr))
end</code></pre><h2><a class="nav-anchor" id="Unit-Tests-1" href="#Unit-Tests-1">Unit Tests</a></h2><p>What you should test:</p><ul><li>Creation of the factor</li><li>Sampling of the factor</li><li>Residual testing</li><li>Solving using the variables and factors</li><li>Serialization and deserialization</li></ul><p>An example of these tests can be seen for the trivial case shown in the example repo <a href="https://github.com/GearsAD/Caesar_VariableFactorExamples.jl/blob/master/test/ExamplePrior.jl">ExamplePrior Unit Tests</a>.</p><h2><a class="nav-anchor" id="Using-your-Types-with-the-Caesar-Solver-1" href="#Using-your-Types-with-the-Caesar-Solver-1">Using your Types with the Caesar Solver</a></h2><p>As above, as long as you bring your factors into the workspace, you should be able to use them in your experimental setup.</p><p>You can validate this with the existence check code in <a href="../building_graphs/">Building and Solving Graphs</a>.</p><blockquote><p>Note: This has been made available as <code>IncrementalInference.getCurrentWorkspaceVariables()</code> and <code>IncrementalInference.getCurrentWorkspaceFactors()</code>in IncrementalInference v0.4.4.</p></blockquote><h2><a class="nav-anchor" id="Contributing-to-Community-1" href="#Contributing-to-Community-1">Contributing to Community</a></h2><p>We really appreciate any contributions, so if you have developed variables and factors that may be useful to the community, please write up an issue in <a href="https://github.com/JuliaRobotics/Caesar.jl">Caesar.jl</a> with a link to your repo and a short description of the use-case(s).</p><footer><hr/><a class="previous" href="../zmq/"><span class="direction">Previous</span><span class="title">Using Caesar&#39;s Multi-Language Support</span></a><a class="next" href="../database_interactions/"><span class="direction">Next</span><span class="title">Using Caesar Database Operation</span></a></footer></article></body></html>
