<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Building Factor Graphs · Caesar.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Caesar.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Getting Started</span><ul><li><a class="toctext" href="../../installation_environment/">Installation</a></li></ul></li><li><span class="toctext">Concepts</span><ul><li><a class="toctext" href="../concepts/">Caesar Concepts</a></li><li class="current"><a class="toctext" href>Building Factor Graphs</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Initializing-a-Factor-Graph-1">Initializing a Factor Graph</a></li><li><a class="toctext" href="#Adding-to-the-Graph-1">Adding to the Graph</a></li><li><a class="toctext" href="#Variables-1">Variables</a></li><li><a class="toctext" href="#Factors-1">Factors</a></li><li class="toplevel"><a class="toctext" href="#Variables-and-Factors-Available-in-Caesar-1">Variables and Factors Available in Caesar</a></li><li class="toplevel"><a class="toctext" href="#Querying-the-FactorGraph-1">Querying the FactorGraph</a></li><li><a class="toctext" href="#Solving-Graphs-1">Solving Graphs</a></li><li><a class="toctext" href="#Peeking-at-Results-1">Peeking at Results</a></li><li><a class="toctext" href="#Plotting-1">Plotting</a></li><li><a class="toctext" href="#Next-Steps-1">Next Steps</a></li></ul></li><li><a class="toctext" href="../arena_visualizations/">Arena Visualization</a></li><li><a class="toctext" href="../zmq/">Using Caesar&#39;s Multi-Language Support</a></li><li><a class="toctext" href="../adding_variables_factors/">Adding New Variables and Factors</a></li><li><a class="toctext" href="../database_interactions/">Using Caesar Database Operation</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/examples/">Caesar Examples</a></li><li><a class="toctext" href="../../examples/basic_continuousscalar/">ContinuousScalar</a></li><li><a class="toctext" href="../../examples/basic_slamedonut/">Singular Ranges-only SLAM (Underdetermined System)</a></li><li><a class="toctext" href="../../examples/basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="toctext" href="../../examples/interm_fixedlag_hexagonal/">Fixed-Lag Solving</a></li><li><a class="toctext" href="../../examples/basic_definingfactors/">Creating Custom Variables and Factors</a></li><li><a class="toctext" href="../../examples/interm_dynpose/">Creating DynPose Factor</a></li></ul></li><li><span class="toctext">Function Reference</span><ul><li><a class="toctext" href="../../func_ref/">Function Reference</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Concepts</li><li><a href>Building Factor Graphs</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/concepts/building_graphs.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Building Factor Graphs</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Building-and-Solving-Graphs-1" href="#Building-and-Solving-Graphs-1">Building and Solving Graphs</a></h1><p>Irrespective of your application - real-time robotics, batch processing of survey data, or really complex multi-hypothesis modeling - you&#39;re going to need to add factors and variables to a graph. This section discusses how to do that in Caesar.</p><p>The following sections discuss the steps required to construct a graph and solve it:</p><ul><li>Initialing the Factor Graph</li><li>Adding Variables and Factors to the Graph</li><li>Solving the Graph</li><li>Informing the Solver About Ready Data</li></ul><h1><a class="nav-anchor" id="Initializing-a-Factor-Graph-1" href="#Initializing-a-Factor-Graph-1">Initializing a Factor Graph</a></h1><pre><code class="language-julia">using Caesar, RoME, Distributions

# start with an empty factor graph object
fg = initfg()</code></pre><h2><a class="nav-anchor" id="Adding-to-the-Graph-1" href="#Adding-to-the-Graph-1">Adding to the Graph</a></h2><p>Factor graphs are made of two constituent parts:</p><ul><li>Variables</li><li>Factors</li></ul><h2><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h2><p>Variables (a.k.a. poses in localization terminology) are created in the same way  shown above for the landmark. Variables contain a label, a data type (e.g. in 2D <code>RoME.Point2</code> or <code>RoME.Pose2</code>). Note that variables are solved - i.e. they are the product, what you wish to calculate when the solver runs - so you don&#39;t provide any measurements when creating them.</p><pre><code class="language-julia"># Add the first pose :x0
addNode!(fg, :x0, Pose2)
# Add a few more poses
for i in 1:10
  addNode!(fg, Symbol(&quot;x$(i)&quot;), Pose2)
end</code></pre><h2><a class="nav-anchor" id="Factors-1" href="#Factors-1">Factors</a></h2><p>Factors are algebraic relationships between variables based on data cues such as sensor measurements. Examples of factors are absolute GPS readings (unary factors/priors) and odometry changes between pose variables. All factors encode a stochastic measurement (measurement + error), such as below, where a prior is defined against x0 with a normal distribution centered around [0,0,0].</p><h3><a class="nav-anchor" id="Priors-1" href="#Priors-1">Priors</a></h3><pre><code class="language-julia"># Add at a fixed location Prior to pin :x0 to a starting location (0,0,pi/6.0)
addFactor!(fg, [:x0], IIF.Prior( MvNormal([0; 0; pi/6.0], Matrix(Diagonal([0.1;0.1;0.05].^2)) )))</code></pre><h3><a class="nav-anchor" id="Factors-Between-Variables-1" href="#Factors-Between-Variables-1">Factors Between Variables</a></h3><pre><code class="language-julia"># Add odometry indicating a zigzag movement
for i in 1:10
  pp = Pose2Pose2(MvNormal([10.0;0; (i % 2 == 0 ? -pi/3 : pi/3)], Matrix(Diagonal([0.1;0.1;0.1].^2))))
  addFactor!(fg, [Symbol(&quot;x$(i-1)&quot;); Symbol(&quot;x$(i)&quot;)], pp )
end</code></pre><h3><a class="nav-anchor" id="When-to-Create-New-Pose-Variables-1" href="#When-to-Create-New-Pose-Variables-1">When to Create New Pose Variables</a></h3><p>Consider a robot traversing some area while exploring, localizing, and wanting to find strong loop-closure features for consistent mapping.  The creation of new poses and landmark variables is a trade-off in computational complexity and marginalization errors made during factor graph construction.  Common triggers for new poses are:</p><ul><li>Time-based trigger (eg. new pose a second or 5 minutes if stationary)</li><li>Distance traveled (eg. new pose every 0.5 meters)</li><li>Rotation angle (eg. new pose every 15 degrees)</li></ul><p>Computation will progress faster if poses and landmarks are very sparse.  To extract the benefit of dense reconstructions, one approach is to use the factor graph as sparse index in history about the general progression of the trajectory and use additional processing from dense sensor data for high-fidelity map reconstructions.  Either interpolations, or better direct reconstructions from inertial data can be used for dense reconstruction.</p><p>For completeness, one could also re-project the most meaningful measurements from sensor measurements between pose epochs as though measured from the pose epoch.  This approach essentially marginalizes the local dead reckoning drift errors into the local interpose re-projections, but helps keep the pose count low.</p><p>In addition, see <a href="../../examples/interm_fixedlag_hexagonal/">fixed-lag discussion</a> for limiting during inference the number of fluid variables manually to a user desired count.</p><h1><a class="nav-anchor" id="Variables-and-Factors-Available-in-Caesar-1" href="#Variables-and-Factors-Available-in-Caesar-1">Variables and Factors Available in Caesar</a></h1><h3><a class="nav-anchor" id="Variables-Available-in-Caesar-1" href="#Variables-Available-in-Caesar-1">Variables Available in Caesar</a></h3><p>You can check for the latest variable types by running the following in your terminal:</p><pre><code class="language-julia">using RoME, Caesar
subtypes(IncrementalInference.InferenceVariable)</code></pre><p>Note: This has been made available as <code>IncrementalInference.getCurrentWorkspaceVariables()</code> in IncrementalInference v0.4.4.</p><p>The current list of available variable types is:</p><ul><li><code>RoME.Point2</code> - A 2D coordinate consisting of [x, y, theta]</li><li><code>RoME.Pose2</code> - A 2D coordinate and a rotation (i.e. bearing) consisting of [x, y, z, and theta]</li><li><code>RoME.DynPoint2</code> - A 2D coordinate and linear velocities</li><li><code>RoME.DynPose2</code> - A 2D coordinate, linear velocities, and a rotation</li><li><code>RoME.Point3</code> - A 3D coordinate consisting of [x, y, z]</li><li><code>RoME.Pose3</code> - A 3D coordinate and 3 associated rotations consisting of [x, y, z, theta, phi, psi]</li><li><code>RoME.InertialPose3</code> - A 3D coordinate and rotation pose along with velocity and IMU bias calibration terms</li></ul><blockquote><p><strong>Note</strong> several more variable and factors types have been implemented which will over time be incorporated into standard <code>RoME</code> release.  Please open an issue with <a href="concepts/JuliaRobotics/RoME.jl">JuliaRobotics/RoME.jl</a> for specific requests, problems, or suggestions.  Contributions are also welcome.</p></blockquote><h3><a class="nav-anchor" id="Factors-Available-in-Caesar-1" href="#Factors-Available-in-Caesar-1">Factors Available in Caesar</a></h3><p>You can check for the latest factor types by running the following in your terminal:</p><pre><code class="language-julia">using RoME, Caesar
println(&quot;- Singletons (priors): &quot;)
println.(sort(string.(subtypes(IncrementalInference.FunctorSingleton))));
println(&quot;- Pairwise (variable constraints): &quot;)
println.(sort(string.(subtypes(IncrementalInference.FunctorPairwise))));
println(&quot;- Pairwise (variable minimization constraints): &quot;)
println.(sort(string.(subtypes(IncrementalInference.FunctorPairwiseMinimize))));</code></pre><p>Note: This has been made available as <code>IncrementalInference.getCurrentWorkspaceFactors()</code> in IncrementalInference v0.4.4.</p><p>The current factor types that you will find in the examples are (there are many aside from these):</p><ul><li><code>RoME.Prior</code> - A singleton indicating a prior on a variable</li><li><code>RoME.Point2Point2</code> - A factor between two 2D points</li><li><code>RoME.Point2Point2WorldBearing</code> - A factor between two 2D points with bearing</li><li><code>RoME.Pose2Point2Bearing</code> - A factor between two 2D points with bearing</li><li><code>RoME.Pose2Point2BearingRange</code> - A factor between two 2D points with bearing and range</li><li><code>RoME.Pose2Point2Range</code> - A factor between a 2D pose and a 2D point, with range</li><li><code>RoME.Pose2Pose2</code> - A factor between two 2D poses</li><li><code>RoME.Pose3Pose3</code> - A factor between two 3D poses</li><li><code>RoME.IntertialPose3</code> - A factor between two 3D IMU sensor poses</li></ul><h1><a class="nav-anchor" id="Querying-the-FactorGraph-1" href="#Querying-the-FactorGraph-1">Querying the FactorGraph</a></h1><p>There are a variety of functions to query the factor graph, please refer to <a href="../../func_ref/">Function Reference</a> for details.</p><p>A quick summary of the variables in the factor graph can be retrieved with:</p><pre><code class="language-julia"># List variables
ls(fg)
# List factors attached to x0
ls(fg, :x0)
# TODO: Provide an overview of getVal, getVert, getBW, getVertKDE, etc.</code></pre><h2><a class="nav-anchor" id="Solving-Graphs-1" href="#Solving-Graphs-1">Solving Graphs</a></h2><p>When you have built the graph, you can call the solver to perform inference with the following:</p><pre><code class="language-julia"># Perform inference
batchSolve!(fg)</code></pre><h2><a class="nav-anchor" id="Peeking-at-Results-1" href="#Peeking-at-Results-1">Peeking at Results</a></h2><p>Once you have solved the graph, you can review the full marginal with:</p><pre><code class="language-julia">X0 = getVertKDE(fg, :x0) # Get the raw KDE
# Evaluate the marginal density function just for fun at [0.01, 0, 0].
X0([0.01, 0, 0])</code></pre><p>For finding the MAP value in the density functions, you can use <code>getKDEMax</code> or <code>getKDEMean</code>. Here we are asking for the MAP values for all the variables in the factor graph:</p><pre><code class="language-julia">verts = ls(fg)
map(v -&gt; println(&quot;$v : $(getKDEMax(getVertKDE(fg, v)))&quot;), verts[1]);</code></pre><blockquote><p>Also see built-in function <code>printgraphmax(fg)</code> which performs a similar function.</p></blockquote><h2><a class="nav-anchor" id="Plotting-1" href="#Plotting-1">Plotting</a></h2><p>Once the graph has been built, a simple plot of the values can be produced with RoMEPlotting.jl. For example:</p><pre><code class="language-julia">using RoMEPlotting

drawPoses(fg)
# If you have landmarks, you can call drawPosesLandms(fg)

# Draw the KDE for x0
plotKDE(fg, :x0)
# Draw the KDE&#39;s for x0 and x1
plotKDE(fg, [:x0, :x1])</code></pre><h2><a class="nav-anchor" id="Next-Steps-1" href="#Next-Steps-1">Next Steps</a></h2><p>Although the above graph demonstrates the fundamental operations, it&#39;s not particularly useful. Take a look at <a href="../../examples/basic_hexagonal2d/">Hexagonal Example</a> for a complete example that builds on these operations.</p><h3><a class="nav-anchor" id="Extending-Caesar-with-New-Variables-and-Factors-1" href="#Extending-Caesar-with-New-Variables-and-Factors-1">Extending Caesar with New Variables and Factors</a></h3><p>A question that frequently arises is how to design custom variables and factors to solve a specific type of graph. One strength of Caesar is the ability to incorporate new variables and factors at will. Please refer to <a href="../adding_variables_factors/">Adding Factors</a> for more information on creating your own factors.</p><footer><hr/><a class="previous" href="../concepts/"><span class="direction">Previous</span><span class="title">Caesar Concepts</span></a><a class="next" href="../arena_visualizations/"><span class="direction">Next</span><span class="title">Arena Visualization</span></a></footer></article></body></html>
