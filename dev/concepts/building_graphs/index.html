<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Building Graphs · Caesar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Caesar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../introduction/">Introduction</a></li><li><a class="tocitem" href="../why_nongaussian/">Gaussian vs. Non-Gaussian</a></li><li><a class="tocitem" href="../../installation_environment/">Installation</a></li><li><a class="tocitem" href="../using_julia/">Using Julia</a></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../concepts/">Initial Concepts</a></li><li class="is-active"><a class="tocitem" href>Building Graphs</a><ul class="internal"><li><a class="tocitem" href="#Familiar-Canonical-Factor-Graphs"><span>Familiar Canonical Factor Graphs</span></a></li><li><a class="tocitem" href="#Building-a-new-Graph"><span>Building a new Graph</span></a></li><li><a class="tocitem" href="#Variables"><span>Variables</span></a></li><li><a class="tocitem" href="#Factors"><span>Factors</span></a></li><li><a class="tocitem" href="#When-to-Instantiate-Poses-(i.e.-new-Variables-in-Factor-Graph)"><span>When to Instantiate Poses (i.e. new Variables in Factor Graph)</span></a></li><li><a class="tocitem" href="#Which-Variables-and-Factors-to-use"><span>Which Variables and Factors to use</span></a></li></ul></li><li><a class="tocitem" href="../solving_graphs/">Solving Graphs</a></li><li><a class="tocitem" href="../interacting_fgs/">Interact w Graphs</a></li><li><a class="tocitem" href="../dataassociation/">Multi-Modal/Hypothesis</a></li><li><a class="tocitem" href="../parallel_processing/">Parallel Processing</a></li><li><a class="tocitem" href="../using_manifolds/">Using Manifolds.jl</a></li><li><a class="tocitem" href="../../examples/parametric_solve/">[DEV] Parametric Solve</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/examples/">Caesar Examples</a></li><li><a class="tocitem" href="../../examples/basic_continuousscalar/">Canonical 1D Example</a></li><li><a class="tocitem" href="../../examples/basic_slamedonut/">Underconstrained Range-only</a></li><li><a class="tocitem" href="../../examples/basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="tocitem" href="../../examples/interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li><li><a class="tocitem" href="../../examples/deadreckontether/">Dead Reckon Tether</a></li></ul></li><li><span class="tocitem">Graph Library</span><ul><li><a class="tocitem" href="../../examples/canonical_graphs/">Canonical Generators</a></li><li><a class="tocitem" href="../entry_data/">Entry=&gt;Data Blob</a></li><li><a class="tocitem" href="../available_varfacs/">Variables/Factors</a></li><li><a class="tocitem" href="../flux_factors/">Flux (NN) Factors</a></li><li><a class="tocitem" href="../../examples/using_images/">Images and AprilTags</a></li></ul></li><li><span class="tocitem">Visualization</span><ul><li><a class="tocitem" href="../../install_viz/">Installing Viz</a></li><li><a class="tocitem" href="../2d_plotting/">Plotting (2D)</a></li><li><a class="tocitem" href="../arena_visualizations/">Visualization (3D)</a></li></ul></li><li><span class="tocitem">Middlewares</span><ul><li><a class="tocitem" href="../../examples/using_ros/">ROS Middleware</a></li><li><a class="tocitem" href="../compile_binary/">Compile Binaries</a></li><li><a class="tocitem" href="../zero_install/">Zero Install Solution</a></li><li><a class="tocitem" href="../multisession/">Multi-session/agent Solving</a></li><li><a class="tocitem" href="../multilang/">Multi-Language Support</a></li></ul></li><li><span class="tocitem">How to Expand?</span><ul><li><a class="tocitem" href="../../caesar_framework/">Pkg Framework</a></li><li><a class="tocitem" href="../../examples/custom_variables/">Custom Variables</a></li><li><a class="tocitem" href="../../examples/basic_definingfactors/">Custom Prior Factor</a></li><li><a class="tocitem" href="../../examples/custom_relative_factors/">Custom Relative Factor</a></li><li><a class="tocitem" href="../../examples/custom_factor_features/">Important Factor Features</a></li><li><a class="tocitem" href="../../examples/adding_variables_factors/">Variable/Factor Considerations</a></li><li><a class="tocitem" href="../../func_ref/">More Functions</a></li></ul></li><li><span class="tocitem">Principles</span><ul><li><a class="tocitem" href="../../principles/filterCorrespondence/">Filters vs. Graphs</a></li><li><a class="tocitem" href="../../principles/approxConvDensities/">Generic Convolutions</a></li><li><a class="tocitem" href="../../principles/multiplyingDensities/">Multiplying Functions (.py)</a></li><li><a class="tocitem" href="../../principles/bayestreePrinciples/">Bayes (Junction) tree</a></li><li><a class="tocitem" href="../../principles/initializingOnBayesTree/">Advanced Bayes Tree Topics</a></li><li><a class="tocitem" href="../mmisam_alg/">Non-Gaussian Algorithm</a></li></ul></li><li><span class="tocitem">Developer Zone</span><ul><li><a class="tocitem" href="../../dev/wiki/">Wiki Pointers</a></li><li><a class="tocitem" href="../../examples/legacy_deffactors/">Legacy Factors</a></li><li><a class="tocitem" href="../../principles/interm_dynpose/">Creating DynPose Factor</a></li><li><a class="tocitem" href="../../dev/known_issues/">Known Issue List</a></li><li><a class="tocitem" href="../../dev/internal_fncs/">Internal Functions</a></li></ul></li><li><span class="tocitem">Literature</span><ul><li><a class="tocitem" href="../../refs/literature/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li class="is-active"><a href>Building Graphs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Building Graphs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/concepts/building_graphs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="[Building-Graphs](@ref-building_graphs)"><a class="docs-heading-anchor" href="#[Building-Graphs](@ref-building_graphs)"><a href="concepts/@ref building_graphs">Building Graphs</a></a><a id="[Building-Graphs](@ref-building_graphs)-1"></a><a class="docs-heading-anchor-permalink" href="#[Building-Graphs](@ref-building_graphs)" title="Permalink"></a></h1><p>Irrespective of your application - real-time robotics, batch processing of survey data, or really complex multi-hypothesis modeling - you&#39;re going to need to add factors and variables to a graph. This section discusses how to do that in Caesar.</p><p>The following sections discuss the steps required to construct a graph and solve it:</p><ul><li>Initializing the Factor Graph</li><li>Adding Variables and Factors to the Graph</li><li>Solving the Graph</li><li>Informing the Solver About Ready Data</li></ul><h2 id="Familiar-Canonical-Factor-Graphs"><a class="docs-heading-anchor" href="#Familiar-Canonical-Factor-Graphs">Familiar Canonical Factor Graphs</a><a id="Familiar-Canonical-Factor-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Familiar-Canonical-Factor-Graphs" title="Permalink"></a></h2><p>Starting with a shortcut to just quickly getting a small predefined <em>canonical</em> graph containing a few variables and factors.  Functions to <em>generate</em> a canonical factor graph object that is useful for orientation, testing, learning, or validation.  You can generate any of these factor graphs at any time, for example when quickly wanting to test some idea midway through building a more sophisiticated <code>fg</code>, you might just want to quickly do:</p><pre><code class="language-julia hljs">fg_ = generateCanonicalFG_Hexagonal()</code></pre><p>and then work with <code>fg_</code> to try out something risky.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>See the <a href="../../examples/canonical_graphs/">Canonical Graphs</a> page for a more complete list of existing graph generators.</p></div></div><h2 id="Building-a-new-Graph"><a class="docs-heading-anchor" href="#Building-a-new-Graph">Building a new Graph</a><a id="Building-a-new-Graph-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-new-Graph" title="Permalink"></a></h2><p>The first step is to model the data (using the most appropriate <em>factors</em>) among <em>variables</em> of interest.  To start model, first create a <em>distributed factor graph object</em>:</p><pre><code class="language-julia hljs"># start with an empty factor graph object
fg = initfg()</code></pre><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.initfg" href="#IncrementalInference.initfg"><code>IncrementalInference.initfg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initfg()
initfg(dfg; sessionname, robotname, username, cloudgraph)
</code></pre><p>Initialize an empty in-memory DistributedFactorGraph <code>::DistributedFactorGraph</code> object.</p></div></section></article><h2 id="Variables"><a class="docs-heading-anchor" href="#Variables">Variables</a><a id="Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Variables" title="Permalink"></a></h2><p>Variables (a.k.a. poses or states in navigation lingo) are created with the <code>addVariable!</code> fucntion call.</p><pre><code class="language-julia hljs"># Add the first pose :x0
addVariable!(fg, :x0, Pose2)
# Add a few more poses
for i in 1:10
  addVariable!(fg, Symbol(&quot;x&quot;,i), Pose2)
end</code></pre><p>Variables contain a label, a data type (e.g. in 2D <code>RoME.Point2</code> or <code>RoME.Pose2</code>). Note that variables are solved - i.e. they are the product, what you wish to calculate when the solver runs - so you don&#39;t provide any measurements when creating them.</p><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.addVariable!" href="#DistributedFactorGraphs.addVariable!"><code>DistributedFactorGraphs.addVariable!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addVariable!(dfg, label, varTypeU; N, solvable, timestamp, nanosecondtime, dontmargin, labels, tags, smalldata, checkduplicates, initsolvekeys)
</code></pre><p>Add a variable node <code>label::Symbol</code> to <code>dfg::AbstractDFG</code>, as <code>varType&lt;:InferenceVariable</code>.</p><p><strong>Notes</strong></p><ul><li>keyword <code>nanosecondtime</code> is experimental and intended as the whole subsection portion – i.e. accurateTime = (timestamp MOD second) + Nanosecond</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">fg = initfg()
addVariable!(fg, :x0, Pose2)</code></pre></div></section><section><div><p>Add a DFGVariable to a DFG.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.deleteVariable!" href="#DistributedFactorGraphs.deleteVariable!"><code>DistributedFactorGraphs.deleteVariable!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deleteVariable!(dfg, label)
</code></pre><p>Delete a DFGVariable from the DFG using its label.</p></div></section><section><div><pre><code class="language-julia hljs">deleteVariable!(dfg, variable)
</code></pre><p>Delete a referenced DFGVariable from the DFG.</p><p>Notes</p><ul><li>Returns <code>Tuple{AbstractDFGVariable, Vector{&lt;:AbstractDFGFactor}}</code></li></ul></div></section></article><h3 id="Initializing-Variables"><a class="docs-heading-anchor" href="#Initializing-Variables">Initializing Variables</a><a id="Initializing-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Initializing-Variables" title="Permalink"></a></h3><p>The MM-iSAMv2 algorithm uses one of two approaches to automatically initialize variables.  The <code>initManual!</code> function can be used if you wish to overwrite or pre-empt this initialization.</p><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.initManual!" href="#IncrementalInference.initManual!"><code>IncrementalInference.initManual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initManual!(variable::DFGVariable, ptsArr::ManifoldKernelDensity)
initManual!(variable::DFGVariable, ptsArr::ManifoldKernelDensity, solveKey::Symbol; dontmargin, N)
</code></pre><p>Method to manually initialize a variable using a set of points.</p><p>Notes</p><ul><li>Disable automated graphinit on `addFactor!(fg, ...; graphinit=false)<ul><li>any un-initialized variables will automatically be initialized by <code>solveTree!</code></li></ul></li></ul><p>Example:</p><pre><code class="language-julia hljs"># some variable is added to fg
addVariable!(fg, :somepoint3, ContinuousEuclid{2})

# data is organized as (row,col) == (dimension, samples)
pts = randn(2,100)
initManual!(fg, :somepoint3, pts)

# manifold management should be done automatically.
# note upgrades are coming to consolidate with Manifolds.jl, see RoME #244

## it is also possible to initManual! by using existing factors, e.g.
initManual!(fg, :x3, [:x2x3f1])</code></pre><p>DevNotes</p><ul><li>TODO better document graphinit and treeinit.</li></ul></div></section></article><h2 id="Factors"><a class="docs-heading-anchor" href="#Factors">Factors</a><a id="Factors-1"></a><a class="docs-heading-anchor-permalink" href="#Factors" title="Permalink"></a></h2><p>Factors are algebraic relationships between variables based on data cues such as sensor measurements. Examples of factors are absolute (pre-resolved) GPS readings (unary factors/priors) and odometry changes between pose variables. All factors encode a stochastic measurement (measurement + error), such as below, where a generic <a href="../available_varfacs/#IncrementalInference.Prior"><code>Prior</code></a> belief is add to <code>x0</code> (using the <a href="#DistributedFactorGraphs.addFactor!"><code>addFactor!</code></a> call) as a normal distribution centered around <code>[0,0,0]</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.addFactor!" href="#DistributedFactorGraphs.addFactor!"><code>DistributedFactorGraphs.addFactor!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addFactor!(dfg, Xi, usrfnc; multihypo, nullhypo, solvable, tags, timestamp, graphinit, threadmodel, suppressChecks, inflation, namestring, _blockRecursion)
</code></pre><p>Add factor with user defined type <code>&lt;:AbstractFactor</code><code>to the factor graph object. Define whether the automatic initialization of variables should be performed.  Use order sensitive</code>multihypo` keyword argument to define if any variables are related to data association uncertainty.</p><p>Experimental</p><ul><li><code>inflation</code>, to better disperse kernels before convolution solve, see IIF #1051.</li></ul></div></section><section><div><p>Add a DFGFactor to a DFG.</p><pre><code class="language-julia hljs">addFactor!(dfg, factor)
</code></pre></div></section><section><div><pre><code class="language-julia hljs">addFactor!(dfg, variables, factor)
</code></pre></div></section><section><div><pre><code class="language-julia hljs">addFactor!(dfg, variableLabels, factor)
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DistributedFactorGraphs.deleteFactor!" href="#DistributedFactorGraphs.deleteFactor!"><code>DistributedFactorGraphs.deleteFactor!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Delete a DFGFactor from the DFG using its label.</p></div></section><section><div><p>Delete the referened DFGFactor from the DFG.</p></div></section></article><h3 id="Priors"><a class="docs-heading-anchor" href="#Priors">Priors</a><a id="Priors-1"></a><a class="docs-heading-anchor-permalink" href="#Priors" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Add at a fixed location Prior to pin :x0 to a starting location (0,0,pi/6.0)
addFactor!(fg, [:x0], PriorPose2( MvNormal([0; 0; pi/6.0], Matrix(Diagonal([0.1;0.1;0.05].^2)) )))</code></pre><h3 id="Factors-Between-Variables"><a class="docs-heading-anchor" href="#Factors-Between-Variables">Factors Between Variables</a><a id="Factors-Between-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Factors-Between-Variables" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Add odometry indicating a zigzag movement
for i in 1:10
  pp = Pose2Pose2(MvNormal([10.0;0; (i % 2 == 0 ? -pi/3 : pi/3)], Matrix(Diagonal([0.1;0.1;0.1].^2))))
  addFactor!(fg, [Symbol(&quot;x$(i-1)&quot;); Symbol(&quot;x$(i)&quot;)], pp )
end</code></pre><h4 id="[OPTIONAL]-Understanding-Internal-Factor-Naming-Convention"><a class="docs-heading-anchor" href="#[OPTIONAL]-Understanding-Internal-Factor-Naming-Convention">[OPTIONAL] Understanding Internal Factor Naming Convention</a><a id="[OPTIONAL]-Understanding-Internal-Factor-Naming-Convention-1"></a><a class="docs-heading-anchor-permalink" href="#[OPTIONAL]-Understanding-Internal-Factor-Naming-Convention" title="Permalink"></a></h4><p>The factor name used by Caesar is automatically generated from </p><pre><code class="language-julia hljs">addFactor!(fg, [:x0; :x1],...)</code></pre><p>will create a factor with name <code>:x0x1f1</code></p><p>When you were to add a another factor betweem <code>:x0</code>, <code>:x1</code>:</p><pre><code class="language-julia hljs">addFactor!(fg, [:x0; :x1],...)</code></pre><p>will create a second factor with the name <code>:x0x1f2</code>.</p><h3 id="Adding-Tags"><a class="docs-heading-anchor" href="#Adding-Tags">Adding Tags</a><a id="Adding-Tags-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Tags" title="Permalink"></a></h3><p>It is possible to add <code>tags</code> to variables and factors that make later graph management tasks easier, e.g.:</p><pre><code class="language-julia hljs">addVariable!(fg, :l7_3, Pose2, tags=[:APRILTAG; :LANDMARK])</code></pre><h3 id="Drawing-the-Factor-Graph"><a class="docs-heading-anchor" href="#Drawing-the-Factor-Graph">Drawing the Factor Graph</a><a id="Drawing-the-Factor-Graph-1"></a><a class="docs-heading-anchor-permalink" href="#Drawing-the-Factor-Graph" title="Permalink"></a></h3><p>Once you have a graph, you can visualize the graph as follows (beware though if the fg object is large):</p><pre><code class="language-julia hljs"># requires `sudo apt-get install graphviz
drawGraph(fg, show=true)</code></pre><p>By setting <code>show=true</code>, the application <code>evince</code> will be called to show the <code>fg.pdf</code> file that was created using <em>GraphViz</em>.  A <code>GraphPlot.jl</code> visualization engine is also available.</p><pre><code class="language-julia hljs">using GraphPlot
plotDFG(fg)</code></pre><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.drawGraph" href="#IncrementalInference.drawGraph"><code>IncrementalInference.drawGraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">drawGraph(fgl; viewerapp, filepath, engine, show)
</code></pre><p>Draw and show the factor graph <code>&lt;:AbstractDFG</code> via system graphviz and xdot app.</p><p>Notes</p><ul><li>Requires system install on Linux of <code>sudo apt-get install xdot</code></li><li>Should not be calling outside programs.</li><li>Need long term solution</li><li>DFG&#39;s <code>toDotFile</code> a better solution – view with <code>xdot</code> application.</li><li>also try <code>engine={&quot;sfdp&quot;,&quot;fdp&quot;,&quot;dot&quot;,&quot;twopi&quot;,&quot;circo&quot;,&quot;neato&quot;}</code></li></ul><p>Notes:</p><ul><li>Calls external system application <code>xdot</code> to read the <code>.dot</code> file format<ul><li><code>toDot(fg,file=...); @async run(`xdot file.dot`)</code></li></ul></li></ul><p>Related</p><p>drawGraphCliq, <a href="../../principles/bayestreePrinciples/#IncrementalInference.drawTree"><code>drawTree</code></a>, printCliqSummary, spyCliqMat</p></div></section></article><p>For more details, see <a href="https://juliarobotics.org/DistributedFactorGraphs.jl/latest/DrawingGraphs/#Drawing-Graphs-1">the DFG docs on Drawing Graphs</a>.</p><h2 id="When-to-Instantiate-Poses-(i.e.-new-Variables-in-Factor-Graph)"><a class="docs-heading-anchor" href="#When-to-Instantiate-Poses-(i.e.-new-Variables-in-Factor-Graph)">When to Instantiate Poses (i.e. new Variables in Factor Graph)</a><a id="When-to-Instantiate-Poses-(i.e.-new-Variables-in-Factor-Graph)-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Instantiate-Poses-(i.e.-new-Variables-in-Factor-Graph)" title="Permalink"></a></h2><p>Consider a robot traversing some area while exploring, localizing, and wanting to find strong loop-closure features for consistent mapping.  The creation of new poses and landmark variables is a trade-off in computational complexity and marginalization errors made during factor graph construction.  Common triggers for new poses are:</p><ul><li>Time-based trigger (eg. new pose a second or 5 minutes if stationary)</li><li>Distance traveled (eg. new pose every 0.5 meters)</li><li>Rotation angle (eg. new pose every 15 degrees)</li></ul><p>Computation will progress faster if poses and landmarks are very sparse.  To extract the benefit of dense reconstructions, one approach is to use the factor graph as sparse index in history about the general progression of the trajectory and use additional processing from dense sensor data for high-fidelity map reconstructions.  Either interpolations, or better direct reconstructions from inertial data can be used for dense reconstruction.</p><p>For completeness, one could also re-project the most meaningful measurements from sensor measurements between pose epochs as though measured from the pose epoch.  This approach essentially marginalizes the local dead reckoning drift errors into the local interpose re-projections, but helps keep the pose count low.</p><p>In addition, see <a href="../../examples/interm_fixedlag_hexagonal/#fixedlag_solving">Fixed-lag Solving</a> for limiting during inference the number of fluid variables manually to a user desired count.</p><h2 id="Which-Variables-and-Factors-to-use"><a class="docs-heading-anchor" href="#Which-Variables-and-Factors-to-use">Which Variables and Factors to use</a><a id="Which-Variables-and-Factors-to-use-1"></a><a class="docs-heading-anchor-permalink" href="#Which-Variables-and-Factors-to-use" title="Permalink"></a></h2><p>See the next page on <a href="../available_varfacs/#variables_factors">available variables and factors</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../concepts/">« Initial Concepts</a><a class="docs-footer-nextpage" href="../solving_graphs/">Solving Graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Tuesday 5 April 2022 01:46">Tuesday 5 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
