<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Creating DynPose Factor · Caesar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Caesar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../introduction/">Introduction</a></li><li><a class="tocitem" href="../../concepts/why_nongaussian/">Gaussian vs. Non-Gaussian</a></li><li><a class="tocitem" href="../../installation_environment/">Installation</a></li><li><a class="tocitem" href="../../concepts/using_julia/">Using Julia</a></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../concepts/concepts/">Initial Concepts</a></li><li><a class="tocitem" href="../../concepts/building_graphs/">Building Graphs</a></li><li><a class="tocitem" href="../../concepts/solving_graphs/">Solving Graphs</a></li><li><a class="tocitem" href="../../concepts/interacting_fgs/">Interact w Graphs</a></li><li><a class="tocitem" href="../../concepts/dataassociation/">Multi-Modal/Hypothesis</a></li><li><a class="tocitem" href="../../concepts/parallel_processing/">Parallel Processing</a></li><li><a class="tocitem" href="../../concepts/using_manifolds/">Using Manifolds.jl</a></li><li><a class="tocitem" href="../../examples/parametric_solve/">[DEV] Parametric Solve</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/examples/">Caesar Examples</a></li><li><a class="tocitem" href="../../examples/basic_continuousscalar/">Canonical 1D Example</a></li><li><a class="tocitem" href="../../examples/basic_slamedonut/">Underconstrained Range-only</a></li><li><a class="tocitem" href="../../examples/basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="tocitem" href="../../examples/interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li><li><a class="tocitem" href="../../examples/deadreckontether/">Dead Reckon Tether</a></li></ul></li><li><span class="tocitem">Graph Library</span><ul><li><a class="tocitem" href="../../examples/canonical_graphs/">Canonical Generators</a></li><li><a class="tocitem" href="../../concepts/entry_data/">Entry=&gt;Data Blob</a></li><li><a class="tocitem" href="../../concepts/available_varfacs/">Variables/Factors</a></li><li><a class="tocitem" href="../../concepts/flux_factors/">Flux (NN) Factors</a></li><li><a class="tocitem" href="../../examples/using_images/">Images and AprilTags</a></li></ul></li><li><span class="tocitem">Visualization</span><ul><li><a class="tocitem" href="../../install_viz/">Installing Viz</a></li><li><a class="tocitem" href="../../concepts/2d_plotting/">Plotting (2D)</a></li><li><a class="tocitem" href="../../concepts/arena_visualizations/">Visualization (3D)</a></li></ul></li><li><span class="tocitem">Middlewares</span><ul><li><a class="tocitem" href="../../examples/using_ros/">ROS Middleware</a></li><li><a class="tocitem" href="../../concepts/compile_binary/">Compile Binaries</a></li><li><a class="tocitem" href="../../concepts/zero_install/">Zero Install Solution</a></li><li><a class="tocitem" href="../../concepts/multisession/">Multi-session/agent Solving</a></li><li><a class="tocitem" href="../../concepts/multilang/">Multi-Language Support</a></li></ul></li><li><span class="tocitem">How to Expand?</span><ul><li><a class="tocitem" href="../../caesar_framework/">Pkg Framework</a></li><li><a class="tocitem" href="../../examples/custom_variables/">Custom Variables</a></li><li><a class="tocitem" href="../../examples/basic_definingfactors/">Custom Prior Factor</a></li><li><a class="tocitem" href="../../examples/custom_relative_factors/">Custom Relative Factor</a></li><li><a class="tocitem" href="../../concepts/stash_and_cache/">Caching and Stashing</a></li><li><a class="tocitem" href="../../examples/custom_factor_features/">Important Factor Features</a></li><li><a class="tocitem" href="../../examples/adding_variables_factors/">Variable/Factor Considerations</a></li><li><a class="tocitem" href="../../func_ref/">More Functions</a></li></ul></li><li><span class="tocitem">Principles</span><ul><li><a class="tocitem" href="../filterCorrespondence/">Filters vs. Graphs</a></li><li><a class="tocitem" href="../approxConvDensities/">Generic Convolutions</a></li><li><a class="tocitem" href="../multiplyingDensities/">Multiplying Functions (.py)</a></li><li><a class="tocitem" href="../bayestreePrinciples/">Bayes (Junction) tree</a></li><li><a class="tocitem" href="../initializingOnBayesTree/">Advanced Bayes Tree Topics</a></li><li><a class="tocitem" href="../../concepts/mmisam_alg/">Non-Gaussian Algorithm</a></li></ul></li><li><span class="tocitem">Developer Zone</span><ul><li><a class="tocitem" href="../../dev/wiki/">Wiki Pointers</a></li><li><a class="tocitem" href="../../examples/legacy_deffactors/">Legacy Factors</a></li><li class="is-active"><a class="tocitem" href>Creating DynPose Factor</a><ul class="internal"><li><a class="tocitem" href="#Example:-Adding-Velocity-to-RoME.Point2"><span>Example: Adding Velocity to <code>RoME.Point2</code></span></a></li><li class="toplevel"><a class="tocitem" href="#IncrementalInference.jl-Defining-Factors-(Future-API)"><span>IncrementalInference.jl Defining Factors (Future API)</span></a></li><li><a class="tocitem" href="#Contributions"><span>Contributions</span></a></li></ul></li><li><a class="tocitem" href="../../dev/known_issues/">Known Issue List</a></li><li><a class="tocitem" href="../../dev/internal_fncs/">Internal Functions</a></li></ul></li><li><span class="tocitem">Literature</span><ul><li><a class="tocitem" href="../../refs/literature/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Zone</a></li><li class="is-active"><a href>Creating DynPose Factor</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Creating DynPose Factor</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/principles/interm_dynpose.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Adding-Velocity-(Preintegration)"><a class="docs-heading-anchor" href="#Adding-Velocity-(Preintegration)">Adding Velocity (Preintegration)</a><a id="Adding-Velocity-(Preintegration)-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Velocity-(Preintegration)" title="Permalink"></a></h1><p>This tutorial describes how a new factor can be developed, beyond the pre-existing implementation in <a href="http://www.github.com/JuliaRobotics/RoME.jl">RoME.jl</a>.  Factors can accept any number of variable dependencies and allow for a wide class of allowable function calls can be used.  Our intention is to make it as easy as possible for users to create their own factor types.</p><h2 id="Example:-Adding-Velocity-to-RoME.Point2"><a class="docs-heading-anchor" href="#Example:-Adding-Velocity-to-RoME.Point2">Example: Adding Velocity to <code>RoME.Point2</code></a><a id="Example:-Adding-Velocity-to-RoME.Point2-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Adding-Velocity-to-RoME.Point2" title="Permalink"></a></h2><p>A smaller example in two dimensions where we wish to estimate the velocity of some target:  Consider two variables <code>:x0</code> with a prior as well as a conditional–-likelihood for short–-to variable <code>:x1</code>.  Priors are in the &quot;global&quot; reference frame (how ever you choose to define it), while likelihoods are in the &quot;local&quot; / &quot;relative&quot; frame that only exist between variables.</p><p><img src="https://user-images.githubusercontent.com/6412556/40951628-caf1d332-6845-11e8-9710-9f6fcd92a8ca.png" alt="dynpoint2fg"/></p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Text below is outdated (2021Q1) and needs to be updated for changes <code>softtype--&gt;variableType</code> and <code>CalcFactor</code>.</p></div></div><h3 id="Brief-on-Variable-Node-softtypes"><a class="docs-heading-anchor" href="#Brief-on-Variable-Node-softtypes">Brief on Variable Node <code>softtypes</code></a><a id="Brief-on-Variable-Node-softtypes-1"></a><a class="docs-heading-anchor-permalink" href="#Brief-on-Variable-Node-softtypes" title="Permalink"></a></h3><p>Variable nodes retain meta data (so called &quot;soft types&quot;) describing the type of variable.  Common VariableNode types are <code>RoME.Point2D</code>, <code>RoME.Pose3D</code>.  VariableNode soft types are passed during construction of the factor graph, for example:</p><pre><code class="language-julia hljs">v1 = addVariable!(fg, :x1, Pose2)</code></pre><p>Certain cases require that more information be retained for each VariableNode, and velocity calculations are a clear example where time stamp data across positions is required.  </p><p><strong>Note</strong> Larger data can also be stored under the bigdata framework which is discussed here (TBD).</p><p>If the required VariableNode does not exist, then one can be created, such as adding velocity states with <code>DynPoint2</code>:</p><pre><code class="language-julia hljs">mutable struct DynPoint2 &lt;: IncrementalInference.InferenceVariable
  ut::Int64 # microsecond time
  dims::Int
  DynPoint2(;ut::Int64=0) = new(ut, 4)
end</code></pre><p>The <code>dims</code> field is permanently set to 4, i.e. <code>[x, y, dx/dt, dy/dt]</code>.  The <code>ut</code>parameter is for storing the microsecond time stamp for that variable node.</p><p>In order to implement your own factor type outside <code>IncrementalInference</code> you should import the required identifiers, as follows:</p><pre><code class="language-julia hljs">using IncrementalInference
import IncrementalInference: getSample</code></pre><p><strong>Note</strong> that new factor types can be defined at any time, even after you have started to construct the <code>FactorGraph</code> object.</p><h3 id="DynPoint2VelocityPrior"><a class="docs-heading-anchor" href="#DynPoint2VelocityPrior"><code>DynPoint2VelocityPrior</code></a><a id="DynPoint2VelocityPrior-1"></a><a class="docs-heading-anchor-permalink" href="#DynPoint2VelocityPrior" title="Permalink"></a></h3><p>Work in progress.</p><pre><code class="language-julia hljs">mutable struct DynPoint2VelocityPrior{T} &lt;: IncrementalInference.AbstractPrior where {T &lt;: Distribution}
  z::T
  DynPoint2VelocityPrior{T}() where {T &lt;: Distribution} = new{T}()
  DynPoint2VelocityPrior(z1::T) where {T &lt;: Distribution} = new{T}(z1)
end
getSample(dp2v::DynPoint2VelocityPrior, N::Int=1) = (rand(dp2v.z,N), )</code></pre><h3 id="DynPoint2DynPoint2-(preintegration)"><a class="docs-heading-anchor" href="#DynPoint2DynPoint2-(preintegration)"><code>DynPoint2DynPoint2</code> (preintegration)</a><a id="DynPoint2DynPoint2-(preintegration)-1"></a><a class="docs-heading-anchor-permalink" href="#DynPoint2DynPoint2-(preintegration)" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>::IIF.FactorMetadata</code> is being refactored and improved.  Some of the content below is out of date.  See IIF #1025 for details. (1Q2021)</p></div></div><p>The basic idea is that change in position is composed of three components (originating from double integration of Newton&#39;s second law):</p><p><img src="https://user-images.githubusercontent.com/6412556/40951449-05bdfed8-6845-11e8-8c4f-31fd92523819.gif" alt="deltapositionplus"/> ( eq. 1)</p><p><code>DynPoint2DynPoint2</code> factor is using the above equation to define the difference in position between the two <code>DynPoint2</code>s.  The position part stored in <code>DynPoint2DynPoint2</code> factor corresponds to <img src="https://user-images.githubusercontent.com/6412556/40951527-70cb4140-6845-11e8-8f06-3e405e4ca54b.gif" alt="deltaposplusonly"/>.  A new multi-variable (so called &quot;pairwise&quot;) factor between any number of variables is defined with three elements:</p><ul><li>Factor type definition that inherits either <code>IncrementalInference.FunctorPairwise</code> or <code>IncrementalInference.FunctorPairwiseMinimize</code>;</li></ul><pre><code class="language-julia hljs">mutable struct DynPoint2DynPoint2{T} &lt;: IncrementalInference.FunctorPairwise where {T &lt;: Distribution}
  z::T
  DynPoint2DynPoint2{T}() where {T &lt;: Distribution} = new{T}()
  DynPoint2DynPoint2(z1::T) where {T &lt;: Distribution} = new{T}(z1)
end</code></pre><ul><li>A sampling function with exactly the signature: <code>getSample(dp2dp2::DynPoint2DynPoint2, N::Int=1)</code> and returning a <code>Tuple</code> (legacy reasons);</li></ul><pre><code class="language-julia hljs">getSample(dp2dp2::DynPoint2DynPoint2, N::Int=1) = (rand(dp2dp2.z,N), )</code></pre><ul><li>A residual or minimization function with exactly the signature described below.</li></ul><p>Residual (related to <code>FunctorPairwise</code>) or factor minimization function (related to <code>FunctorPairwiseMinimize</code>) signatures should match this <code>dp2dp2::DynPoint2DynPoint2</code> example:</p><pre><code class="language-julia hljs">function (dp2dp2::DynPoint2DynPoint2)(
            res::Array{Float64},
            userdata,
            idx::Int,
            meas::Tuple,
            Xs...  )::Nothing</code></pre><p>where <code>Xs</code> can be expanded to the particular number of variable nodes this factor will be associated, and note they are order sensitive at <code>addFactor!(fg, ...)</code> time.  The <code>res</code> parameter is a vector of the same dimension defined by the largest of the <code>Xs</code> terms.  The <code>userdata</code> value contains the small metadata / userdata portions of information that was introduced to the factor graph at construction time – please consult <code>error(string(fieldnames(userdata)))</code> for details at this time.  This is a relatively new feature in the code and likely to be improved.  The <code>idx</code> parameter represents a legacy index into the measurement <code>meas[1]</code> and variables <code>Xs</code> to select the desired marginal sample value.  Future versions of the code plan to remove the <code>idx</code> parameter entirely.  The <code>Xs</code> array of parameter are each of type <code>::Array{Float64,2}</code> and contain the estimated samples from each of the current best marginal belief estimates of the factor graph variable node.  </p><pre><code class="language-julia hljs">function (dp2dp2::DynPoint2DynPoint2)(
            res::Array{Float64},
            userdata,
            idx::Int,
            meas::Tuple,
            Xi::Array{Float64,2},
            Xj::Array{Float64,2}  )
  #
  z = meas[1][:,idx]
  xi, xj = Xi[:,idx], Xj[:,idx]
  dt = (userdata.variableuserdata[2].ut - userdata.variableuserdata[1].ut)*1e-6   # roughly the intended use of userdata
  res[1:2] = z[1:2] - (xj[1:2] - (xi[1:2]+dt*xi[3:4]))
  res[3:4] = z[3:4] - (xj[3:4] - xi[3:4])
  nothing
end</code></pre><p>A brief usage example looks as follows, and further questions about how the preintegration strategy was implemented can be traced through the original issue JuliaRobotics/RoME.jl#60 or the literature associated with this project, or contact for more information.</p><pre><code class="language-julia hljs">using RoME, Distributions
fg = initfg()
v0 = addVariable!(fg, :x0, DynPoint2(ut=0))

# Prior factor as boundary condition
pp0 = DynPoint2VelocityPrior(MvNormal([zeros(2);10*ones(2)], 0.1*eye(4)))
f0 = addFactor!(fg, [:x0;], pp0)

# conditional likelihood between Dynamic Point2
v1 = addVariable!(fg, :x1, DynPoint2(ut=1000_000)) # time in microseconds
dp2dp2 = DynPoint2DynPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))
f1 = addFactor!(fg, [:x0;:x1], dp2dp2)

initAll!(fg)
tree = wipeBuildNewTree!(fg)
inferOverTree!(fg, tree)

using KernelDensityEstimate
@show x0 = getKDEMax(getBelief(fg, :x0))
# julia&gt; ... = [-0.19441, 0.0187019, 10.0082, 10.0901]
@show x1 = getKDEMax(getBelief(fg, :x1))
 # julia&gt; ... = [19.9072, 19.9765, 10.0418, 10.0797]</code></pre><h3 id="VelPoint2VelPoint2-(back-differentiation)"><a class="docs-heading-anchor" href="#VelPoint2VelPoint2-(back-differentiation)"><code>VelPoint2VelPoint2</code> (back-differentiation)</a><a id="VelPoint2VelPoint2-(back-differentiation)-1"></a><a class="docs-heading-anchor-permalink" href="#VelPoint2VelPoint2-(back-differentiation)" title="Permalink"></a></h3><p>In case the preintegrated approach is not the first choice, we include <code>VelPoint2VelPoint2 &lt;: IncrementalInference.FunctorPairwiseMinimize</code> as a second likelihood factor example which may seem more intuitive:</p><pre><code class="language-julia hljs">mutable struct VelPoint2VelPoint2{T} &lt;: IncrementalInference.FunctorPairwiseMinimize where {T &lt;: Distribution}
  z::T
  VelPoint2VelPoint2{T}() where {T &lt;: Distribution} = new{T}()
  VelPoint2VelPoint2(z1::T) where {T &lt;: Distribution} = new{T}(z1)
end
getSample(vp2vp2::VelPoint2VelPoint2, N::Int=1) = (rand(vp2vp2.z,N), )
function (vp2vp2::VelPoint2VelPoint2)(
                res::Array{Float64},
                userdata,
                idx::Int,
                meas::Tuple,
                Xi::Array{Float64,2},
                Xj::Array{Float64,2}  )
  #
  z = meas[1][:,idx]
  xi, xj = Xi[:,idx], Xj[:,idx]
  dt = (userdata.variableuserdata[2].ut - userdata.variableuserdata[1].ut)*1e-6   # roughly the intended use of userdata
  dp = (xj[1:2]-xi[1:2])
  dv = (xj[3:4]-xi[3:4])
  res[1] = 0.0
  res[1] += sum((z[1:2] - dp).^2)
  res[1] += sum((z[3:4] - dv).^2)
  res[1] += sum((dp/dt - xi[3:4]).^2)  # (dp/dt - 0.5*(xj[3:4]+xi[3:4])) # midpoint integration
  res[1]
end</code></pre><p>A similar usage example here shows:</p><pre><code class="language-julia hljs">fg = initfg()

# add three point locations
v0 = addVariable!(fg, :x0, DynPoint2(ut=0))
v1 = addVariable!(fg, :x1, DynPoint2(ut=1000_000))
v2 = addVariable!(fg, :x2, DynPoint2(ut=2000_000))

# Prior factor as boundary condition
pp0 = DynPoint2VelocityPrior(MvNormal([zeros(2);10*ones(2)], 0.1*eye(4)))
f0 = addFactor!(fg, [:x0;], pp0)

# conditional likelihood between Dynamic Point2
dp2dp2 = VelPoint2VelPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))
f1 = addFactor!(fg, [:x0;:x1], dp2dp2)

# conditional likelihood between Dynamic Point2
dp2dp2 = VelPoint2VelPoint2(MvNormal([10*ones(2);zeros(2)], 0.1*eye(4)))
f2 = addFactor!(fg, [:x1;:x2], dp2dp2)

# Graphs.plot(fg.g)
initAll!(fg)
tree = wipeBuildNewTree!(fg)
inferOverTree!(fg, tree)

# see the output
@show x0 = getKDEMax(getBelief(getVariable(fg, :x0)))
@show x1 = getKDEMax(getBelief(getVariable(fg, :x1)))
@show x2 = getKDEMax(getBelief(getVariable(fg, :x2)))</code></pre><p>Producing output:</p><pre><code class="nohighlight hljs">x0 = getKDEMax(getBelief(getVariable(fg, :x0))) = [0.101503, -0.0273216, 9.86718, 9.91146]
x1 = getKDEMax(getBelief(getVariable(fg, :x1))) = [10.0087, 9.95139, 10.0622, 10.0195]
x2 = getKDEMax(getBelief(getVariable(fg, :x2))) = [19.9381, 19.9791, 10.0056, 9.92442]</code></pre><h1 id="IncrementalInference.jl-Defining-Factors-(Future-API)"><a class="docs-heading-anchor" href="#IncrementalInference.jl-Defining-Factors-(Future-API)">IncrementalInference.jl Defining Factors (Future API)</a><a id="IncrementalInference.jl-Defining-Factors-(Future-API)-1"></a><a class="docs-heading-anchor-permalink" href="#IncrementalInference.jl-Defining-Factors-(Future-API)" title="Permalink"></a></h1><p>We would like to remove the <code>idx</code> indexing from the residual function calls, since that is an unnecessary burden on the user.  Instead, the package will use <code>views</code> and <code>SubArray</code> types to simplify the interface.  Please contact author for more details (8 June 2018).</p><h2 id="Contributions"><a class="docs-heading-anchor" href="#Contributions">Contributions</a><a id="Contributions-1"></a><a class="docs-heading-anchor-permalink" href="#Contributions" title="Permalink"></a></h2><p>Thanks to mc2922 for raising the catalyst issue and conversations that followed from JuliaRobotics/RoME.jl#60.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/legacy_deffactors/">« Legacy Factors</a><a class="docs-footer-nextpage" href="../../dev/known_issues/">Known Issue List »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Friday 22 April 2022 17:37">Friday 22 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
