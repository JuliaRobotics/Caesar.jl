<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bayes tree prototyping · Caesar.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Caesar.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Getting Started</span><ul><li><a class="toctext" href="../../installation_environment/">Installation</a></li><li><a class="toctext" href="../../faq/">FAQ</a></li></ul></li><li><span class="toctext">Initial Concepts</span><ul><li><a class="toctext" href="../../concepts/concepts/">Caesar Concepts</a></li><li><a class="toctext" href="../../concepts/building_graphs/">Building Factor Graphs</a></li><li><a class="toctext" href="../../concepts/available_varfacs/">Available Variables/Factors</a></li><li><a class="toctext" href="../../concepts/interacting_fgs/">Interacting w/ Factor Graphs</a></li><li><a class="toctext" href="../../concepts/mmisam_alg/">Multimodal iSAM Algorithm</a></li><li><a class="toctext" href="../../concepts/multilang/">Multi-Language Support</a></li><li><a class="toctext" href="../../concepts/arena_visualizations/">Arena Visualization</a></li><li><a class="toctext" href="../../concepts/database_interactions/">Cloud Server/Database</a></li><li><a class="toctext" href="../../concepts/multisession/">Multi/Cross Session Solving</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/examples/">Caesar Examples</a></li><li><a class="toctext" href="../../examples/basic_continuousscalar/">ContinuousScalar as 1D Example</a></li><li><a class="toctext" href="../../examples/basic_slamedonut/">Under-defined Trilateration SLAM 2D</a></li><li><a class="toctext" href="../../examples/basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="toctext" href="../../examples/interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li></ul></li><li><span class="toctext">Principles</span><ul><li><a class="toctext" href="../multiplyingDensities/">Multiplying Functions (.py)</a></li><li><a class="toctext" href="../approxConvDensities/">Generic Convolutions</a></li><li><a class="toctext" href="../filterCorrespondence/">Filters vs. Graphs</a></li><li class="current"><a class="toctext" href>Bayes tree prototyping</a><ul class="internal"><li><a class="toctext" href="#What-is-a-Bayes-(Junction)-tree-1">What is a Bayes (Junction) tree</a></li><li><a class="toctext" href="#Constructing-a-Tree-1">Constructing a Tree</a></li><li><a class="toctext" href="#Visualizing-1">Visualizing</a></li><li><a class="toctext" href="#Variable-Ordering-1">Variable Ordering</a></li><li><a class="toctext" href="#Interfacing-with-&#39;mmisam&#39;-Solver-1">Interfacing with &#39;mmisam&#39; Solver</a></li></ul></li></ul></li><li><span class="toctext">How to Expand?</span><ul><li><a class="toctext" href="../../concepts/adding_variables_factors/">Custom Variables and Factors</a></li><li><a class="toctext" href="../../examples/basic_definingfactors/">Creating Variables and Factors</a></li><li><a class="toctext" href="../../examples/interm_dynpose/">Creating DynPose Factor</a></li></ul></li><li><span class="toctext">Developer Zone</span><ul><li><a class="toctext" href="../../dev/wiki/">Wiki Pointer</a></li></ul></li><li><span class="toctext">Literature</span><ul><li><a class="toctext" href="../../refs/literature/">References</a></li></ul></li><li><span class="toctext">Function Reference</span><ul><li><a class="toctext" href="../../func_ref/">Caesar&#39;s Reference</a></li><li><a class="toctext" href="../../vis_func_ref/">Visualization Reference</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Principles</li><li><a href>Bayes tree prototyping</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/principles/bayestreePrinciples.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Bayes tree prototyping</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Principle:-Bayes-tree-prototyping-1" href="#Principle:-Bayes-tree-prototyping-1">Principle: Bayes tree prototyping</a></h1><p>This page describes how to visualize, study, test, and compare Bayes (Junction) tree concepts with special regard for variable ordering.</p><p><strong>NOTE: docs under construction</strong></p><h2><a class="nav-anchor" id="What-is-a-Bayes-(Junction)-tree-1" href="#What-is-a-Bayes-(Junction)-tree-1">What is a Bayes (Junction) tree</a></h2><p>The Bayes tree data structure is a rooted and directed Junction tree (maximal elimination clique tree). It allows for exact inference to be carried out by leveraging and exposing the variables&#39; conditional independence and, very interestingly, can be directly associated with the sparsity pattern exhibited by a system&#39;s factorized upper triangular square root information matrix (see picture below).</p><p><img src="https://user-images.githubusercontent.com/27132241/69210533-f55da400-0b52-11ea-89dd-f18b7fa983b8.png" alt="graph and matrix analagos"/></p><p>Following this matrix-graph parallel, the picture also shows what the associated matrix interpretation is for a factor graph (~first order expansion in the form of a measurement Jacobian) and its corresponding Markov random field (sparsity pattern corresponding to the information matrix).</p><p>The procedure for obtaining the Bayes (Junction) tree is outlined in the figure shown below (factor graph to chrodal Bayes net via bipartite elimination game, and chordal Bayes net to Bayes tree via maximum cardinality search algorithm).</p><p><img src="https://user-images.githubusercontent.com/27132241/69210647-5eddb280-0b53-11ea-82ab-dc5ff89c4a43.png" alt="add the fg2net2tree outline"/></p><h2><a class="nav-anchor" id="Constructing-a-Tree-1" href="#Constructing-a-Tree-1">Constructing a Tree</a></h2><p>Trees and factor graphs are separated in the implementation, allowing the user to construct multiple different trees from one factor graph except for a few temporary values in the factor graph.</p><pre><code class="language-julia">using IncrementalInference # RoME or Caesar will work too

## construct a distributed factor graph object
fg = initfg()
# add variables and factors
# ...

## build the tree
tree = wipeBuildNewTree!(fg)</code></pre><p>The temporary values are <code>wiped</code> from the distributed factor graph object <code>fg&lt;:AbstractDFG</code> and a new tree is constructed.  This <code>wipeBuildNewTree!</code> call can be repeated as many times the user desires and results should be consistent for the same factor graph structure (regardless of numerical values contained within).</p><h2><a class="nav-anchor" id="Visualizing-1" href="#Visualizing-1">Visualizing</a></h2><p>IncrementalInference.jl includes functions for visualizing the Bayes tree, and uses outside packages such as GraphViz (standard) and Latex tools (experimental, optional) to do so.  </p><h3><a class="nav-anchor" id="GraphViz-1" href="#GraphViz-1">GraphViz</a></h3><pre><code class="language-julia">drawTree(tree, show=true) # , filepath=&quot;/tmp/caesar/mytree.pdf&quot;</code></pre><h3><a class="nav-anchor" id="Latex-Tikz-(Optional)-1" href="#Latex-Tikz-(Optional)-1">Latex Tikz (Optional)</a></h3><p><strong>EXPERIMENTAL</strong>, requiring special import.</p><p>First make sure the following packages are installed on your system:</p><pre><code class="language-none">$ sudo apt-get install texlive-pictures dot2tex
$ pip install dot2tex</code></pre><p>Then in Julia you should be able to do:</p><pre><code class="language-julia">import IncrementalInference: generateTexTree

generateTexTree(tree)</code></pre><p>An example Bayes (Junction) tree representation obtained through <code>generateTexTree(tree)</code> for the sample factor graph shown above can be seen in the following image.</p><p><img src="https://user-images.githubusercontent.com/27132241/69210722-9e0c0380-0b53-11ea-9462-7964844b89b1.png" alt="add the fg2net2tree outline"/></p><h3><a class="nav-anchor" id="Visualizing-Clique-Adjacency-Matrix-1" href="#Visualizing-Clique-Adjacency-Matrix-1">Visualizing Clique Adjacency Matrix</a></h3><p>It is also possible to see the upward message passing variable/factor association matrix for each clique, requiring the Gadfly.jl package:</p><pre><code class="language-julia">using Gadfly

spyCliqMat(tree, :x1) # provided by IncrementalInference

#or embedded in graphviz
drawTree(tree, imgs=true, show=true)</code></pre><h2><a class="nav-anchor" id="Variable-Ordering-1" href="#Variable-Ordering-1">Variable Ordering</a></h2><h3><a class="nav-anchor" id="Getting-the-AMD-Variable-Ordering-1" href="#Getting-the-AMD-Variable-Ordering-1">Getting the AMD Variable Ordering</a></h3><p>The variable ordering is described as a <code>::Vector{Symbol}</code>.</p><pre><code class="language-julia">vo = getEliminationOrder(fg)
tree = buildTreeFromOrdering!(fg, vo)</code></pre><p>The temporary elimination values in <code>fg</code> can be reset with (currently rather aggressive):</p><pre><code class="language-julia">resetFactorGraphNewTree!(fg)</code></pre><p>These steps are combined in a wrapper function:</p><pre><code class="language-julia">resetBuildTreeFromOrder!(fg, vo)</code></pre><h3><a class="nav-anchor" id="Manipulating-the-Variable-Ordering-1" href="#Manipulating-the-Variable-Ordering-1">Manipulating the Variable Ordering</a></h3><pre><code class="language-julia">vo = [:x1; :l3; :x2; ...]</code></pre><blockquote><p><strong>Note</strong> that a list of variables or factors can be obtained through the <code>ls</code> and related functions:</p></blockquote><p>Variables:</p><pre><code class="language-julia">unsorted = ls(fg)
unsorted = ls(fg, Pose2) # by variable type
unsorted = ls(fg, r&quot;x&quot;)  # by regex
unsorted = intersect(ls(fg, r&quot;x&quot;), ls(fg, Pose2))  # by regex

# sorting
sorted = sortDFG(unsorted)  # deprecated name sortVarNested(unsorted)</code></pre><p>Factors:</p><pre><code class="language-julia">unsorted = lsf(fg)
unsorted = ls(fg, Pose2Point2BearingRange)</code></pre><h2><a class="nav-anchor" id="Interfacing-with-&#39;mmisam&#39;-Solver-1" href="#Interfacing-with-&#39;mmisam&#39;-Solver-1">Interfacing with &#39;mmisam&#39; Solver</a></h2><p>The regular solver used in IIF is:</p><pre><code class="language-julia">tree, smt, hist = solveTree!(fg)</code></pre><p>where a new tree is constructed internally.  In order to recycle computations from a previous tree, the following interface can be used:</p><pre><code class="language-julia">tree, smt, hist = solveTree!(fg, tree)</code></pre><p>which will replace the <code>tree</code> object pointer to the new tree object after solution.  The following parmaters (set before calling <code>solveTree!</code>) will show the solution progress on the tree visualization:</p><pre><code class="language-julia">getSolverParams(fg).drawtree = true
getSolverParams(fg).showtree = true</code></pre><p>The color legend is currently recorded in an <a href="https://github.com/JuliaRobotics/IncrementalInference.jl/issues/349">issue thread here</a>.</p><h3><a class="nav-anchor" id="Clique-State-Machine-1" href="#Clique-State-Machine-1">Clique State Machine</a></h3><p>The mmisam solver is based on a state machine design to handle the inter and intra clique operations during a variety of situations.  Use of the clique state machine (CSM) makes debugging, development, verification, and modification of the algorithm real easy.  Contact us for any support regarding modifications to the default algorithm.  For pre-docs on working with CSM, please see <a href="https://github.com/JuliaRobotics/IncrementalInference.jl/issues/443">IIF #443</a>.</p><footer><hr/><a class="previous" href="../filterCorrespondence/"><span class="direction">Previous</span><span class="title">Filters vs. Graphs</span></a><a class="next" href="../../concepts/adding_variables_factors/"><span class="direction">Next</span><span class="title">Custom Variables and Factors</span></a></footer></article></body></html>
