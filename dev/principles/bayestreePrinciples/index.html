<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bayes (Junction) tree · Caesar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Caesar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../introduction/">Introduction</a></li><li><a class="tocitem" href="../../concepts/why_nongaussian/">Gaussian vs. Non-Gaussian</a></li><li><a class="tocitem" href="../../installation_environment/">Installation</a></li><li><a class="tocitem" href="../../concepts/using_julia/">Using Julia</a></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../concepts/concepts/">Initial Concepts</a></li><li><a class="tocitem" href="../../concepts/building_graphs/">Building Graphs</a></li><li><a class="tocitem" href="../../concepts/solving_graphs/">Solving Graphs</a></li><li><a class="tocitem" href="../../concepts/interacting_fgs/">Interact w Graphs</a></li><li><a class="tocitem" href="../../concepts/dataassociation/">Multi-Modal/Hypothesis</a></li><li><a class="tocitem" href="../../concepts/parallel_processing/">Parallel Processing</a></li><li><a class="tocitem" href="../../examples/parametric_solve/">[DEV] Parametric Solve</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/examples/">Caesar Examples</a></li><li><a class="tocitem" href="../../examples/basic_continuousscalar/">Canonical 1D Example</a></li><li><a class="tocitem" href="../../examples/basic_slamedonut/">Underconstrained Range-only</a></li><li><a class="tocitem" href="../../examples/basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="tocitem" href="../../examples/interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li><li><a class="tocitem" href="../../examples/deadreckontether/">Dead Reckon Tether</a></li></ul></li><li><span class="tocitem">Graph Library</span><ul><li><a class="tocitem" href="../../examples/canonical_graphs/">Canonical Generators</a></li><li><a class="tocitem" href="../../concepts/entry_data/">Entry=&gt;Data Blob</a></li><li><a class="tocitem" href="../../concepts/available_varfacs/">Variables/Factors</a></li><li><a class="tocitem" href="../../concepts/flux_factors/">Flux (NN) Factors</a></li><li><a class="tocitem" href="../../examples/using_images/">Images and AprilTags</a></li></ul></li><li><span class="tocitem">Visualization</span><ul><li><a class="tocitem" href="../../install_viz/">Installing Viz</a></li><li><a class="tocitem" href="../../concepts/2d_plotting/">Plotting (2D)</a></li><li><a class="tocitem" href="../../concepts/arena_visualizations/">Visualization (3D)</a></li></ul></li><li><span class="tocitem">Middlewares</span><ul><li><a class="tocitem" href="../../examples/using_ros/">ROS Middleware</a></li><li><a class="tocitem" href="../../concepts/compile_binary/">Compile Binaries</a></li><li><a class="tocitem" href="../../concepts/zero_install/">Zero Install Solution</a></li><li><a class="tocitem" href="../../concepts/multisession/">Multi-session/agent Solving</a></li><li><a class="tocitem" href="../../concepts/multilang/">Multi-Language Support</a></li></ul></li><li><span class="tocitem">How to Expand?</span><ul><li><a class="tocitem" href="../../caesar_framework/">Pkg Framework</a></li><li><a class="tocitem" href="../../examples/custom_variables/">Custom Variables</a></li><li><a class="tocitem" href="../../examples/basic_definingfactors/">Custom Prior Factor</a></li><li><a class="tocitem" href="../../examples/custom_relative_factors/">Custom Relative Factor</a></li><li><a class="tocitem" href="../../examples/custom_factor_features/">Important Factor Features</a></li><li><a class="tocitem" href="../../examples/adding_variables_factors/">Variable/Factor Considerations</a></li><li><a class="tocitem" href="../../func_ref/">More Functions</a></li></ul></li><li><span class="tocitem">Principles</span><ul><li><a class="tocitem" href="../filterCorrespondence/">Filters vs. Graphs</a></li><li><a class="tocitem" href="../approxConvDensities/">Generic Convolutions</a></li><li><a class="tocitem" href="../multiplyingDensities/">Multiplying Functions (.py)</a></li><li class="is-active"><a class="tocitem" href>Bayes (Junction) tree</a><ul class="internal"><li><a class="tocitem" href="#Why-a-Bayes-(Junction)-tree"><span>Why a Bayes (Junction) tree</span></a></li><li><a class="tocitem" href="#What-is-a-Bayes-(Junction)-tree"><span>What is a Bayes (Junction) tree</span></a></li><li><a class="tocitem" href="#Constructing-a-Tree"><span>Constructing a Tree</span></a></li><li><a class="tocitem" href="#Variable-Ordering"><span>Variable Ordering</span></a></li><li><a class="tocitem" href="#Interfacing-with-the-MM-iSAMv2-Solver"><span>Interfacing with the MM-iSAMv2 Solver</span></a></li><li><a class="tocitem" href="#Visualizing"><span>Visualizing</span></a></li><li><a class="tocitem" href="#Clique-State-Machine"><span>Clique State Machine</span></a></li></ul></li><li><a class="tocitem" href="../initializingOnBayesTree/">Advanced Bayes Tree Topics</a></li><li><a class="tocitem" href="../../concepts/mmisam_alg/">Non-Gaussian Algorithm</a></li></ul></li><li><span class="tocitem">Developer Zone</span><ul><li><a class="tocitem" href="../../dev/wiki/">Wiki Pointers</a></li><li><a class="tocitem" href="../../examples/legacy_deffactors/">Legacy Factors</a></li><li><a class="tocitem" href="../interm_dynpose/">Creating DynPose Factor</a></li><li><a class="tocitem" href="../../dev/known_issues/">Known Issue List</a></li><li><a class="tocitem" href="../../dev/internal_fncs/">Internal Functions</a></li></ul></li><li><span class="tocitem">Literature</span><ul><li><a class="tocitem" href="../../refs/literature/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Principles</a></li><li class="is-active"><a href>Bayes (Junction) tree</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bayes (Junction) tree</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/principles/bayestreePrinciples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Principle:-Bayes-tree-prototyping"><a class="docs-heading-anchor" href="#Principle:-Bayes-tree-prototyping">Principle: Bayes tree prototyping</a><a id="Principle:-Bayes-tree-prototyping-1"></a><a class="docs-heading-anchor-permalink" href="#Principle:-Bayes-tree-prototyping" title="Permalink"></a></h1><p>This page describes how to visualize, study, test, and compare Bayes (Junction) tree concepts with special regard for variable ordering.</p><h2 id="Why-a-Bayes-(Junction)-tree"><a class="docs-heading-anchor" href="#Why-a-Bayes-(Junction)-tree">Why a Bayes (Junction) tree</a><a id="Why-a-Bayes-(Junction)-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Why-a-Bayes-(Junction)-tree" title="Permalink"></a></h2><p>The tree is algebraicly equivalent–-but acyclic–-structure to the factor graph:  i.) Inference is easier on on acyclic graphs; ii.) We can exploit Smart Message Passing benefits (known from the full conditional independence structure encoded in the tree), since the tree represents the &quot;complete form&quot; when marginalizing each variable one at a time (also known as elimination game, marginalization, also related to smart factors).  In loose terms, the Bayes (Junction) tree has implicit access to all Schur complements (if it parametric and linearized) of each variable to all others.  Please see <a href="https://www.juliarobotics.org/Caesar.jl/latest/principles/initializingOnBayesTree/">this page more information regarding advanced topics on the Bayes tree</a>.</p><h2 id="What-is-a-Bayes-(Junction)-tree"><a class="docs-heading-anchor" href="#What-is-a-Bayes-(Junction)-tree">What is a Bayes (Junction) tree</a><a id="What-is-a-Bayes-(Junction)-tree-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-a-Bayes-(Junction)-tree" title="Permalink"></a></h2><p>The Bayes tree data structure is a rooted and directed Junction tree (maximal elimination clique tree). It allows for exact inference to be carried out by leveraging and exposing the variables&#39; conditional independence and, very interestingly, can be directly associated with the sparsity pattern exhibited by a system&#39;s factorized upper triangular square root information matrix (see picture below).</p><p><img src="https://user-images.githubusercontent.com/27132241/69210533-f55da400-0b52-11ea-89dd-f18b7fa983b8.png" alt="graph and matrix analagos"/></p><p>Following this matrix-graph parallel, the picture also shows what the associated matrix interpretation is for a factor graph (~first order expansion in the form of a measurement Jacobian) and its corresponding Markov random field (sparsity pattern corresponding to the information matrix).</p><p>The procedure for obtaining the Bayes (Junction) tree is outlined in the figure shown below (factor graph to chrodal Bayes net via bipartite elimination game, and chordal Bayes net to Bayes tree via maximum cardinality search algorithm).</p><p><img src="https://user-images.githubusercontent.com/27132241/69210647-5eddb280-0b53-11ea-82ab-dc5ff89c4a43.png" alt="add the fg2net2tree outline"/></p><h2 id="Constructing-a-Tree"><a class="docs-heading-anchor" href="#Constructing-a-Tree">Constructing a Tree</a><a id="Constructing-a-Tree-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-a-Tree" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A visual illustration of factor graph to Bayes net to Bayes tree can be <a href="https://github.com/JuliaRobotics/IncrementalInference.jl/files/3929194/hex-slam.pdf">found in this PDF</a> </p></div></div><p>Trees and factor graphs are separated in the implementation, allowing the user to construct multiple different trees from one factor graph except for a few temporary values in the factor graph.</p><pre><code class="language-julia hljs">using IncrementalInference # RoME or Caesar will work too

## construct a distributed factor graph object
fg = generateGraph_Kaess()
# add variables and factors
# ...

## build the tree
tree = buildTreeReset!(fg)</code></pre><p>The temporary values are <code>reset</code> from the distributed factor graph object <code>fg&lt;:AbstractDFG</code> and a new tree is constructed.  This <code>buildTreeReset!</code> call can be repeated as many times the user desires and results should be consistent for the same factor graph structure (regardless of numerical values contained within).</p><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.buildTreeReset!" href="#IncrementalInference.buildTreeReset!"><code>IncrementalInference.buildTreeReset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">buildTreeReset!(dfg)
buildTreeReset!(dfg, eliminationOrder; variableOrder, ordering, drawpdf, show, filepath, viewerapp, imgs, ensureSolvable, eliminationConstraints, variableConstraints)
</code></pre><p>Build a completely new Bayes (Junction) tree, after first wiping clean all temporary state in fg from a possibly pre-existing tree.</p><p>DevNotes</p><ul><li>replaces <code>resetBuildTreeFromOrder!</code></li></ul><p>Related:</p><p>buildTreeFromOrdering!, </p></div></section></article><h2 id="Variable-Ordering"><a class="docs-heading-anchor" href="#Variable-Ordering">Variable Ordering</a><a id="Variable-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Ordering" title="Permalink"></a></h2><h3 id="Getting-the-AMD-Variable-Ordering"><a class="docs-heading-anchor" href="#Getting-the-AMD-Variable-Ordering">Getting the AMD Variable Ordering</a><a id="Getting-the-AMD-Variable-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-the-AMD-Variable-Ordering" title="Permalink"></a></h3><p>The variable ordering is described as a <code>::Vector{Symbol}</code>.  Note the automated methods can be varied between AMD, CCOLAMD, and others.</p><pre><code class="language-julia hljs"># get the automated variable elimination order
vo = getEliminationOrder(fg)</code></pre><p>It is also possible to manually define the Variable Ordering</p><pre><code class="language-julia hljs">vo = [:x1; :l3; :x2; ...]</code></pre><p>And then reset the factor graph and build a new tree</p><pre><code class="language-julia hljs">buildTreeReset!(fg, vo)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>a list of variables or factors can be obtained through the <code>ls</code> and related functions, see <a href="../../concepts/interacting_fgs/#Querying-the-FactorGraph">Querying the FactorGraph</a>.</p></div></div><h2 id="Interfacing-with-the-MM-iSAMv2-Solver"><a class="docs-heading-anchor" href="#Interfacing-with-the-MM-iSAMv2-Solver">Interfacing with the MM-iSAMv2 Solver</a><a id="Interfacing-with-the-MM-iSAMv2-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Interfacing-with-the-MM-iSAMv2-Solver" title="Permalink"></a></h2><p>The following parmaters (set before calling <code>solveTree!</code>) will show the solution progress on the tree visualization:</p><pre><code class="language-julia hljs">getSolverParams(fg).drawtree = true
getSolverParams(fg).showtree = true

# asybc process will now draw and show the tree in linux
tree = solveTree!(fg)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>See the <a href="principles/@ref">Solving Graphs</a> section for more details on the solver.</p></div></div><h3 id="Get-the-Elimination-Order-Used"><a class="docs-heading-anchor" href="#Get-the-Elimination-Order-Used">Get the Elimination Order Used</a><a id="Get-the-Elimination-Order-Used-1"></a><a class="docs-heading-anchor-permalink" href="#Get-the-Elimination-Order-Used" title="Permalink"></a></h3><p>The solver internally uses <a href="#IncrementalInference.buildTreeReset!"><code>buildTreeReset!</code></a> which sometimes requires the user extract the variable elimination order after the fact.  This can be done with:</p><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.getEliminationOrder" href="#IncrementalInference.getEliminationOrder"><code>IncrementalInference.getEliminationOrder</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Determine the variable ordering used to construct both the Bayes Net and Bayes/Junction/Elimination tree.</p><p>Notes</p><ul><li>Heuristic method – equivalent to QR or Cholesky.</li><li>Are using Blas <code>QR</code> function to extract variable ordering.</li><li><strong>NOT USING SUITE SPARSE</strong> – which would requires commercial license.</li><li>For now <code>A::Array{&lt;:Number,2}</code> as a dense matrix.</li><li>Columns of <code>A</code> are system variables, rows are factors (without differentiating between partial or full factor).</li><li>default is to use <code>solvable=1</code> and ignore factors and variables that might be used for dead reckoning or similar.</li></ul><p>Future</p><ul><li>TODO: <code>A</code> should be sparse data structure (when we exceed 10&#39;000 var dims)</li><li>TODO: Incidence matrix is rectagular and adjacency is the square.</li></ul></div></section><section><div><pre><code class="language-julia hljs">getEliminationOrder(treel)
</code></pre><p>Return the variable elimination order stored in a tree object.</p></div></section></article><h2 id="Visualizing"><a class="docs-heading-anchor" href="#Visualizing">Visualizing</a><a id="Visualizing-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing" title="Permalink"></a></h2><p>IncrementalInference.jl includes functions for visualizing the Bayes tree, and uses outside packages such as GraphViz (standard) and Latex tools (experimental, optional) to do so.  </p><h3 id="GraphViz"><a class="docs-heading-anchor" href="#GraphViz">GraphViz</a><a id="GraphViz-1"></a><a class="docs-heading-anchor-permalink" href="#GraphViz" title="Permalink"></a></h3><pre><code class="language-julia hljs">drawTree(tree, show=true) # , filepath=&quot;/tmp/caesar/mytree.pdf&quot;</code></pre><article class="docstring"><header><a class="docstring-binding" id="IncrementalInference.drawTree" href="#IncrementalInference.drawTree"><code>IncrementalInference.drawTree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">drawTree(treel; show, suffix, filepath, xlabels, dpi, viewerapp, imgs)
</code></pre><p>Draw the Bayes (Junction) tree by means of graphviz <code>.dot</code> files.  Ensure Linux packages  are installed <code>sudo apt-get install graphviz xdot</code>.</p><p>Notes</p><ul><li><code>xlabels</code> is optional <code>cliqid=&gt;xlabel</code>.</li></ul></div></section></article><h3 id="Latex-Tikz-(Optional)"><a class="docs-heading-anchor" href="#Latex-Tikz-(Optional)">Latex Tikz (Optional)</a><a id="Latex-Tikz-(Optional)-1"></a><a class="docs-heading-anchor-permalink" href="#Latex-Tikz-(Optional)" title="Permalink"></a></h3><p><strong>EXPERIMENTAL</strong>, requiring special import.</p><p>First make sure the following packages are installed on your system:</p><pre><code class="nohighlight hljs">$ sudo apt-get install texlive-pictures dot2tex
$ pip install dot2tex</code></pre><p>Then in Julia you should be able to do:</p><pre><code class="language-julia hljs">import IncrementalInference: generateTexTree

generateTexTree(tree)</code></pre><p>An example Bayes (Junction) tree representation obtained through <code>generateTexTree(tree)</code> for the sample factor graph shown above can be seen in the following image.</p><p align="center">
<img src="https://user-images.githubusercontent.com/27132241/69210722-9e0c0380-0b53-11ea-9462-7964844b89b1.png" width="200" border="0" />
</p><h3 id="Visualizing-Clique-Adjacency-Matrix"><a class="docs-heading-anchor" href="#Visualizing-Clique-Adjacency-Matrix">Visualizing Clique Adjacency Matrix</a><a id="Visualizing-Clique-Adjacency-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-Clique-Adjacency-Matrix" title="Permalink"></a></h3><p>It is also possible to see the upward message passing variable/factor association matrix for each clique, requiring the Gadfly.jl package:</p><pre><code class="language-julia hljs">using Gadfly

spyCliqMat(tree, :x1) # provided by IncrementalInference

#or embedded in graphviz
drawTree(tree, imgs=true, show=true)</code></pre><h2 id="Clique-State-Machine"><a class="docs-heading-anchor" href="#Clique-State-Machine">Clique State Machine</a><a id="Clique-State-Machine-1"></a><a class="docs-heading-anchor-permalink" href="#Clique-State-Machine" title="Permalink"></a></h2><p>The mmisam solver is based on a state machine design to handle the inter and intra clique operations during a variety of situations.  Use of the clique state machine (CSM) makes debugging, development, verification, and modification of the algorithm real easy.  Contact us for any support regarding modifications to the default algorithm.  For pre-docs on working with CSM, please see <a href="https://github.com/JuliaRobotics/IncrementalInference.jl/issues/443">IIF #443</a>.</p><h3 id="STATUS-of-a-Clique"><a class="docs-heading-anchor" href="#STATUS-of-a-Clique">STATUS of a Clique</a><a id="STATUS-of-a-Clique-1"></a><a class="docs-heading-anchor-permalink" href="#STATUS-of-a-Clique" title="Permalink"></a></h3><p>CSM currently uses the following statusses for each of the cliques during the inference process.</p><pre><code class="language-julia hljs">[:initialized;:upsolved;:marginalized;:downsolved;:uprecycled]</code></pre><h3 id="Bayes-Tree-Legend-(from-IIF)"><a class="docs-heading-anchor" href="#Bayes-Tree-Legend-(from-IIF)">Bayes Tree Legend (from IIF)</a><a id="Bayes-Tree-Legend-(from-IIF)-1"></a><a class="docs-heading-anchor-permalink" href="#Bayes-Tree-Legend-(from-IIF)" title="Permalink"></a></h3><p>The color legend for the refactored CSM from <a href="https://github.com/JuliaRobotics/IncrementalInference.jl/issues/1007">issue</a>.</p><ul><li>Blank / white – uninitialized or unprocessed,</li><li>Orange – recycled clique upsolve solution from previous tree passed into <code>solveTree!</code> – TODO,</li><li>Blue – fully marginalized clique that will not be updated during upsolve (maybe downsolved),</li><li>Light blue – completed downsolve,</li><li>Green – trying to up initialize,</li><li>Darkgreen – <code>initUp</code> some could up init,</li><li>Lightgreen – <code>initUp</code> no aditional variables could up init,</li><li>Olive – trying to down initialize,</li><li>Seagreen – <code>initUp</code> some could down init,</li><li>Khaki – <code>initUp</code> no aditional variables could down init,</li><li>Brown – initialized but not solved yet (likely child cliques that depend on downward autoinit msgs),</li><li>Light red – completed upsolve,</li><li>Tomato – partial dimension upsolve but finished,</li><li>Red – CPU working on clique&#39;s Chapman-Kolmogorov inference (up),</li><li>Maroon – CPU working on clique&#39;s Chapman-Kolmogorov inference (down),</li><li>Red – If finished cliques in red are in <code>ERROR_STATUS</code></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../multiplyingDensities/">« Multiplying Functions (.py)</a><a class="docs-footer-nextpage" href="../initializingOnBayesTree/">Advanced Bayes Tree Topics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 4 December 2021 23:59">Saturday 4 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
