<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generic Convolutions · Caesar.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Caesar.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Getting Started</span><ul><li><a class="toctext" href="../../installation_environment/">Installation</a></li><li><a class="toctext" href="../../faq/">FAQ</a></li></ul></li><li><span class="toctext">Initial Concepts</span><ul><li><a class="toctext" href="../../concepts/concepts/">Caesar Concepts</a></li><li><a class="toctext" href="../../concepts/building_graphs/">Building Factor Graphs</a></li><li><a class="toctext" href="../../concepts/available_varfacs/">Available Variables/Factors</a></li><li><a class="toctext" href="../../concepts/interacting_fgs/">Interacting w/ Factor Graphs</a></li><li><a class="toctext" href="../../concepts/mmisam_alg/">Multimodal iSAM Algorithm</a></li><li><a class="toctext" href="../../concepts/multilang/">Multi-Language Support</a></li><li><a class="toctext" href="../../concepts/arena_visualizations/">Arena Visualization</a></li><li><a class="toctext" href="../../concepts/database_interactions/">Cloud Server/Database</a></li><li><a class="toctext" href="../../concepts/multisession/">Multi/Cross Session Solving</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/examples/">Caesar Examples</a></li><li><a class="toctext" href="../../examples/basic_continuousscalar/">ContinuousScalar as 1D Example</a></li><li><a class="toctext" href="../../examples/basic_slamedonut/">Under-defined Trilateration SLAM 2D</a></li><li><a class="toctext" href="../../examples/basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="toctext" href="../../examples/interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li></ul></li><li><span class="toctext">Principles</span><ul><li><a class="toctext" href="../multiplyingDensities/">Multiplying Functions (.py)</a></li><li class="current"><a class="toctext" href>Generic Convolutions</a><ul class="internal"><li><a class="toctext" href="#Convolutions-of-Infinite-Objects-(Functionals)-1">Convolutions of Infinite Objects (Functionals)</a></li><li><a class="toctext" href="#A-Handy-ZMQ-interface-to-Generic-Convolutions-1">A Handy ZMQ interface to Generic Convolutions</a></li><li><a class="toctext" href="#Underlying-Mathematical-Operations-1">Underlying Mathematical Operations</a></li></ul></li></ul></li><li><span class="toctext">How to Expand?</span><ul><li><a class="toctext" href="../../concepts/adding_variables_factors/">Custom Variables and Factors</a></li><li><a class="toctext" href="../../examples/basic_definingfactors/">Creating Variables and Factors</a></li><li><a class="toctext" href="../../examples/interm_dynpose/">Creating DynPose Factor</a></li></ul></li><li><span class="toctext">Developer Zone</span><ul><li><a class="toctext" href="../../dev/wiki/">Wiki Pointer</a></li></ul></li><li><span class="toctext">Literature</span><ul><li><a class="toctext" href="../../refs/literature/">References</a></li></ul></li><li><span class="toctext">Function Reference</span><ul><li><a class="toctext" href="../../func_ref/">Caesar&#39;s Reference</a></li><li><a class="toctext" href="../../vis_func_ref/">Visualization Reference</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Principles</li><li><a href>Generic Convolutions</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/principles/approxConvDensities.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generic Convolutions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Principle:-Approximate-Convolutions-1" href="#Principle:-Approximate-Convolutions-1">Principle: Approximate Convolutions</a></h1><p>This example illustrates a central concept of approximating the convolution of belief density functions.  Convolutions are required to compute (estimate) the probabilistic chain rule with conditional probability density functions.  One easy illustration is robotics where an odometry chain of poses has a continuous increase–-or spreading–-of the confidence/uncertainty of a next pose.  This tutorial will demonstrate that process.</p><p>This page describes a Julia language interface, followed by a CaesarZMQ interface; a link to the mathematical description is provided thereafter.</p><h2><a class="nav-anchor" id="Convolutions-of-Infinite-Objects-(Functionals)-1" href="#Convolutions-of-Infinite-Objects-(Functionals)-1">Convolutions of Infinite Objects (Functionals)</a></h2><p>Consider the following vehicle odometry prediction (probabilistic) operation, where odometry measurement Z is an independent stochastic process from prior belief on pose X0</p><div>\[P(X_1 | X_0, Z) \approx p(Z | X_0, X_1) p(X_0),\]</div><p>and recognize this process as a convolution operation where the prior belief on X0 is spread to a less certain prediction of pose X1.</p><p>Note that this operation is precisely the same as a prediction step in filtering applications, where the state transition model–-usually annotated as <code>d/dt x = f(x, z)</code>–-is here presented by the conditional belief <code>p(Z | X_0, X_1)</code>.</p><p>The convolution computation described above is a core operation required for solving the <a href="http://www.juliarobotics.org/Caesar.jl/latest/concepts/mmisam_alg/">Chapman-Kolmogorov transit equations</a>.</p><p>The following section illustrates a single convolution operation by using a few high level and some low level function calls.  An additional tutorial exists where <a href="http://www.juliarobotics.org/Caesar.jl/latest/examples/basic_continuousscalar.md">a related example</a> in one dimension is performed as a complete factor graph solution/estimation problem.</p><h3><a class="nav-anchor" id="Illustrated-Calculation-in-Julia-1" href="#Illustrated-Calculation-in-Julia-1">Illustrated Calculation in Julia</a></h3><p>The <a href="http://www.github.com/JuliaRobotics/IncrementalInference.jl">IncrementalInference.jl</a> package provides a generic interface for estimating the convolution of full functional objects given some user specified residual or cost function.  The residual/cost function is then used, with the help of non-linear gradient decent, to project/resolve a set of particles for any one variable associated with a any factor.  In the binary variable factor case, such as the odometry tutorial, either pose X2 will be resolved from X1 using the user supplied likelihood residual function, or visa versa for X1 from X2.  </p><blockquote><p>Note in a factor graph sense, the flow of time is captured in the structure of the graph and a requirement of the IncrementalInference system is that factors can be resolved towards any variable, given current estimates on all other variables connected to that factor.  Furthermore, this forwards or backwards resolving/convolution through a factor should adhere to the Kolmogorov Criterion of reversibility to ensure that detailed balance is maintained in the overall marginal posterior solutions.</p></blockquote><p>The IncrementalInference (IIF) package provides a few generic conditional likelihood functions such as <code>LinearConditional</code> or <code>MixtureLinearConditional</code> which we will use in this illustration.  </p><blockquote><p>Note that the <a href="http://www.github.com/JuliaRobotics/RoME.jl">RoME.jl</a> package provides many more factors that are useful to robotics applications.  For a listing of current factors see <a href="http://www.juliarobotics.org/Caesar.jl/latest/concepts/available_varfacs.md">this docs page</a>, details on developing <a href="http://www.juliarobotics.org/Caesar.jl/latest/concepts/adding_variables_factors.md">your own factors on this page</a>.  One of the clear design objectives of the IIF package was to allow easier user extension of arbitrary residual functions that allows for vast capacity to represent non-Gaussian stochastic processes.</p></blockquote><p>Consider a robot traveling in one dimension, progressing along the x-axis at varying speed.  Lets assume pose locations are determined by a constant delta-time rule of say one pose every second, named <code>X0</code>, <code>X1</code>, <code>X2</code>, and so on.</p><blockquote><p>Note the bread-crum discretization of the trajectory history by means of poses can later be used to allow estimation of previously unknown mapping parameters simultaneous to the ongoing localization problem.</p></blockquote><p>Lets a few basic factor graph operations to develop the desired convolutions:</p><pre><code class="language-julia">using IncrementalInference

# empty factor graph container
fg = initfg()

# add two variables of interest
addVariable!(fg, :x0, ContinuousScalar)
addVariable!(fg, :x1, ContinuousScalar)

# gauge the solution by adding the first prior information that represents all history up to the current starting position for the robot
pr = Prior(Normal(0.0, 0.1))
addFactor!(fg, [:x0], pr)

# numerically initialize variable :x0 -- this avoids repeat computations later (specific to this tutorial)
doautoinit!(fg, :x0)

# lastly add the odometry conditional likelihood function between the two variables of interest
odo = LinearConditional(Rayleigh(...))
addFactor!(fg, [:x0;:x1], odo)  # note the list is order sensitive</code></pre><p>The code block above (not solved yet) describes a algebraic setup exactly equivalent to the convolution equation presented at the top of this page.  </p><blockquote><p>IIF does not require the distribution functions to only be parametric, such as Normal, Rayleigh, mixture models, but also allows intensity based values or kernel density estimates.  Parametric types are just used here for ease of illustration.</p></blockquote><p>To perform an stochastic approximate convolution with the odometry conditional, one can simply call a low level function used the mmisam solver:</p><pre><code class="language-julia">pts = approxConv(fg, :x0x1f1, :x1)</code></pre><p>The <code>approxConv</code> function call reads as a operation on <code>fg</code> which won&#39;t influence any values of parameter list (common Julia exclamation mark convention) and must use the first factor <code>:x0x1f1</code> to resolve a convolution on target variable <code>:x1</code>.  Implicitly, this result is based on the current estimate contained in <code>:x0</code>.  The value of <code>pts</code> is a <code>:;Array{Float64,2}</code> where the rows represent the different dimensions (1-D in this case) and the columns are each of the different samples drawn from the intermediate posterior (i.e. convolution result).  </p><p>IIF currently uses kernel density estimation to convert discrete samples into a smooth function estimate – more details can be found on the function <a href="http://www.juliarobotics.org/Caesar.jl/latest/principles/functionApprox.md">approximation principles page here</a>.  The sample set can be converted into an on-manifold functional object as follows:</p><pre><code class="language-julia"># create kde object by referencing back the existing memory location pts
hatX1 = manikde!(pts, ContinuousScalar)</code></pre><p>The functional object <code>X1</code> is now ready for other operations such as function evaluation or product computations discussed on <a href="http://www.juliarobotics.org/Caesar.jl/latest/principles/multiplyingDensities.md">another principles page</a>.  The <code>ContinuousScalar</code> manifold is just the real line in Euclidean space, internally denoted as single element tuple <code>(:Euclid,)</code>.</p><h2><a class="nav-anchor" id="A-Handy-ZMQ-interface-to-Generic-Convolutions-1" href="#A-Handy-ZMQ-interface-to-Generic-Convolutions-1">A Handy ZMQ interface to Generic Convolutions</a></h2><blockquote><p><strong>NOTE</strong> WIP on expanding ZMQ interface:</p></blockquote><p>In addition, <code>ZmqCaesar</code> offers a <code>ZMQ</code> interface to the factor graph solution for multilanguage support.  This example is a small subset that shows how to use the <code>ZMQ</code> infrastructure, but avoids the larger factor graph related calls.</p><p>...</p><h2><a class="nav-anchor" id="Underlying-Mathematical-Operations-1" href="#Underlying-Mathematical-Operations-1">Underlying Mathematical Operations</a></h2><p>In order to compute generic convolutions, the mmisam algorithm uses non-linear gradient descent to resolve estimates of the target variable based on the values of other dependent variables.  The conditional likelihood (multidimensional factor) is based on a residual function:</p><div>\[z_i = \delta_i (\theta_i)\]</div><p>where <code>z_i</code> is the innovation of any smooth twice differentiable residual function delta.  The residual function depends on specific variables collected as theta_i.  The IIF code supports both root finding or minimization trust-region operations, which are each provided by <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a> or <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> packages respectively.</p><p>The choice between root finding or minimization is a performance consideration only.  Minimization of the residual squared will always work but certain situations allow direct root finding to be used.  If the residual function is guaranteed to cross zero–-i.e. <code>z*=0</code>–-the root finding approach can be used.  Each measurement function has a certain number of dimensions – e.g. ranges or bearings are dimension one, and an inter Pose2 rigid transform (delta x, y, theta) is dimension 3.  If the variable being resolved has larger dimension than the measurement residual, then the minimization approach must be used.</p><p>The method of solving the target variable is to fix all other variable values and resolve, sample by sample, the particle estimates of the target.  The Julia programming language has good support for functional programming and is used extensively in the IIF implementation to utilize user defined functions to resolve any variable, including the null-hypothesis and multi-hypothesis generalizations. </p><footer><hr/><a class="previous" href="../multiplyingDensities/"><span class="direction">Previous</span><span class="title">Multiplying Functions (.py)</span></a><a class="next" href="../../concepts/adding_variables_factors/"><span class="direction">Next</span><span class="title">Custom Variables and Factors</span></a></footer></article></body></html>
