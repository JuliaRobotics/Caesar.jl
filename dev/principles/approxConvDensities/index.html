<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generic Convolutions · Caesar.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Caesar.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../installation_environment/">Installation</a></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul></li><li><span class="tocitem">Initial Concepts</span><ul><li><a class="tocitem" href="../../concepts/concepts/">Caesar Concepts</a></li><li><a class="tocitem" href="../../concepts/building_graphs/">Building Factor Graphs</a></li><li><a class="tocitem" href="../../concepts/available_varfacs/">Available Variables/Factors</a></li><li><a class="tocitem" href="../../concepts/interacting_fgs/">Interacting w/ Factor Graphs</a></li><li><a class="tocitem" href="../../concepts/multilang/">Multi-Language Support</a></li><li><a class="tocitem" href="../../concepts/arena_visualizations/">Arena Visualization</a></li><li><a class="tocitem" href="../../concepts/database_interactions/">Cloud Server/Database</a></li><li><a class="tocitem" href="../../concepts/multisession/">Multi/Cross Session Solving</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/examples/">Caesar Examples</a></li><li><a class="tocitem" href="../../examples/basic_continuousscalar/">ContinuousScalar as 1D Example</a></li><li><a class="tocitem" href="../../examples/basic_slamedonut/">Under-defined Trilateration SLAM 2D</a></li><li><a class="tocitem" href="../../examples/basic_hexagonal2d/">Hexagonal 2D SLAM</a></li><li><a class="tocitem" href="../../examples/interm_fixedlag_hexagonal/">Fixed-Lag Solving 2D</a></li></ul></li><li><span class="tocitem">Principles</span><ul><li><a class="tocitem" href="../filterCorrespondence/">Filters vs. Graphs</a></li><li class="is-active"><a class="tocitem" href>Generic Convolutions</a><ul class="internal"><li><a class="tocitem" href="#Convolutions-of-Infinite-Objects-(Functionals)-1"><span>Convolutions of Infinite Objects (Functionals)</span></a></li><li><a class="tocitem" href="#Underlying-Mathematical-Operations-1"><span>Underlying Mathematical Operations</span></a></li><li><a class="tocitem" href="#A-Handy-ZMQ-interface-to-Generic-Convolutions-1"><span>A Handy ZMQ interface to Generic Convolutions</span></a></li></ul></li><li><a class="tocitem" href="../multiplyingDensities/">Multiplying Functions (.py)</a></li><li><a class="tocitem" href="../bayestreePrinciples/">Bayes (Junction) tree</a></li><li><a class="tocitem" href="../initializingOnBayesTree/">Advanced Bayes Tree Topics</a></li><li><a class="tocitem" href="../../concepts/mmisam_alg/">Multimodal iSAM Algorithm</a></li></ul></li><li><span class="tocitem">How to Expand?</span><ul><li><a class="tocitem" href="../../concepts/adding_variables_factors/">Custom Variables and Factors</a></li><li><a class="tocitem" href="../../examples/basic_definingfactors/">Creating Variables and Factors</a></li><li><a class="tocitem" href="../../examples/interm_dynpose/">Creating DynPose Factor</a></li></ul></li><li><span class="tocitem">Developer Zone</span><ul><li><a class="tocitem" href="../../dev/wiki/">Wiki Pointer</a></li></ul></li><li><span class="tocitem">Literature</span><ul><li><a class="tocitem" href="../../refs/literature/">References</a></li></ul></li><li><span class="tocitem">Function Reference</span><ul><li><a class="tocitem" href="../../func_ref/">Caesar&#39;s Reference</a></li><li><a class="tocitem" href="../../vis_func_ref/">Visualization Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Principles</a></li><li class="is-active"><a href>Generic Convolutions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generic Convolutions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/principles/approxConvDensities.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Principle:-Approximate-Convolutions-1"><a class="docs-heading-anchor" href="#Principle:-Approximate-Convolutions-1">Principle: Approximate Convolutions</a><a class="docs-heading-anchor-permalink" href="#Principle:-Approximate-Convolutions-1" title="Permalink"></a></h1><p>This example illustrates a central concept of approximating the convolution of belief density functions.  Convolutions are required to compute (estimate) the probabilistic chain rule with conditional probability density functions.  One easy illustration is robotics where an odometry chain of poses has a continuous increase–-or spreading–-of the confidence/uncertainty of a next pose.  This tutorial will demonstrate that process.</p><p>This page describes a Julia language interface, followed by a CaesarZMQ interface; a link to the mathematical description is provided thereafter.</p><h2 id="Convolutions-of-Infinite-Objects-(Functionals)-1"><a class="docs-heading-anchor" href="#Convolutions-of-Infinite-Objects-(Functionals)-1">Convolutions of Infinite Objects (Functionals)</a><a class="docs-heading-anchor-permalink" href="#Convolutions-of-Infinite-Objects-(Functionals)-1" title="Permalink"></a></h2><p>Consider the following vehicle odometry prediction (probabilistic) operation, where odometry measurement Z is an independent stochastic process from prior belief on pose X0</p><div>\[p(X_1 | X_0, Z) \propto p(Z | X_0, X_1) p(X_0),\]</div><p>and recognize this process as a convolution operation where the prior belief on X0 is spread to a less certain prediction of pose X1.  The figure below shows an example quasi-deterministic convolution of green densitty with the red density, which results in the black density below:</p><a href="https://darchive.mblwhoilibrary.org/bitstream/handle/1912/9305/Fourie_thesis.pdf?sequence=1" target="_blank"><img src="https://user-images.githubusercontent.com/6412556/61175404-3b4f9d80-a59e-11e9-85db-ca6bbdb73ffd.png" alt="Bayes/Junction tree example" width="480" border="0" /></a><p>Note that this operation is precisely the same as a <a href="https://www.juliarobotics.org/Caesar.jl/latest/principles/filterCorrespondence/">prediction step in filtering applications</a>, where the state transition model–-usually annotated as <code>d/dt x = f(x, z)</code>–-is here presented by the conditional belief <code>p(Z | X_0, X_1)</code>.</p><p>The convolution computation described above is a core operation required for solving the <a href="http://www.juliarobotics.org/Caesar.jl/latest/concepts/mmisam_alg/">Chapman-Kolmogorov transit equations</a>.</p><h2 id="Underlying-Mathematical-Operations-1"><a class="docs-heading-anchor" href="#Underlying-Mathematical-Operations-1">Underlying Mathematical Operations</a><a class="docs-heading-anchor-permalink" href="#Underlying-Mathematical-Operations-1" title="Permalink"></a></h2><p>In order to compute generic convolutions, the mmisam algorithm uses non-linear gradient descent to resolve estimates of the target variable based on the values of other dependent variables.  The conditional likelihood (multidimensional factor) is based on a residual function:</p><div>\[z_i = \delta_i (\theta_i)\]</div><p>where <code>z_i</code> is the innovation of any smooth twice differentiable residual function delta.  The residual function depends on specific variables collected as theta_i.  The IIF code supports both root finding or minimization trust-region operations, which are each provided by <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a> or <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> packages respectively.</p><p>The choice between root finding or minimization is a performance consideration only.  Minimization of the residual squared will always work but certain situations allow direct root finding to be used.  If the residual function is guaranteed to cross zero–-i.e. <code>z*=0</code>–-the root finding approach can be used.  Each measurement function has a certain number of dimensions – e.g. ranges or bearings are dimension one, and an inter Pose2 rigid transform (delta x, y, theta) is dimension 3.  If the variable being resolved has larger dimension than the measurement residual, then the minimization approach must be used.</p><p>The method of solving the target variable is to fix all other variable values and resolve, sample by sample, the particle estimates of the target.  The Julia programming language has good support for functional programming and is used extensively in the IIF implementation to utilize user defined functions to resolve any variable, including the null-hypothesis and multi-hypothesis generalizations.</p><p>The following section illustrates a single convolution operation by using a few high level and some low level function calls.  An additional tutorial exists where <a href="https://www.juliarobotics.org/Caesar.jl/latest/examples/basic_continuousscalar/">a related example</a> in one dimension is performed as a complete factor graph solution/estimation problem.</p><h4 id="Previous-Text-(to-be-merged-here)-1"><a class="docs-heading-anchor" href="#Previous-Text-(to-be-merged-here)-1">Previous Text (to be merged here)</a><a class="docs-heading-anchor-permalink" href="#Previous-Text-(to-be-merged-here)-1" title="Permalink"></a></h4><p>Proposal distributions are computed by means of (analytical or numerical – i.e. &quot;algebraic&quot;) factor which defines a residual function:</p><div>\[\delta : S \times \Eta \rightarrow \mathcal{R}\]</div><p>where <span>$S \times \Eta$</span> is the domain such that <span>$\theta_i \in S, \, \eta \sim P(\Eta)$</span>, and <span>$P(\cdot)$</span> is a probability.</p><p>A trust-region, nonlinear gradient decent method is used to enforce the residual function <span>$\delta (\theta_S)$</span> in a leave-one-out-Gibbs strategy for all the factors and variables in each clique.  Each time a factor residual is enforced for another particle along with a sample from the stochastic noise term.  Solutions are found either through root finding on &quot;full dimension&quot; equations (<a href="https://github.com/JuliaRobotics/IncrementalInference.jl/blob/62afec6300c899d567be29b06f8d9b0919b31878/src/SolverUtilities.jl#L128">source code here</a>):</p><div>\[\text{solve}_{\theta_i} ~ s.t. \, 0 = \delta(\theta_{S}; \eta)\]</div><p>Or minimization of &quot;low dimension&quot; equations (<a href="https://github.com/JuliaRobotics/IncrementalInference.jl/blob/62afec6300c899d567be29b06f8d9b0919b31878/src/SolverUtilities.jl#L72">source code here</a>) that might not have any roots in <span>$\theta_i$</span>:</p><div>\[\text{argmin}_{\theta_i} ~ [\delta(\theta_{S}; \eta)]^2\]</div><blockquote><p>Gradient decent methods are obtained from the Julia Package community, namely <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a> and <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>.</p></blockquote><p>The factor noise term can be any samplable belief (a.k.a. <a href="https://github.com/JuliaRobotics/IncrementalInference.jl/blob/2b9f1c3d03e796bc24fbcc622329769dadd94288/src/DefaultNodeTypes.jl#L3"><code>IIF.SamplableBelief</code></a>), either through algebraic modeling, or (<strong>critically</strong>) directly from the sensor measurement that is driven by the underlying physics process.  Parametric factors (<a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a>) or direct physical measurement noise can be used via <code>AliasingScalarSampler</code> or <code>KernelDensityEstimate</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Also see <a href="https://juliarobotics.org/Caesar.jl/latest/refs/literature/#Direct-References-1">[1.2], Chap. 5, Approximate Convolutions</a> for more details.</p></div></div><h3 id="Illustrated-Calculation-in-Julia-1"><a class="docs-heading-anchor" href="#Illustrated-Calculation-in-Julia-1">Illustrated Calculation in Julia</a><a class="docs-heading-anchor-permalink" href="#Illustrated-Calculation-in-Julia-1" title="Permalink"></a></h3><p>The <a href="http://www.github.com/JuliaRobotics/IncrementalInference.jl">IncrementalInference.jl</a> package provides a generic interface for estimating the convolution of full functional objects given some user specified residual or cost function.  The residual/cost function is then used, with the help of non-linear gradient decent, to project/resolve a set of particles for any one variable associated with a any factor.  In the binary variable factor case, such as the odometry tutorial, either pose X2 will be resolved from X1 using the user supplied likelihood residual function, or visa versa for X1 from X2.  </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note in a factor graph sense, the flow of time is captured in the structure of the graph and a requirement of the IncrementalInference system is that factors can be resolved towards any variable, given current estimates on all other variables connected to that factor.  Furthermore, this forwards or backwards resolving/convolution through a factor should adhere to the Kolmogorov Criterion of reversibility to ensure that detailed balance is maintained in the overall marginal posterior solutions.</p></div></div><p>The IncrementalInference (IIF) package provides a few generic conditional likelihood functions such as <code>LinearConditional</code> or <code>MixtureLinearConditional</code> which we will use in this illustration.  </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that the <a href="http://www.github.com/JuliaRobotics/RoME.jl">RoME.jl</a> package provides many more factors that are useful to robotics applications.  For a listing of current factors see <a href="http://www.juliarobotics.org/Caesar.jl/latest/concepts/available_varfacs.md">this docs page</a>, details on developing <a href="http://www.juliarobotics.org/Caesar.jl/latest/concepts/adding_variables_factors.md">your own factors on this page</a>.  One of the clear design objectives of the IIF package was to allow easier user extension of arbitrary residual functions that allows for vast capacity to represent non-Gaussian stochastic processes.</p></div></div><p>Consider a robot traveling in one dimension, progressing along the x-axis at varying speed.  Lets assume pose locations are determined by a constant delta-time rule of say one pose every second, named <code>X0</code>, <code>X1</code>, <code>X2</code>, and so on.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note the bread-crum discretization of the trajectory history by means of poses can later be used to allow estimation of previously unknown mapping parameters simultaneous to the ongoing localization problem.</p></div></div><p>Lets a few basic factor graph operations to develop the desired convolutions:</p><pre><code class="language-julia">using IncrementalInference

# empty factor graph container
fg = initfg()

# add two variables of interest
addVariable!(fg, :x0, ContinuousScalar)
addVariable!(fg, :x1, ContinuousScalar)

# gauge the solution by adding the first prior information that represents all history up to the current starting position for the robot
pr = Prior(Normal(0.0, 0.1))
addFactor!(fg, [:x0], pr)

# numerically initialize variable :x0 -- this avoids repeat computations later (specific to this tutorial)
doautoinit!(fg, :x0)

# lastly add the odometry conditional likelihood function between the two variables of interest
odo = LinearConditional(Rayleigh(...))
addFactor!(fg, [:x0;:x1], odo)  # note the list is order sensitive</code></pre><p>The code block above (not solved yet) describes a algebraic setup exactly equivalent to the convolution equation presented at the top of this page.  </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>IIF does not require the distribution functions to only be parametric, such as Normal, Rayleigh, mixture models, but also allows intensity based values or kernel density estimates.  Parametric types are just used here for ease of illustration.</p></div></div><p>To perform an stochastic approximate convolution with the odometry conditional, one can simply call a low level function used the mmisam solver:</p><pre><code class="language-julia">pts = approxConv(fg, :x0x1f1, :x1)</code></pre><p>The <code>approxConv</code> function call reads as a operation on <code>fg</code> which won&#39;t influence any values of parameter list (common Julia exclamation mark convention) and must use the first factor <code>:x0x1f1</code> to resolve a convolution on target variable <code>:x1</code>.  Implicitly, this result is based on the current estimate contained in <code>:x0</code>.  The value of <code>pts</code> is a <code>:;Array{Float64,2}</code> where the rows represent the different dimensions (1-D in this case) and the columns are each of the different samples drawn from the intermediate posterior (i.e. convolution result).  </p><p>IIF currently uses kernel density estimation to convert discrete samples into a smooth function estimate – more details can be found on the function <a href="http://www.juliarobotics.org/Caesar.jl/latest/principles/functionApprox/">approximation principles page here</a>.  The sample set can be converted into an on-manifold functional object as follows:</p><pre><code class="language-julia"># create kde object by referencing back the existing memory location pts
hatX1 = manikde!(pts, ContinuousScalar)</code></pre><p>The functional object <code>X1</code> is now ready for other operations such as function evaluation or product computations discussed on <a href="http://www.juliarobotics.org/Caesar.jl/latest/principles/multiplyingDensities/">another principles page</a>.  The <code>ContinuousScalar</code> manifold is just the real line in Euclidean space, internally denoted as single element tuple <code>(:Euclid,)</code>.</p><h2 id="A-Handy-ZMQ-interface-to-Generic-Convolutions-1"><a class="docs-heading-anchor" href="#A-Handy-ZMQ-interface-to-Generic-Convolutions-1">A Handy ZMQ interface to Generic Convolutions</a><a class="docs-heading-anchor-permalink" href="#A-Handy-ZMQ-interface-to-Generic-Convolutions-1" title="Permalink"></a></h2><blockquote><p><strong>NOTE</strong> WIP on expanding ZMQ interface:</p></blockquote><p>In addition, <code>ZmqCaesar</code> offers a <code>ZMQ</code> interface to the factor graph solution for multilanguage support.  This example is a small subset that shows how to use the <code>ZMQ</code> infrastructure, but avoids the larger factor graph related calls.</p><p>...</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../filterCorrespondence/">« Filters vs. Graphs</a><a class="docs-footer-nextpage" href="../multiplyingDensities/">Multiplying Functions (.py) »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 12 January 2020 18:22">Sunday 12 January 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
