<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Entry Tutorial: ContinuousScalar · Caesar.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Caesar.jl logo"/></a><h1>Caesar.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="getting_started.html">Getting Started</a></li><li><a class="toctext" href="examples.html">Examples</a></li><li class="current"><a class="toctext" href="tutorialcontinuousscalar.html">Entry Tutorial: ContinuousScalar</a><ul class="internal"><li><a class="toctext" href="#IncrementalInference.jl-ContinuousScalar-1">IncrementalInference.jl ContinuousScalar</a></li></ul></li><li><a class="toctext" href="tut_hexagonal2d.html">Entry Tutorial: Hexagonal 2D SLAM</a></li><li><a class="toctext" href="tut_slamedonut.html">Entry Tutorial: Singular Ranges-only SLAM</a></li><li><a class="toctext" href="definingfactors.html">Moderate Tutorial: Defining Factors</a></li><li><a class="toctext" href="arena_visualizations.html">Arena Visualization</a></li><li><a class="toctext" href="database_interactions.html">Offloading to Server</a></li><li><a class="toctext" href="func_ref.html">Functions</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="tutorialcontinuousscalar.html">Entry Tutorial: ContinuousScalar</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/Caesar.jl/blob/master/docs/src/tutorialcontinuousscalar.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Entry Tutorial: ContinuousScalar</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorials-1" href="#Tutorials-1">Tutorials</a></h1><h2><a class="nav-anchor" id="IncrementalInference.jl-ContinuousScalar-1" href="#IncrementalInference.jl-ContinuousScalar-1">IncrementalInference.jl ContinuousScalar</a></h2><p>This tutorial illustrates how <code>IncrementalInference</code> enables algebraic relations between stochastic variables, and how a final posterior belief estimate is calculated from several pieces of information. This tutorial is rather abstract and the user is free to imagine any system of relationships, for example a robot driving in a one dimensional world, or a time traveler making uncertain jumps forwards and backwards in time. The tutorial implicitly shows a multi-modal uncertainty introduced and transmitted. The tutorial also illustrates consensus through an additional piece of information, which reduces all stochastic variable marginal beliefs to unimodal only beliefs. The example will also illustrate the use of non-Gaussian beliefs and global inference. The tutorial also shows how to create user defined functions. Lastly, the tutorial demonstrates how automatic initialization of variables works.</p><p>This tutorial requires <code>IncrementalInference v0.3.0+, RoME v0.1.0, RoMEPlotting</code> packages be installed. In addition, the optional <code>GraphViz</code> package will allow easy visualization of the <code>FactorGraph</code> object structure.</p><p>To start, the two major mathematical packages are brought into scope.</p><pre><code class="language-julia">using Distributions
using IncrementalInference</code></pre><p>This tutorial calls for multiple variable nodes connected through algebraic functions stochastic uncertainty. User scope <code>Prior</code>, <code>LinearOffset</code>, and <code>MultiModalOffset</code> with arbitrary distributions are defined as:</p><pre><code class="language-julia">import IncrementalInference: getSample

struct Prior{T} &lt;: IncrementalInference.FunctorSingleton where T &lt;: Distribution
  z::T
end
getSample(s::Prior, N::Int=1) = (rand(s.z,N), )
struct LinearOffset{T} &lt;: IncrementalInference.FunctorPairwise where T &lt;: Distribution
  z::T
end
getSample(s::LinearOffset, N::Int=1) = (rand(s.z,N), )
function (s::LinearOffset)(res::Array{Float64},
      idx::Int,
      meas::Tuple{Array{Float64, 1}},
      X1::Array{Float64,2},
      X2::Array{Float64,2}  )
  #
  res[1] = meas[1][idx] - (X2[1,idx] - X1[1,idx])
  nothing
end
struct MultiModalOffset &lt;: IncrementalInference.FunctorPairwise
  z::Vector{Distribution}
  c::Categorical
end
getSample(s::MultiModalOffset, N::Int=1) = (rand.(s.z, N)..., rand(s.c, N))
function (s::MultiModalOffset)(res::Array{Float64},
      idx::Int,
      meas::Tuple,
      X1::Array{Float64,2},
      X2::Array{Float64,2}  )
  #
  res[1] = meas[meas[end][idx]][idx] - (X2[1,idx] - X1[1,idx])
  nothing
end</code></pre><p>Notice the residual function relating to the two <code>PairwiseFunctor</code> derived definitions. The one dimensional residual functions, <code>res[1] = measurement - prediction</code>, are used during inference to approximate the convolution of conditional beliefs from the sample approximate marginal beliefs of the connected variables.</p><p>Guidelines for developing your own functions are discussed here (TBD), and we note that mechanizations and manifolds required for robotic simultaneous localization and mapping (SLAM) has been tightly integrated with the expansion package <a href="http://www.github.com/dehann/RoME.jl">RoME.jl</a>.</p><p>The next step is to describe the inference problem with a graphical model of type <code>IncrementalInference.FactorGraph</code>. The first step is to create an empty factor graph object and start populating it with variable nodes. The variable nodes are identified by <code>Symbol</code>s, namely <code>:x0, :x1, :x2, :x3</code>.</p><pre><code class="language-julia"># Start with an empty factor graph
fg = emptyFactorGraph()

# add the first node
addNode!(fg, :x0, ContinuousScalar)

# this is unary (prior) factor and does not immediately trigger autoinit of :x0.
addFactor!(fg, [:x0], Prior(Normal(0,1)))</code></pre><p>Factor graphs are bipartite graphs with <code>factors</code> that act as mathematical structure between interacting <code>variables</code>. After adding node <code>:x0</code>, a singleton factor of type <code>Prior</code> (which was defined by the user earlier) is &#39;connected to&#39; variable node <code>:x0</code>. This unary factor is taken as a <code>Distributions.Normal</code> distribution with zero mean and a standard devitation of <code>1</code>. <code>GraphViz.jl</code> can be used to visualize the factor graph structure, although the package is not installed by default. Furthermore, the <code>writeGraphPdf</code> member definition is given at the end of this tutorial, which allows the user to store the graph image in graphviz supported image types.</p><pre><code class="language-julia">Graphs.plot(fg.g)
# writeGraphPdf(fg, file=&quot;fgx01.pdf&quot;) # file=&quot;fgx01.png&quot;</code></pre><p>The two node factor graph is shown in the image below.</p><p align="center">
<img src="assets/tutorials/ContinuousScalar/fgx0.png" width="120" border="0" />
</p><p>Automatic initialization of variables depend on how the factor graph model is constructed. This tutorial demonstrates this behavior by first showing that <code>:x0</code> is not initialized:</p><pre><code class="language-julia">@show isInitialized(fg, :x0) # false</code></pre><p>Why is <code>:x0</code> not initialized? Since no other variable nodes have been &#39;connected to&#39; (or depend) on <code>:x0</code> and future intentions of the user are unknown, the initialization of <code>:x0</code> is deferred until the latest possible moment. <code>IncrementalInference.jl</code> assumes that the user will generally populate new variable nodes with most of the associated factors before moving to the next variable. By delaying initialization of a new variable (say <code>:x0</code>) until a second newer uninitialized variable (say <code>:x1</code>) depends on <code>:x0</code>, the <code>IncrementalInference</code> algorithms hope to then initialize <code>:x0</code> with the more information from previous and surrounding variables and factors. Also note that initialization of variables is a local operation based only on the neighboring nodes – global inference will over the entire graph is shows later in this tutorial.</p><p>By adding <code>:x1</code> and connecting it through the <code>LinearOffset</code> and <code>Normal</code> distributed factor, the automatic initialization of <code>:x0</code> is triggered.</p><pre><code class="language-julia">addNode!(fg, :x1, ContinuousScalar)
# P(Z | :x1 - :x0 ) where Z ~ Normal(10,1)
addFactor!(fg, [:x0, :x1], LinearOffset(Normal(10.0,1)))
@show isInitialized(fg, :x0) # true</code></pre><p>Note that the automatic initialization of <code>:x0</code> is aware that <code>:x1</code> is not initialized and therefore only used the <code>Prior(Normal(0,1))</code> unary factor to initialize the marginal belief estimate for <code>:x0</code>. The structure of the graph has now been updated to two variable nodes and two factors.</p><p align="center">
<img src="assets/tutorials/ContinuousScalar/fgx01.png" width="240" border="0" />
</p><p>Global inference requires that the entire factor graph be initialized before the numerical belief computation algorithms can be performed. Notice how the new <code>:x1</code> variable is not yet initialized:</p><pre><code class="language-julia">@show isInitialized(fg, :x1) # false</code></pre><p>The <code>RoMEPlotting.jl</code> package allows visualization (plotting) of the belief state over any of the variable nodes. Remember the first time executions are slow given required code compilation, and that future versions of these package will use more precompilation to reduce first execution running cost.</p><pre><code class="language-julia">using RoMEPlotting

plotKDE(fg, :x0)</code></pre><p align="center">
<img src="assets/tutorials/ContinuousScalar/plx0.png" width="360" border="0" />
</p><p>By forcing the initialization of <code>:x1</code> and plotting its belief estimate,</p><pre><code class="language-julia">ensureAllInitialized!(fg)
plotKDE(fg, [:x0, :x1])</code></pre><p>the predicted influence of the <code>P(Z| X1 - X0) = LinearOffset(Normal(10, 1))</code> is shown by the red trace.</p><p align="center">
<img src="assets/tutorials/ContinuousScalar/plx01.png" width="360" border="0" />
</p><p>The red trace (predicted belief of <code>:x1</code>) is noting more than the approximated convolution of the current marginal belief of <code>:x0</code> with the conditional belief described by <code>P(Z | X1 - X0)</code>.</p><p>Another <code>ContinuousScalar</code> variable <code>:x2</code> is &#39;connected&#39; to <code>:x1</code> through a more complicated <code>MultiModalOffset</code> likelihood function.</p><pre><code class="language-julia">addNode!(fg, :x2, ContinuousScalar)
mmo = MultiModalOffset([Rayleigh(3); Uniform(30,55)], Categorical([0.4; 0.6]))
addFactor!(fg, [:x1, :x2], mmo)</code></pre><p align="center">
<img src="assets/tutorials/ContinuousScalar/fgx012.png" width="360" border="0" />
</p><p>The <code>mmo</code> variable illustrates how a near arbitrary mixture probability distribution can be used as a conditional relationship between variable nodes in the factor graph. In this case, a 40%/60% balance of a Rayleigh and truncated Uniform distribution which acts as a multi-modal conditional belief. Interpret carefully what a conditional belief of this nature actually means.</p><p>Following the tutorial&#39;s practical example frameworks (robot navigation or time travel), this multi-modal belief implies that moving from one of the probable locations in <code>:x1</code> to a location in <code>:x2</code> by some processes defined by <code>mmo=P(Z | X2, X1)</code> is uncertain to the same 40%/60% ratio. In practical terms, collapsing (through observation of an event) the probabilistic likelihoods of the transition from <code>:x1</code> to <code>:x2</code> may result in the <code>:x2</code> location being at either 15-20, or 40-65-ish units. The predicted belief over <code>:x2</code> is illustrated by plotting the predicted belief (green trace), after forcing initialization.</p><pre><code class="language-julia">ensureAllInitialized!(fg)
plotKDE(fg, [:x0, :x1, :x2])</code></pre><p align="center">
<img src="assets/tutorials/ContinuousScalar/plx012.png" width="360" border="0" />
</p><p>Adding one more variable <code>:x3</code> through another <code>LinearOffset(Normal(-50,1))</code></p><pre><code class="language-julia">addNode!(fg, :x3, ContinuousScalar)
addFactor!(fg, [:x2, :x3], LinearOffset(Normal(-50, 1)))</code></pre><p>expands the factor graph to to four variables and four factors.</p><p align="center">
<img src="assets/tutorials/ContinuousScalar/fgx0123.png" width="480" border="0" />
</p><p>This part of the tutorial shows how a unimodal likelihood (conditional belief) can transmit the bimodal belief currently contained in <code>:x2</code>.</p><pre><code class="language-julia">ensureAllInitialized!(fg)
plotKDE(fg, [:x0, :x1, :x2, :x3])</code></pre><p>Notice the blue trace (<code>:x3</code>) is a shifted and slightly spread out version of the initialized belief on <code>:x2</code>, through the convolution with the conditional belief <code>P(Z | X2, X3)</code>.</p><p align="center">
<img src="assets/tutorials/ContinuousScalar/plx0123.png" width="480" border="0" />
</p><p>Global inference over the entire factor graph has still not occurred, and will at this stage produce roughly similar results to the predicted beliefs shown above. Only by introducing more information into the factor graph can inference extract more precise marginal belief estimates for each of the variables. A final piece of information added to this graph is a factor directly relating <code>:x3</code> with <code>:x0</code>.</p><pre><code class="language-julia">addFactor!(fg, [:x3, :x0], LinearOffset(Normal(40, 1)))</code></pre><p>Pay close attention to what this last factor means in terms of the probability density traces shown in the previous figure. The blue trace for <code>:x3</code> has two major modes, one that overlaps with <code>:x0, :x1</code> near 0 and a second mode further to the left at -40. The last factor introduces a shift <code>LinearOffset(Normal(40,1))</code> which essentially aligns the left most mode of <code>:x3</code> back onto <code>:x0</code>.</p><p align="center">
<img src="assets/tutorials/ContinuousScalar/fgx0123c.png" width="480" border="0" />
</p><p>This last factor forces a mode selection through consensus. By doing global inference, the new information obtained in <code>:x3</code> will be equally propagated to <code>:x2</code> where only one of the two modes will remain.</p><p>Global inference is achieved with local computation using two function calls, as follows.</p><pre><code class="language-julia">tree = wipeBuildNewTree!(fg)
inferOverTree!(fg, tree)

# and visualization
plotKDE(fg, [:x0, :x1, :x2, :x3])</code></pre><p>The resulting posterior marginal beliefs over all the system variables are:</p><p align="center">
<img src="assets/tutorials/ContinuousScalar/plx0123infr.png" width="480" border="0" />
</p><p>It is import to note that although this tutorial ends with all marginal beliefs having near Gaussian shape and are unimodal, that the package supports multi-modal belief estimates during both the prediction and global inference processes. In fact, many of the same underlying inference functions are involved with the automatic initialization process and the global multi-modal iSAM inference procedure. This concludes the ContinuousScalar tutorial particular to the <code>IncrementalInference</code> package.</p><footer><hr/><a class="previous" href="examples.html"><span class="direction">Previous</span><span class="title">Examples</span></a><a class="next" href="tut_hexagonal2d.html"><span class="direction">Next</span><span class="title">Entry Tutorial: Hexagonal 2D SLAM</span></a></footer></article></body></html>
